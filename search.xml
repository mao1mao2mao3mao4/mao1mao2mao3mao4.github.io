<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 事件系统使用手册</title>
      <link href="/posts/b3bc6fe5.html"/>
      <url>/posts/b3bc6fe5.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-事件系统使用手册"><a href="#C-事件系统使用手册" class="headerlink" title="C++ 事件系统使用手册"></a>C++ 事件系统使用手册</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本手册提供了 C++ 事件系统的使用指南。事件系统允许对象订阅和接收特定类型的事件通知，从而实现对象之间的解耦。本系统基于 <code>EventManager</code>模块、<code>GameEvent</code>模块 <code>Delegate</code> 模块，<strong>支持使用 lambda 表达式来封装事件处理函数。</strong></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在使用事件系统之前，请确保以下依赖库已正确配置：</p><ul><li><code>EventManager.h</code>: 事件管理器头文件，包含事件注册、发送和注销等功能。</li><li><code>iostream</code>: 输入输出流库，用于示例中的打印操作。</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>事件 (Event): 代表发生的事情，可以被订阅和触发。</li><li>委托 (Delegate): 用于封装事件处理函数，可以是 lambda 表达式、函数指针或函数对象。</li></ul><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="1-定义事件处理函数"><a href="#1-定义事件处理函数" class="headerlink" title="1. 定义事件处理函数"></a>1. 定义事件处理函数</h3><p>事件处理函数应该接受一个事件对象作为参数，并执行相应的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(MyEvent* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TEST1&quot;</span> &lt;&lt; a-&gt;message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建委托并注册事件"><a href="#2-创建委托并注册事件" class="headerlink" title="2. 创建委托并注册事件"></a>2. 创建委托并注册事件</h3><p>使用 lambda 表达式创建委托，并将其注册到事件管理器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST1</span>()</span><br><span class="line">&#123;</span><br><span class="line">    d = [<span class="keyword">this</span>](MyEvent* a) &#123;<span class="keyword">this</span>-&gt;<span class="built_in">Func</span>(a); &#125;;</span><br><span class="line">    EventManager::<span class="built_in">Register</span>&lt;MyEvent&gt;(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-触发事件"><a href="#3-触发事件" class="headerlink" title="3. 触发事件"></a>3. 触发事件</h3><p>创建事件对象，设置必要的信息，并通过事件管理器发送。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Trigger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> evt = MyEvent::<span class="built_in">Get</span>();</span><br><span class="line">    evt-&gt;message = <span class="string">&quot;世界&quot;</span>;</span><br><span class="line">    EventManager::<span class="built_in">SendEvent</span>(evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注销事件"><a href="#4-注销事件" class="headerlink" title="4. 注销事件"></a>4. 注销事件</h3><p>当不再需要监听事件时，应注销委托。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventManager::<span class="built_in">Unregister</span>&lt;MyEvent&gt;(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-事件对象池管理"><a href="#5-事件对象池管理" class="headerlink" title="5. 事件对象池管理"></a>5. 事件对象池管理</h3><p>事件对象使用完毕后，应放回对象池以便重用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evt-&gt;<span class="built_in">Dispose</span>();</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是一个完整的示例，展示了如何使用事件系统。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TEST</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TEST2 t2;</span><br><span class="line">        TEST1 t1;</span><br><span class="line">        TEST3 t3;</span><br><span class="line"></span><br><span class="line">        t<span class="number">1.</span><span class="built_in">Trigger</span>(); <span class="comment">// 触发事件</span></span><br><span class="line"></span><br><span class="line">        t<span class="number">3.</span><span class="built_in">Remove</span>(); <span class="comment">// 注销事件</span></span><br><span class="line"></span><br><span class="line">        t<span class="number">1.</span><span class="built_in">Trigger</span>(); <span class="comment">// 再次触发事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用委托</span></span><br><span class="line">        Delegate&lt;TEST1Event*&gt; d;</span><br><span class="line">        d = [](TEST1Event* event) &#123;<span class="built_in">Func1</span>(event); &#125;;</span><br><span class="line">        EventManager::<span class="built_in">Register</span>&lt;TEST1Event&gt;(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册多个事件处理函数</span></span><br><span class="line">        Delegate&lt;TEST1Event*&gt; d1;</span><br><span class="line">        d1 = [](TEST1Event* event) &#123;<span class="built_in">Func2</span>(event); &#125;;</span><br><span class="line">        EventManager::<span class="built_in">Register</span>&lt;TEST1Event&gt;(d1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> d2 = d1;</span><br><span class="line">        d2 = [](TEST1Event* event) &#123;<span class="built_in">Func3</span>(event); &#125;;</span><br><span class="line">        EventManager::<span class="built_in">Register</span>&lt;TEST1Event&gt;(d2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事件的使用</span></span><br><span class="line">        <span class="keyword">auto</span> evt = TEST1Event::<span class="built_in">Get</span>();</span><br><span class="line">        EventManager::<span class="built_in">Unregister</span>&lt;TEST1Event&gt;(d2); <span class="comment">// 注销事件</span></span><br><span class="line">        EventManager::<span class="built_in">SendEvent</span>(evt); <span class="comment">// 发送事件</span></span><br><span class="line">        evt-&gt;<span class="built_in">Dispose</span>(); <span class="comment">// 事件对象放回对象池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>确保事件处理函数的参数类型与事件类型匹配。</li><li>在注册委托之前，请检查事件处理函数的有效性。</li><li>委托Delegate的模板参数是目标方法需求的参数类型，事件系统EventManger的模板参数是注册的事件类型</li></ul><h2 id="各模块解释"><a href="#各模块解释" class="headerlink" title="各模块解释"></a>各模块解释</h2><p><a href="https://mao1mao2mao3mao4.github.io/posts/773e9c7e.html">游戏事件池实现解释文档 | mao的博客 (mao1mao2mao3mao4.github.io)</a></p><p><a href="https://mao1mao2mao3mao4.github.io/posts/b66f79ee.html">EventManager 和 EventCallbackList 类解释文档 | mao的博客 (mao1mao2mao3mao4.github.io)</a></p><p><a href="https://mao1mao2mao3mao4.github.io/posts/b29a7baf.html">Delegate 类模板解释文档 | mao的博客 (mao1mao2mao3mao4.github.io)</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本手册提供了 C++ 事件系统的基础使用指南。通过遵循上述步骤，开发者可以有效地在应用程序中实现事件驱动的设计模式。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏事件池实现解释文档</title>
      <link href="/posts/773e9c7e.html"/>
      <url>/posts/773e9c7e.html</url>
      
        <content type="html"><![CDATA[<h1 id="游戏事件池实现解释文档"><a href="#游戏事件池实现解释文档" class="headerlink" title="游戏事件池实现解释文档"></a>游戏事件池实现解释文档</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文件提供了一个基于对象池的游戏事件池的实现。它包括一个模板类 <code>GameEventPool</code> 用于管理事件对象，以及一个抽象基类 <code>GameEventBase</code> 和一个模板类 <code>GameEvent</code> 用于定义和创建具体的游戏事件。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;stack&gt;</code>: 提供了栈数据结构，用于存储事件对象。</li><li><code>&lt;unordered_set&gt;</code>: 提供了哈希集合数据结构，用于快速查找和确保对象唯一性。</li><li><code>&lt;string&gt;</code>: 提供了字符串类，用于存储事件信息。</li></ul><h2 id="GameEventPool-类模板"><a href="#GameEventPool-类模板" class="headerlink" title="GameEventPool 类模板"></a>GameEventPool 类模板</h2><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="Push-T-item"><a href="#Push-T-item" class="headerlink" title="Push(T* item)"></a>Push(T* item)</h4><ul><li>将一个事件对象推入池中。如果对象已存在，则不重复添加。</li></ul><h4 id="Get"><a href="#Get" class="headerlink" title="Get()"></a>Get()</h4><ul><li>从池中获取一个事件对象。如果池为空，则创建一个新的对象实例。</li></ul><h3 id="私有成员函数"><a href="#私有成员函数" class="headerlink" title="私有成员函数"></a>私有成员函数</h3><h4 id="Init-T-item"><a href="#Init-T-item" class="headerlink" title="Init(T* item)"></a>Init(T* item)</h4><ul><li>初始化事件对象。</li></ul><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul><li><code>_pool</code>: 存储事件对象的栈。</li><li><code>_poolSet</code>: 存储事件对象的集合，用于确保对象唯一性。</li></ul><h2 id="GameEventBase-类"><a href="#GameEventBase-类" class="headerlink" title="GameEventBase 类"></a>GameEventBase 类</h2><h3 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="GameEventBase"><a href="#GameEventBase" class="headerlink" title="~GameEventBase()"></a>~GameEventBase()</h4><ul><li>虚析构函数，确保派生类的析构函数可以被正确调用。</li></ul><h4 id="static-int-GetEventId"><a href="#static-int-GetEventId" class="headerlink" title="static int GetEventId()"></a>static int GetEventId()</h4><ul><li>生成并返回一个唯一的事件ID。</li></ul><h3 id="静态成员变量-1"><a href="#静态成员变量-1" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul><li><code>_eventCount</code>: 存储事件ID的计数。</li></ul><h2 id="GameEvent-类模板"><a href="#GameEvent-类模板" class="headerlink" title="GameEvent 类模板"></a>GameEvent 类模板</h2><h3 id="成员函数-2"><a href="#成员函数-2" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="GameEvent"><a href="#GameEvent" class="headerlink" title="GameEvent()"></a>GameEvent()</h4><ul><li>构造函数，如果事件ID尚未设置，则设置它。</li></ul><h4 id="Dispose"><a href="#Dispose" class="headerlink" title="Dispose()"></a>Dispose()</h4><ul><li>将当前事件对象推回池中。</li></ul><h4 id="static-T-Get"><a href="#static-T-Get" class="headerlink" title="static T* Get()"></a>static T* Get()</h4><ul><li>从池中获取事件对象。</li></ul><h4 id="static-void-Push-T-item"><a href="#static-void-Push-T-item" class="headerlink" title="static void Push(T* item)"></a>static void Push(T* item)</h4><ul><li>向池中推入事件对象。</li></ul><h3 id="静态成员变量-2"><a href="#静态成员变量-2" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul><li><code>eventId</code>: 存储事件类型的ID。</li></ul><h2 id="MyEvent-类"><a href="#MyEvent-类" class="headerlink" title="MyEvent 类"></a>MyEvent 类</h2><ul><li>继承自 <code>GameEvent&lt;MyEvent&gt;</code>，表示一个具体的游戏事件。</li><li>包含一个 <code>message</code> 成员变量，用于存储事件信息。</li></ul><h2 id="TEST1Event-类"><a href="#TEST1Event-类" class="headerlink" title="TEST1Event 类"></a>TEST1Event 类</h2><ul><li>继承自 <code>GameEvent&lt;TEST1Event&gt;</code>，表示另一个具体的游戏事件。</li><li>包含一个 <code>message</code> 成员变量，用于存储事件信息。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>使用本文件时，需要确保依赖的库已经正确配置。</li><li>在调用 <code>GameEventPool</code> 的 <code>Push</code> 和 <code>Get</code> 函数时，需要检查输入参数的有效性。</li><li>本文件中的某些函数可能存在性能瓶颈，请谨慎使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventManager 和 EventCallbackList 类解释文档</title>
      <link href="/posts/b66f79ee.html"/>
      <url>/posts/b66f79ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="EventManager-和-EventCallbackList-类解释文档"><a href="#EventManager-和-EventCallbackList-类解释文档" class="headerlink" title="EventManager 和 EventCallbackList 类解释文档"></a>EventManager 和 EventCallbackList 类解释文档</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>该文档描述了 <code>EventManager</code> 和 <code>EventCallbackList</code> 类，它们共同构成了一个游戏事件的分级广播管理系统。该系统允许注册、注销和触发事件，每个事件可以有不同的优先级。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameEvent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delegate.h&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;vector&gt;</code>: 用于存储回调列表。</li><li><code>&lt;functional&gt;</code>: 提供了 <code>std::function</code>。</li><li><code>&lt;unordered_map&gt;</code>: 用于快速查找事件信息。</li><li><code>&quot;GameEvent.h&quot;</code>: 包含游戏事件基类定义。</li><li><code>&quot;Delegate.h&quot;</code>: 包含委托类定义。</li></ul><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int MAX_PRIORITY_COUNT = 11;</span><br></pre></td></tr></table></figure><ul><li><code>MAX_PRIORITY_COUNT</code>: 定义了最大优先级数量，优先级从 0 到 10。</li></ul><h2 id="GameEventPriority-类"><a href="#GameEventPriority-类" class="headerlink" title="GameEventPriority 类"></a>GameEventPriority 类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class GameEventPriority &#123;</span><br><span class="line">public:</span><br><span class="line">    const int Low = 0;</span><br><span class="line">    const int Middle = 5;</span><br><span class="line">    const int High = 10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>GameEventPriority</code>: 定义了事件的优先级常量。</li></ul><h2 id="EventCallbackList-类"><a href="#EventCallbackList-类" class="headerlink" title="EventCallbackList 类"></a>EventCallbackList 类</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventCallbackList();</span><br></pre></td></tr></table></figure><ul><li>初始化回调列表和缓存列表。</li></ul><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="Add"><a href="#Add" class="headerlink" title="Add()"></a>Add()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Add(Delegate&lt;GameEventBase*&gt;&amp; action, int priority);</span><br></pre></td></tr></table></figure><ul><li>向回调列表中添加一个委托，并指定其优先级。</li></ul><h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove()"></a>Remove()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Remove(Delegate&lt;GameEventBase*&gt;&amp; delegate, int priority);</span><br></pre></td></tr></table></figure><ul><li>从回调列表中移除指定的委托。</li></ul><h4 id="Invoke"><a href="#Invoke" class="headerlink" title="Invoke()"></a>Invoke()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Invoke(GameEventBase* evt);</span><br></pre></td></tr></table></figure><ul><li>触发所有注册的回调，按照优先级从高到低调用。</li></ul><h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><ul><li><code>callbackLists</code>: 存储回调列表。</li><li><code>cacheCallbackLists</code>: 存储缓存列表。</li><li><code>cacheDirty</code>: 标记缓存是否需要更新。</li><li><code>invokeCount</code>: 记录当前正在触发的回调数量。</li></ul><h3 id="私有成员函数"><a href="#私有成员函数" class="headerlink" title="私有成员函数"></a>私有成员函数</h3><h4 id="GetCallbacks"><a href="#GetCallbacks" class="headerlink" title="GetCallbacks()"></a>GetCallbacks()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Delegate&lt;GameEventBase*&gt;&gt;* GetCallbacks();</span><br></pre></td></tr></table></figure><ul><li>返回当前应该操作的回调列表，如果是触发阶段则返回缓存列表。</li></ul><h2 id="EventManager-类"><a href="#EventManager-类" class="headerlink" title="EventManager 类"></a>EventManager 类</h2><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul><li><code>_events</code>: 存储所有事件的回调列表。</li><li><code>_findEvents</code>: 用于快速查找事件信息。</li></ul><h3 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register()"></a>Register()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">static void Register(Delegate&lt;T*&gt;&amp; callback, int priority = 5);</span><br></pre></td></tr></table></figure><ul><li>注册一个事件回调，并指定优先级。</li></ul><h4 id="Unregister"><a href="#Unregister" class="headerlink" title="Unregister()"></a>Unregister()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">static void Unregister(Delegate&lt;T*&gt;&amp; callback);</span><br></pre></td></tr></table></figure><ul><li>注销一个事件回调。</li></ul><h4 id="SendEvent"><a href="#SendEvent" class="headerlink" title="SendEvent()"></a>SendEvent()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">static void SendEvent(T* evt);</span><br></pre></td></tr></table></figure><ul><li>触发一个事件，调用所有注册的回调。</li></ul><h3 id="私有结构"><a href="#私有结构" class="headerlink" title="私有结构"></a>私有结构</h3><h4 id="EventInfo"><a href="#EventInfo" class="headerlink" title="EventInfo"></a>EventInfo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct EventInfo &#123;</span><br><span class="line">    int eventId;</span><br><span class="line">    int priority;</span><br><span class="line">    Delegate&lt;GameEventBase*&gt; action;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>存储事件信息，包括事件ID、优先级和委托。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>确保 <code>GameEvent</code> 和 <code>Delegate</code> 类已经正确实现。</li><li>使用 <code>EventManager</code> 时，应检查回调的有效性。</li><li>事件优先级应在有效范围内（0 到 10）。</li><li>在事件触发期间，不应修改回调列表。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delegate 类模板解释文档</title>
      <link href="/posts/b29a7baf.html"/>
      <url>/posts/b29a7baf.html</url>
      
        <content type="html"><![CDATA[<h1 id="Delegate-类模板解释文档"><a href="#Delegate-类模板解释文档" class="headerlink" title="Delegate 类模板解释文档"></a>Delegate 类模板解释文档</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Delegate</code> 类模板是一个单播委托类，它封装了 C++ 的可变参数模板和 <code>std::function</code>，用于存储和调用具有任意数量参数的方法，但仅支持返回值为 <code>void</code> 类型的方法。委托类可以看作是函数指针的一个更灵活的替代品，它允许存储和调用任何可调用的目标（如函数、lambda 表达式、函数对象等）。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;functional&gt;</code>: 提供了 <code>std::function</code>，用于封装函数对象。</li><li><code>&lt;stdexcept&gt;</code>: 提供了标准异常类，如 <code>std::runtime_error</code>。</li></ul><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><h3 id="成员类型别名"><a href="#成员类型别名" class="headerlink" title="成员类型别名"></a>成员类型别名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FunctionType = std::function&lt;<span class="built_in">void</span>(Args...)&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>FunctionType</code>: 类型别名，用于表示可以接受任意数量参数并返回 <code>void</code> 的函数类型。</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Delegate</span>(<span class="type">int</span> hashCode);</span><br><span class="line"><span class="built_in">Delegate</span>();</span><br><span class="line"><span class="built_in">Delegate</span>(<span class="type">const</span> FunctionType&amp; func);</span><br></pre></td></tr></table></figure><ul><li>Delegate(int hashCode)&#96;: 构造一个无效的委托，并设置一个哈希码。</li><li><code>Delegate()</code>: 默认构造函数，构造一个无效的委托。</li><li><code>Delegate(const FunctionType&amp; func)</code>: 使用给定的函数对象构造一个委托，并从函数对象中获取哈希码。</li></ul><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="IsValid"><a href="#IsValid" class="headerlink" title="IsValid()"></a>IsValid()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ul><li>检查委托是否有效（即是否已绑定到一个函数）。</li></ul><h4 id="Invoke"><a href="#Invoke" class="headerlink" title="Invoke()"></a>Invoke()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Args... args)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>调用委托绑定的函数，并传递任意数量的参数。如果委托无效，则抛出 <code>std::runtime_error</code> 异常。</li></ul><h4 id="operator"><a href="#operator" class="headerlink" title="operator&#x3D;&#x3D;()"></a>operator&#x3D;&#x3D;()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Delegate&amp; other) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><ul><li>比较两个委托是否相等，基于它们的哈希码。</li></ul><h4 id="operator-1"><a href="#operator-1" class="headerlink" title="operator&#x3D;()"></a>operator&#x3D;()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Delegate&amp; <span class="keyword">operator</span>=(<span class="type">const</span> FunctionType&amp; func);</span><br></pre></td></tr></table></figure><ul><li>将委托绑定到新的函数对象，并更新哈希码。</li></ul><h4 id="operator-2"><a href="#operator-2" class="headerlink" title="operator!&#x3D;()"></a>operator!&#x3D;()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Delegate&amp; other) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><ul><li>检查两个委托是否不相等。</li></ul><h4 id="GetHashCode"><a href="#GetHashCode" class="headerlink" title="GetHashCode()"></a>GetHashCode()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetHashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>返回委托的哈希码。</li></ul><h4 id="SetHashCode"><a href="#SetHashCode" class="headerlink" title="SetHashCode()"></a>SetHashCode()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetHashCode</span><span class="params">(<span class="type">int</span> hashCode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>设置委托的哈希码。哈希码只能手动设置一次。</li></ul><h2 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FunctionType function;</span><br><span class="line"><span class="type">int</span> _hashCode = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> _isHandSetHashCode = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li><code>function</code>: 存储委托绑定的函数对象。</li><li><code>_hashCode</code>: 存储函数对象的哈希码，用于比较委托。</li><li><code>_isHandSetHashCode</code>: 标记哈希码是否已被手动设置。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>委托类仅支持返回值为 <code>void</code> 的函数。</li><li>在调用 <code>Invoke</code> 方法之前，应先检查委托是否有效。</li><li>哈希码用于比较委托，如果函数对象的参数类型可能发生转换，应手动设置哈希码以确保正确比较。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— 2D，glow效果</title>
      <link href="/posts/5a9886b9.html"/>
      <url>/posts/5a9886b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="2DGlow效果"><a href="#2DGlow效果" class="headerlink" title="2DGlow效果"></a>2DGlow效果</h1><p>让2D图片固定部分呈现出发光效果</p><h1 id="工程准备"><a href="#工程准备" class="headerlink" title="工程准备"></a>工程准备</h1><p>按照以下链接所示准备一个使用2D灯光的工程，即2Durp</p><p><a href="http://localhost:4000/posts/4abb1517.html">Unity —— 2D渲染光照迁移 | mao的博客</a></p><p>不过对于配置文件需要额外勾选 Dept Texture这一个选项</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220181304.png" alt="image-20241220181301267"></p><h1 id="Shader准备"><a href="#Shader准备" class="headerlink" title="Shader准备"></a>Shader准备</h1><p>使用到2Durp渲染管线，光照大部分被替换为 2D-lit，此时手写Unit Shader可能不能达到预期的效果，因此使用ShaderGraph</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220175745.png" alt="image-20241220175742463"></p><p>具体Shader实现如下图所示</p><p>每一方块对应的是在 Shader 中 的代码操作</p><p><strong>注意</strong></p><p>需要在ShaderGraph中准备一个主贴图，名称应该是MainTex，按照普通Shader文件的代码编写方式，需要有下划线_，来作为属性在shader中的引用</p><p>这Unity2021lts版本中，创建和修改对着两个属性的修改是自动进行的</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220175548.png" alt="image-20241220175532263"  /><p>Shader准备完成后，新建一个Material来承载即可，具体步骤和一般的Material和Shader对应没有差别</p><h1 id="素材准备"><a href="#素材准备" class="headerlink" title="素材准备"></a>素材准备</h1><p>将素材中不需要发光的部分涂黑即可</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220180510.png" alt="image-20241220180507272"></p><p>简单呈现效果</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220180815.png" alt="image-20241220180534446"></p><p>实际上最终不必要是下半黑色，因为素材的关系这里才是这样</p><p><strong>教程链接</strong></p><p><a href="https://www.bilibili.com/video/BV1RY41167ff?vd_source=0c56e77847d28781d8cdd412054492d9">https://www.bilibili.com/video/BV1RY41167ff?vd_source=0c56e77847d28781d8cdd412054492d9</a></p><p>参照教程中的内容，实际效果应该是这样的</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220180812.png" alt="image-20241220180809185"></p><p><strong>因此这里还不算是准备完成，需要有去krita中准备素材这一步</strong></p><h1 id="后期Volume准备"><a href="#后期Volume准备" class="headerlink" title="后期Volume准备"></a>后期Volume准备</h1><p>需要在场景中准备一个global Volume</p><p>配置参照下图第二个就可以</p><p>第一个的话 的 Profile 属性栏 可以 new一个</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220181132.png" alt="image-20241220181034821"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220181134.png" alt="image-20241220181003945"></p><h1 id="相机处理"><a href="#相机处理" class="headerlink" title="相机处理"></a>相机处理</h1><p>最后还需要对摄像机进行处理，不这样设置的话最后在Game窗口中是没有办法看见效果的</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220182126.png" alt="image-20241220181541170"></p>]]></content>
      
      
      <categories>
          
          <category> Unity2D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 特效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— 2D渲染光照迁移</title>
      <link href="/posts/4abb1517.html"/>
      <url>/posts/4abb1517.html</url>
      
        <content type="html"><![CDATA[<h1 id="2D光照渲染迁移"><a href="#2D光照渲染迁移" class="headerlink" title="2D光照渲染迁移"></a>2D光照渲染迁移</h1><p>本篇文章大体内容是通过Unity2D 核心渲染模板来将项目加载到2D光照渲染下</p><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p><strong>提示</strong></p><p>文章使用功能的Unity版本是2021 lts</p><p>选用2D核心模板</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220163757.png" alt="image-20241220163754193"></p><h1 id="package导入"><a href="#package导入" class="headerlink" title="package导入"></a>package导入</h1><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220163537.png" alt="image-20241220163529083"></p><h1 id="配置文件创建"><a href="#配置文件创建" class="headerlink" title="配置文件创建"></a>配置文件创建</h1><p>经历完以上步骤后，在Assets的新建面板上才会有Rendering的选项</p><p>按照按照以下步骤进行配置文件创建</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220164035.png" alt="image-20241220164029435" style="zoom:67%;" /><p>最后会出现两个配置文件，具体做什么不需要去管，两个配置文件的联系在上一步的操作中已经被建立</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220164255.png" alt="image-20241220164250689"></p><h1 id="更改项目配置"><a href="#更改项目配置" class="headerlink" title="更改项目配置"></a>更改项目配置</h1><p>进入到Project Settings中更改配置</p><p><strong>补充</strong><br>该窗口通过Unity编辑器左上角开始第二个选项 Edit 进入</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220164532.png" alt="image-20241220164529129"></p><h1 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h1><p>以上步骤操作正确后，在创建中新建一个2DSprite，对应的配置如如下图所示即为正确</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220165143.png" alt="image-20241220165104804"></p><p>相应的，灯光也要使用2D的，即如下图所示的内容</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220182057.png" alt="image-20241220165344528"></p><p><strong>成果示意</strong></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241220182100.png" alt="image-20241220165451148"></p><p>因为项目从一开始就是从零开始创建，不确定下面博客中最后的升级场景素材是否需要</p><p><a href="https://blog.csdn.net/m0_63673681/article/details/128725905">Unity-2D光源使用讲解_unity2d光源-CSDN博客</a></p><p>同时，对应位置的升级素材选项在本文章使用的版本中也不可见</p>]]></content>
      
      
      <categories>
          
          <category> Unity2D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 2D渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pixiv的作品id使用</title>
      <link href="/posts/32419e40.html"/>
      <url>/posts/32419e40.html</url>
      
        <content type="html"><![CDATA[<h1 id="图片id使用"><a href="#图片id使用" class="headerlink" title="图片id使用"></a>图片id使用</h1><p><a href="https://www.pixiv.net/artworks/">https://www.pixiv.net/artworks/</a></p><p>在以上网址的后面加上作品id即可</p>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pixiv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity——热更</title>
      <link href="/posts/62d8d43f.html"/>
      <url>/posts/62d8d43f.html</url>
      
        <content type="html"><![CDATA[<h1 id="热更"><a href="#热更" class="headerlink" title="热更"></a>热更</h1><p>主要流程：</p><p>1，设置热更配表数据结构</p><p>2，生成热更包及热更配表放到服务器</p><p>3，下载热更配置表读取需要热更文件</p><p>4，下载热更文件</p><p>5，游戏中加载热更</p><p>其他：</p><p>1，自动生成热更包及自动生成热更配置表</p><p>2，本地记录下载热更版本，方便比较</p><p>3，热更下载中断等处理</p><p>4，热更资源下载后校验</p><p>5，热更回退</p><p>6，资源加密，解密</p><p>7，资源解压</p>]]></content>
      
      
      <categories>
          
          <category> 热更 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 热更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua语法</title>
      <link href="/posts/c0acd869.html"/>
      <url>/posts/c0acd869.html</url>
      
        <content type="html"><![CDATA[<h1 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h1><p>语法</p><p>只记录重点内容，还有和编程语言在常规使用上的不同之处</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p><p>Lua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p><p>局部变量的作用域为从声明位置开始到所在语句块结束。</p><p>变量的默认值均为 nil。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test.lua 文件脚本</span></span><br><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joke</span><span class="params">()</span></span></span><br><span class="line">    c = <span class="number">5</span>           <span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line"><span class="built_in">print</span>(c,d)          <span class="comment">--&gt; 5 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line">    b = <span class="number">6</span>           <span class="comment">-- 对局部变量重新赋值</span></span><br><span class="line">    <span class="built_in">print</span>(a,b);     <span class="comment">--&gt; 6 6</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)      <span class="comment">--&gt; 5 6</span></span><br></pre></td></tr></table></figure><p><strong>应该尽可能的使用局部变量，有两个好处：</strong></p><ul><li><ol><li>避免命名冲突。</li></ol></li><li><ol start="2"><li>访问局部变量的速度比全局变量更快。</li></ol></li></ul><h2 id="空、NULL，null"><a href="#空、NULL，null" class="headerlink" title="空、NULL，null"></a>空、NULL，null</h2><p>在默认情况下，变量总是认为是全局的。</p><p>全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：<strong>nil</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(b)</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt; b=<span class="number">10</span></span><br><span class="line">&gt; <span class="built_in">print</span>(b)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>如果想删除一个全局变量，只需要将变量赋值为nil。</p><h3 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h3><p><strong>nil 作比较时应该加上双引号 “：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">type</span>(X)</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="literal">nil</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="string">&quot;nil&quot;</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><strong>type(X)&#x3D;&#x3D;nil</strong> 结果为 <strong>false</strong> 的原因是 type(X) 实质是返回的 <strong>“nil”</strong> 字符串，是一个 string 类型：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>(X))==<span class="built_in">string</span></span><br></pre></td></tr></table></figure><h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是 false，其他的都为 true，数字 0 也是 true:</p><p>与之不同的是，在编程语言，例如，C++和C#中，0是false</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>字符串拼接不使用 加号</strong></p><p>相反，由 两个英文句号替代 </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> .. <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">ab</span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="number">157</span> .. <span class="number">428</span>)</span><br><span class="line"><span class="number">157428</span></span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure><p><strong>加号字符串的运算中有，有着另外的作用</strong></p><p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span> + <span class="number">6</span>)</span><br><span class="line"><span class="number">8.0</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span> + <span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="number">8.0</span></span><br></pre></td></tr></table></figure><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引头"><a href="#索引头" class="headerlink" title="索引头"></a>索引头</h2><p>lua做出了一个违背祖宗的决定</p><p>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。</p><p>不过是默认是，这个是可以自行指定的，</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i= <span class="number">-2</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = i *<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">-2</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(array[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Table是ua中的特殊类型</p><h2 id="方括号调用"><a href="#方括号调用" class="headerlink" title="方括号调用"></a>方括号调用</h2><p>table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。</p><p>对 table 的索引使用方括号 []。Lua 也提供了 . 操作。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t[i]</span><br><span class="line">t.i                 <span class="comment">-- 当索引为字符串类型时的一种简化写法</span></span><br><span class="line">gettable_event(t,i) <span class="comment">-- 采用索引访问本质上是一个类似这样的函数调用</span></span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><table><thead><tr><th><a href="https://www.runoob.com/lua/lua-break-statement.html">break 语句</a></th><th>退出当前循环或语句，并开始脚本执行紧接着的语句。</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/lua/lua-goto.html">goto 语句</a></td><td>将程序的控制点转移到一个标签处。</td></tr></tbody></table><p>遗憾的是lua没有continue操作</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>设置继承的关键在setmetatable和self.__index &#x3D; self中</p><p>Table需要被声明后才能使用</p><p>同时对于方法的调用，需要通过实例加上英文的冒号 : ，来实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Meta class</span></span><br><span class="line">Shape = &#123;area = <span class="number">0</span>&#125;</span><br><span class="line"><span class="comment">-- 基础类方法 new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:new</span> <span class="params">(side)</span></span></span><br><span class="line">    o = &#123;&#125;</span><br><span class="line">    <span class="comment">--对于继承的调用来说，首先使用的就是父类的中的方法和属性，因此o在前，将self设置为元表就是让在基础table找不属性和方法的时再去调用元组中的内容</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 这一行设置了 Shape 表的 __index 元方法。这意味着，当Lua查找一个键（属性或方法）在一个对象中不存在时，它会使用 Shape 表本身作为查找的起点</span></span><br><span class="line">    <span class="comment">--即从本社找不到后指定去元表中查找</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    side = side <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="built_in">self</span>.area = side*side;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 基础类方法 printArea</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:printArea</span> <span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;面积为 &quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myShapeIns = Shape:new(<span class="number">3</span>)</span><br><span class="line">myShapeIns:printArea()</span><br><span class="line"></span><br><span class="line"><span class="comment">--table需要首先被声明后才能使用</span></span><br><span class="line">Square = Shape:new()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square:new</span><span class="params">(side)</span></span></span><br><span class="line">    o = Shape:new(side)</span><br><span class="line">    <span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mySquareIns =  Square:new(<span class="number">4</span>)</span><br><span class="line">mySquareIns:printArea()</span><br></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p><p>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。以下为创建自定义模块 module.lua，文件代码格式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 module.lua</span></span><br><span class="line"><span class="comment">-- 定义一个名为 module 的模块</span></span><br><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个常量</span></span><br><span class="line"><span class="built_in">module</span>.constant = <span class="string">&quot;这是一个常量&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;这是一个公有函数！\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个私有函数！&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">    func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure><h2 id="自定义测试"><a href="#自定义测试" class="headerlink" title="自定义测试"></a>自定义测试</h2><p>名字叫做module的lua文件</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">const = <span class="string">&quot;测试内容&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.GetData</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> const</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module1 =  <span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>) <span class="comment">--可以自定义名称</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(module1.GetData())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua——Unity配合Rider使用xlua驱动lua</title>
      <link href="/posts/134f9acd.html"/>
      <url>/posts/134f9acd.html</url>
      
        <content type="html"><![CDATA[<h1 id="xlua"><a href="#xlua" class="headerlink" title="xlua"></a>xlua</h1><p>xLua为Unity、 .Net、 Mono等C#环境增加Lua脚本编程的能力，借助xLua，这些Lua代码可以方便的和C#相互调用。</p><p>xLua的突破</p><p>xLua在功能、性能、易用性都有不少突破，这几方面分别最具代表性的是：</p><ul><li>可以运行时把C#实现（方法，操作符，属性，事件等等）替换成lua实现；</li><li>出色的GC优化，自定义struct，枚举在Lua和C#间传递无C# gc alloc；</li><li>编辑器下无需生成代码，开发更轻量；</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>去github网站上直接下载项目，不是发布版本</p><p><a href="https://github.com/Tencent/xLua">https://github.com/Tencent/xLua</a></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241203203501.png" alt="image-20241203203457634"></p><h2 id="将xlua加入到项目中"><a href="#将xlua加入到项目中" class="headerlink" title="将xlua加入到项目中"></a>将xlua加入到项目中</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241203203701.png" alt="image-20241203203656077" style="zoom:67%;" /><p>压缩包中的Asses文件夹下的内容直接鼠标拖动加入到Unity工程中，在此之前要保证Assets文件夹下不存在同名文件夹，不然运行的时候会直接报错</p><h2 id="Rider配置"><a href="#Rider配置" class="headerlink" title="Rider配置"></a>Rider配置</h2><p>2024通过官网下载到的最新版的rider，具体的安装注册请移步去百度，直接跳过到安装插件，EmmyLua，如下图所示。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241203210534.png" alt="image-20241203204059539"></p><p>最新的版本会自动配置对.lua和.lua.txt的识别</p><p><strong>提示</strong></p><p>插件中对.lua.txt的使用是因为Unity不能识别.lua</p><p><strong>不过一开始对.lua.txt中的高亮文字识别会失败，需要先删除再重新配置</strong></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241203210525.png" alt="image-20241203204430798"></p><h1 id="Unity运行"><a href="#Unity运行" class="headerlink" title="Unity运行"></a>Unity运行</h1><h2 id="require运行"><a href="#require运行" class="headerlink" title="require运行"></a>require运行</h2><h3 id="路径配置"><a href="#路径配置" class="headerlink" title="路径配置"></a>路径配置</h3><p>运行的时候xlua会自动扫描配置的文件夹，在Unity中，最直接的是建议脚本放在Resources文件夹下作为一开始的测试手段</p><h3 id="C-调用"><a href="#C-调用" class="headerlink" title="C#调用"></a>C#调用</h3><p>创建LuaManager的C#文件，并附加在在场景中的一个游戏对象，会在Sart函数中自动调用lua中配置的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Purchasing;</span><br><span class="line"><span class="keyword">using</span> XLua;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> LuaEnv luaEnv; <span class="comment">//配置对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模块调用</span></span><br><span class="line">        <span class="comment">//require是指定方法</span></span><br><span class="line">        <span class="comment">//&#x27;MainLua&#x27;，模块名，一般是脚本名，在路径正确配置的前提下才能正常运行</span></span><br><span class="line">        luaEnv.DoString(<span class="string">&quot;require &#x27;MainLua&#x27;&quot;</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清除Lua的未手动释放的LuaBase对象（比如：LuaTable， LuaFunction），以及其它一些事情。 </span></span><br><span class="line">       <span class="comment">// 需要定期调用，比如在MonoBehaviour的Update中调用。</span></span><br><span class="line">        <span class="keyword">this</span>.luaEnv.Tick();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//xlua创建的独享需要手动进行释放</span></span><br><span class="line">        <span class="keyword">this</span>.luaEnv.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lua文件准备"><a href="#lua文件准备" class="headerlink" title="lua文件准备"></a>lua文件准备</h3><p><strong>提示</strong></p><p>插件中对.lua.txt的使用是因为在Unity的Resources文件夹下可以识别的文件数量有限，不指定Loader的话就需要用 .txt 进行结尾</p><p>MainLua：调用LuaTEST</p><p>LuaTEST：具体实现</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241203205745.png" alt="image-20241203205739362" style="zoom:67%;" /><p>MainLua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;LuaTest&quot;</span>)</span><br></pre></td></tr></table></figure><p>LuaTEST</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;LuaTEST&quot;</span>)</span><br></pre></td></tr></table></figure><p>最终的效果是在Unity的控制台输出 LuaTEST的字样</p><h2 id="自定义Loader"><a href="#自定义Loader" class="headerlink" title="自定义Loader"></a>自定义Loader</h2><p>在指定的C#文件中按照如下方式进行定义</p><p>需要在执行 require 方法之先指定Loader</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">        </span><br><span class="line">        luaEnv.AddLoader((<span class="keyword">ref</span> <span class="built_in">string</span> filename) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] bytes = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> middlePathStr = <span class="string">&quot;/Scripts/Lua/&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对开头进行一个筛查</span></span><br><span class="line">            <span class="keyword">if</span> (!filename.StartsWith(<span class="string">&quot;Main&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                middlePathStr += <span class="string">&quot;Src/&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//程序位置定位</span></span><br><span class="line">            <span class="built_in">string</span> filePath = Application.dataPath + middlePathStr + filename + <span class="string">&quot;.lua&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//加载内容</span></span><br><span class="line">            <span class="built_in">string</span> strLuaContent = File.ReadAllText(filePath);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//转为Utf-8的类型</span></span><br><span class="line">            bytes = System.Text.Encoding.UTF8.GetBytes(strLuaContent);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        luaEnv.DoString(<span class="string">&quot;require &#x27;MainLua&#x27;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>涉及到的类型为</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">byte</span>[] <span class="title">CustomLoader</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> filepath</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> LuaEnv.AddLoader(CustomLoader loader)</span><br></pre></td></tr></table></figure><p><strong>程序位置定位</strong></p><p>打包后也能通过该复合获取到游戏的路径，不过在驱动lua运行的没有正确加载，具体原因子啊2024.12.10暂且不清楚</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Application.dataPath</span><br><span class="line"><span class="comment">//经过测试，该路径指向Unity的开发路径 Assets文件夹</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— 2D，使用Springs制作交互式的水效果</title>
      <link href="/posts/6c0cf8e.html"/>
      <url>/posts/6c0cf8e.html</url>
      
        <content type="html"><![CDATA[<h1 id="交互水"><a href="#交互水" class="headerlink" title="交互水"></a>交互水</h1><p>使用模拟Springs 和 Sprite Shape 的 Unity 交互式 2D 水。 本教程以类似的方式制作，您可以通过不同的示例逐步了解如何创建 2D 水。</p><p>最终效果为玩家跳入水中有水面波纹，游泳的时候水面前高后低</p><p>实现思路来源</p><p>【【Unity教程搬运】Unity中带有Sprite Shape的2D水教程】<a href="https://www.bilibili.com/video/BV1MM4y1r7JU?vd_source=0c56e77847d28781d8cdd412054492d9">https://www.bilibili.com/video/BV1MM4y1r7JU?vd_source=0c56e77847d28781d8cdd412054492d9</a></p><p>这里添加在有玩家游泳的情况下的水体扰动。</p><h1 id="2D物理组件"><a href="#2D物理组件" class="headerlink" title="2D物理组件"></a>2D物理组件</h1><h2 id="Buoyancy-Effector-2D浮力效应"><a href="#Buoyancy-Effector-2D浮力效应" class="headerlink" title="Buoyancy Effector 2D浮力效应"></a>Buoyancy Effector 2D浮力效应</h2><p>Buoyancy Effector 2D 浮力效应：在特定区域内没有力度效果。<br>Use Collider Mask 使用碰撞遮罩，默认勾选，碰撞遮罩可以用于忽略某些层的碰撞效果，比如一块玻璃，如果是光Layer就可以穿过去，如果是物体Layer就会反弹。<br>Collider Mask 碰撞遮罩，用于设置哪些层产生碰撞效果。<br>Density 密度,从而影响对撞机的行为:那些有更高的密度,密度较低的浮动,和那些相同的流体密度表现<br>Surface Level 定义了浮力液体的表面。当一个对象超过这条线,不应用力。当一个物体相交或完全低于这条线,力被重新应用。<br>Linear Drag 线性阻力，如果物体在水上弹来弹去的，就是阻力给小了，这时候加点阻力就好了。<br>Angular Drag 角度阻力<br>Flow Angle 流动力在世界坐标的角度的方向，这个方向就是水流的方向。<br>Flow Magnitude 流动力大小。结合流体角,这个指定的水平力大小，相当于水的流速。<br>Flow Variation 随机流动力大小</p><p>给一个区域添加水的浮力效果</p><h2 id="Render-Shape-Controller"><a href="#Render-Shape-Controller" class="headerlink" title="Render Shape Controller"></a>Render Shape Controller</h2><p>给2D图片塑性的关键性性组件</p><p>在场景管理器后者assets文件中选择新建一个SpriteShapeProfile，有两个选项框进行操作，Open和Close，二者具体的区别如下图所示</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241121152227.png" alt="image-20241121152219691" style="zoom:67%;" /><h3 id="获取点"><a href="#获取点" class="headerlink" title="获取点"></a>获取点</h3><p>spritshapeController是改变形状的组件，类型是SpriteShapeController，Spline类型中保存着顶点，可以使用数组形式的索引进行设置操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spline waterSpline = spriteShapeController.spline; <span class="comment">//spritshapeController是改变形状的组件</span></span><br><span class="line"><span class="built_in">int</span> waterPointsCount = waterSpline.GetPointCount();<span class="comment">//获取到点的数量</span></span><br></pre></td></tr></table></figure><p>在close的类型下</p><p>点的获取遵循数组的常规定义，从0开始作为第一个</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//对于一个矩形来讲，0123，四个点分别是左下，左上，右上和右下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一直在2为止插入顶点就是将矩形的12点的中间插入顶点</span></span><br><span class="line"></span><br><span class="line"> Vector3 waterTopLeftCorner = waterSpline.GetPosition(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> Vector3 waterTopRightCorner = waterSpline.GetPosition(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>使用spline的GetPosition（）方法获取到的vector3的位置是基于SpriteShapeController所在的游戏对象的局部坐标系，也就是模型坐标系</p><p>并且在本例子将局部坐标抓换为世界坐标和在水中进行游泳的物体进行计算的时候会出现<strong>索引越界</strong>的情况，因此使用的是将世界坐标转为局部坐标的方式</p><h4 id="世界坐标和局部坐标的相互转换"><a href="#世界坐标和局部坐标的相互转换" class="headerlink" title="世界坐标和局部坐标的相互转换"></a>世界坐标和局部坐标的相互转换</h4><p>二者的参数和返回类型一样，需要注意的是需要通过相关的局部坐标系的<strong>Transform</strong>来调用TransformPoint方法</p><p>即A为世界坐标系，B为的目标或这源头局部坐标系。</p><p><strong>世界到局部</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3 objectPos = transform.InverseTransformPoint(waterSwimInDetect.transform.position);</span><br></pre></td></tr></table></figure><p><strong>局部到世界</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.TransformPoint(waterSwimDetect.transform.position);</span><br></pre></td></tr></table></figure><h1 id="波纹点生成"><a href="#波纹点生成" class="headerlink" title="波纹点生成"></a>波纹点生成</h1><h2 id="Unity事件"><a href="#Unity事件" class="headerlink" title="Unity事件"></a><strong>Unity事件</strong></h2><p>Editor运行时才会被自动调用的函数</p><p>Unity实现的事件函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnValidate</span>()</span> &#123;</span><br><span class="line">  <span class="comment">// Clean waterpoints </span></span><br><span class="line"></span><br><span class="line">  StartCoroutine(CreateWaves());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在序列化的数值被更改后，会自动调用该函数，</p><p>为避免歧义，当脚本中以下属性值在Unity中被可视化改变后会调用以上函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> swimWaveCreateDistance = <span class="number">0.2f</span>;</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> swimWaveEndDistance = <span class="number">0.1f</span>;</span><br></pre></td></tr></table></figure><h2 id="删除、生成点"><a href="#删除、生成点" class="headerlink" title="删除、生成点"></a>删除、生成点</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">IEnumerator <span class="title">CreateWaves</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Transform child <span class="keyword">in</span> wavePoints.transform) &#123;</span><br><span class="line">            StartCoroutine(Destroy(child.gameObject));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        SetWaves();</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁原本的所有点</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Destroy</span>(<span class="params">GameObject go</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        DestroyImmediate(go);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新生成点并配置游戏对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetWaves</span>()</span> &#123; </span><br><span class="line">        Spline waterSpline = spriteShapeController.spline;</span><br><span class="line">        <span class="built_in">int</span> waterPointsCount = waterSpline.GetPointCount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据close类型中点的分布，1、2组成的线在该矩形图片的初始上方</span></span><br><span class="line">        <span class="comment">//每次删除index为2的点，后面的会自动向前补齐</span></span><br><span class="line">        <span class="comment">//CorsnerCount的值默认 = 2</span></span><br><span class="line">        <span class="comment">//该循环会保证1、2线上有两个点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = CorsnersCount; i &lt; waterPointsCount - CorsnersCount; i++) &#123;</span><br><span class="line">            waterSpline.RemovePointAt(CorsnersCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于一个矩形来讲，0123，四个点分别是左下，左上，右上和右下</span></span><br><span class="line">        <span class="comment">//一直在2为止插入顶点就是将矩形的12点的中间插入顶点</span></span><br><span class="line">        <span class="comment">//GetPosition的点是基于该 SpriteShapeController（这里的实例是WaterSpline）组件所在的游戏对象的局部坐标</span></span><br><span class="line">        Vector3 waterTopLeftCorner = waterSpline.GetPosition(<span class="number">1</span>);</span><br><span class="line">        Vector3 waterTopRightCorner = waterSpline.GetPosition(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">float</span> waterWidth = waterTopRightCorner.x - waterTopLeftCorner.x;</span><br><span class="line"></span><br><span class="line">        pointOriginPositionY = waterTopLeftCorner.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算每个点之间的宽度</span></span><br><span class="line">        <span class="built_in">float</span> spacingPerWave = waterWidth / (WavesCount+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在1、2线上插入新的顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = WavesCount; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">int</span> index = CorsnersCount;</span><br><span class="line">            <span class="built_in">float</span> xPosition = waterTopLeftCorner.x + (spacingPerWave*i);</span><br><span class="line">            Vector3 wavePoint = <span class="keyword">new</span> Vector3(xPosition, waterTopLeftCorner.y, waterTopLeftCorner.z);</span><br><span class="line">            waterSpline.InsertPointAt(index, wavePoint);</span><br><span class="line">            </span><br><span class="line">            waterSpline.SetHeight(index, <span class="number">0.1f</span>);<span class="comment">//设置index位置的水波高度为0.1。这意味着在样条曲线上，这个点的y坐标会增加0.1。实际上要改变点的位置，尤其是在视觉上向上浮动，需要在上一步的InserPointAt（）或者SetPosition（）函数中通过索引和新的vector3进行改变，这个的SetHieight（）效果不佳</span></span><br><span class="line">            waterSpline.SetCorner(index, <span class="literal">false</span>);<span class="comment">//将index位置的点设置为非角点。在样条曲线中，角点会创建一个尖锐的拐角，而非角点则创建平滑的过渡。</span></span><br><span class="line">            waterSpline.SetTangentMode(index, ShapeTangentMode.Continuous);<span class="comment">//设置index位置的切线模式为连续。ShapeTangentMode.Continuous表示样条曲线在该点处的切线是平滑连续的，没有突变，这有助于创建平滑的水波效果。</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化给定游戏对象到新加点的位置上，目的是为了对齐局部坐标，能直接使用游戏对象的局部坐标位置改变Spline中的点位置</span></span><br><span class="line">        springs = <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= WavesCount+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> index = i + <span class="number">1</span>; </span><br><span class="line">            </span><br><span class="line">            Smoothen(waterSpline, index);<span class="comment">//平滑</span></span><br><span class="line"></span><br><span class="line">            GameObject wavePoint = Instantiate(wavePointPref, wavePoints.transform, <span class="literal">false</span>);</span><br><span class="line">            wavePoint.transform.localPosition = waterSpline.GetPosition(index);</span><br><span class="line"></span><br><span class="line">            WaterSpring waterSpring = wavePoint.GetComponent&lt;WaterSpring&gt;();</span><br><span class="line">            waterSpring.Init(spriteShapeController);</span><br><span class="line">            springs.Add(waterSpring);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//本地调用</span></span><br><span class="line">        spline = waterSpline;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Smoothen</span>(<span class="params">Spline waterSpline, <span class="built_in">int</span> index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3 position = waterSpline.GetPosition(index);</span><br><span class="line">    Vector3 positionPrev = position;</span><br><span class="line">    Vector3 positionNext = position;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        positionPrev = waterSpline.GetPosition(index<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index - <span class="number">1</span> &lt;= WavesCount) &#123;</span><br><span class="line">        positionNext = waterSpline.GetPosition(index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector3 forward = gameObject.transform.forward;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> scale = Mathf.Min((positionNext - position).magnitude, (positionPrev - position).magnitude) * <span class="number">0.33f</span>;</span><br><span class="line"></span><br><span class="line">    Vector3 leftTangent = (positionPrev - position).normalized * scale;</span><br><span class="line">    Vector3 rightTangent = (positionNext - position).normalized * scale;</span><br><span class="line"></span><br><span class="line">    SplineUtility.CalculateTangents(position, positionPrev, positionNext, forward, scale, <span class="keyword">out</span> rightTangent, <span class="keyword">out</span> leftTangent);</span><br><span class="line">    </span><br><span class="line">    waterSpline.SetLeftTangent(index, leftTangent);</span><br><span class="line">    waterSpline.SetRightTangent(index, rightTangent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3 position = waterSpline.GetPosition(index);</span><br></pre></td></tr></table></figure><ul><li>获取样条曲线上索引为<code>index</code>的点的位置。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    positionPrev = waterSpline.GetPosition(index<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index - <span class="number">1</span> &lt;= WavesCount) &#123;</span><br><span class="line">    positionNext = waterSpline.GetPosition(index+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前点的前一个和后一个点的位置，如果它们存在的话。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> scale = Mathf.Min((positionNext - position).magnitude, (positionPrev - position).magnitude) * <span class="number">0.33f</span>;</span><br></pre></td></tr></table></figure><ul><li>计算当前点到前后点的最小距离，并乘以0.33来得到切线长度的缩放因子。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 leftTangent = (positionPrev - position).normalized * scale;</span><br><span class="line">Vector3 rightTangent = (positionNext - position).normalized * scale;</span><br></pre></td></tr></table></figure><ul><li>计算当前点的左右切线向量，基于前后点的位置和缩放因子。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SplineUtility.CalculateTangents(position, positionPrev, positionNext, forward, scale, <span class="keyword">out</span> rightTangent, <span class="keyword">out</span> leftTangent);</span><br></pre></td></tr></table></figure><ul><li>使用<code>SplineUtility</code>类的方法来优化左右切线的计算。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">waterSpline.SetLeftTangent(index, leftTangent);</span><br><span class="line">waterSpline.SetRightTangent(index, rightTangent);</span><br></pre></td></tr></table></figure><ul><li>将计算出的左右切线应用到样条曲线的当前点，以平滑曲线。</li></ul><h1 id="波纹模拟"><a href="#波纹模拟" class="headerlink" title="波纹模拟"></a>波纹模拟</h1><p><strong>注意，该部分有两个不同实现点</strong></p><p>跳水部分顶点的位置改变是通过和顶点位置同步的WaterSpring游戏对象进行控制</p><p>游泳则是直接改变Shape的顶点</p><p>总结就是前者有同步的游戏对象位置和单独的弹簧模拟，后者没有</p><p>WaterSpringController的执行代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       JumpInWatetWaveChange();</span><br><span class="line">       SwimWaveChange();</span><br><span class="line">       <span class="comment">//波传递</span></span><br><span class="line">       UpdateSprings();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">JumpInWatetWaveChange</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 物体跳入水中进行的扰动</span></span><br><span class="line">       <span class="keyword">foreach</span>(WaterSpring waterSpringComponent <span class="keyword">in</span> springs) &#123;</span><br><span class="line">           waterSpringComponent.WaveSpringUpdate(springStiffness, dampening);</span><br><span class="line">           waterSpringComponent.WavePointUpdate();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SwimWaveChange</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 游泳前后扰动</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= WavesCount + <span class="number">2</span>; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">int</span> index = i;</span><br><span class="line">           <span class="keyword">if</span> (waterSwimInDetect.isObjectInWater)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (MathF.Abs(waterSwimInDetect.rb.velocity.x) &lt; <span class="number">0.04f</span> || MathF.Abs(waterSwimInDetect.rb.velocity.y)&gt;<span class="number">0.09f</span>) <span class="keyword">return</span>;</span><br><span class="line">               <span class="comment">// 获取物体当前位置和水面点的相对水平距离</span></span><br><span class="line">               Vector3 objectPos = transform.InverseTransformPoint(waterSwimInDetect.transform.position);</span><br><span class="line">               <span class="comment">//获取shape坐标并转换到世界坐标</span></span><br><span class="line">               Vector3 pointPos = spline.GetPosition(index);</span><br><span class="line">               <span class="comment">// 计算物体与水面点之间的水平距离</span></span><br><span class="line">               <span class="built_in">float</span> distance = pointPos.x - objectPos.x;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//配合跳入水中固有的y值扰动，让在物体游泳的时候别的在波动的地方还可以正常波动</span></span><br><span class="line">               pointOriginPositionY = pointPos.y;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 判断物体水平速度和物体与水面点的距离</span></span><br><span class="line">               <span class="built_in">bool</span> isTooFar = Mathf.Abs(distance) &gt; swimWaveCreateDistance;</span><br><span class="line">               <span class="built_in">bool</span> isTooClose = Mathf.Abs(distance) &lt; swimWaveEndDistance;</span><br><span class="line">               <span class="built_in">bool</span> isSlow = Mathf.Abs(waterSwimInDetect.rb.velocity.x) &lt; <span class="number">0.004f</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果物体离水面点太远或水平速度小于阈值，则恢复到原始高度</span></span><br><span class="line">               <span class="keyword">if</span> (isTooFar || isSlow || isTooClose)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 恢复水面点的原始高度</span></span><br><span class="line">                   pointPos.y = pointOriginPositionY;</span><br><span class="line">                   spline.SetPosition(index, pointPos);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 这里使用物体和水面点之间的距离进行扰动计算</span></span><br><span class="line">                   <span class="built_in">float</span> disturbance = ((MathF.Cos(distance)+<span class="number">1</span>)/<span class="number">2</span> * heightFactor * waterSwimInDetect.rb.velocity.x) * MathF.Sign(distance);</span><br><span class="line">                   pointPos.y = pointOriginPositionY + disturbance;</span><br><span class="line">                   spline.SetPosition(index, pointPos);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 模拟波的传递</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment">//mao 24-11-20 09:46</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateSprings</span>()</span> &#123; </span><br><span class="line">       <span class="built_in">int</span> count = springs.Count;</span><br><span class="line">       <span class="built_in">float</span>[] left_deltas = <span class="keyword">new</span> <span class="built_in">float</span>[count];</span><br><span class="line">       <span class="built_in">float</span>[] right_deltas = <span class="keyword">new</span> <span class="built_in">float</span>[count];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               left_deltas[i] = spread * (springs[i].height - springs[i<span class="number">-1</span>].height);</span><br><span class="line">               springs[i<span class="number">-1</span>].velocity += left_deltas[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (i &lt; springs.Count - <span class="number">1</span>) &#123;</span><br><span class="line">               right_deltas[i] = spread * (springs[i].height - springs[i+<span class="number">1</span>].height);</span><br><span class="line">               springs[i+<span class="number">1</span>].velocity += right_deltas[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>SpringWater中的代码</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.U2D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WaterSpring</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> velocity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> force = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// current height</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> height = <span class="number">0f</span>;</span><br><span class="line">    <span class="comment">// normal height</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> target_height = <span class="number">0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform springTransform;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> SpriteShapeController spriteShapeController = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> waveIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WaterSpring&gt; springs = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> resistance = <span class="number">40f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params">SpriteShapeController ssc</span>)</span> &#123; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> index = transform.GetSiblingIndex();</span><br><span class="line">        waveIndex = index+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        spriteShapeController = ssc;</span><br><span class="line">        velocity = <span class="number">0</span>;</span><br><span class="line">        height = transform.localPosition.y;</span><br><span class="line">        target_height = transform.localPosition.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// with dampening</span></span><br><span class="line">    <span class="comment">// adding the dampening to the force</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WaveSpringUpdate</span>(<span class="params"><span class="built_in">float</span> springStiffness, <span class="built_in">float</span> dampening</span>)</span> &#123; </span><br><span class="line">        height = transform.localPosition.y;</span><br><span class="line">        <span class="comment">// maximum extension</span></span><br><span class="line">        <span class="keyword">var</span> x = height - target_height;</span><br><span class="line">        <span class="keyword">var</span> loss = -dampening * velocity;</span><br><span class="line"></span><br><span class="line">        force = - springStiffness * x + loss;</span><br><span class="line">        velocity += force;</span><br><span class="line">        <span class="keyword">var</span> y = transform.localPosition.y;  </span><br><span class="line">        transform.localPosition = <span class="keyword">new</span> Vector3(transform.localPosition.x, y+velocity, transform.localPosition.z);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用该对象的局部坐标同步Render Shape Controller控制的图形形状</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WavePointUpdate</span>()</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (spriteShapeController != <span class="literal">null</span>) &#123;</span><br><span class="line">            Spline waterSpline = spriteShapeController.spline;</span><br><span class="line">            Vector3 wavePosition = waterSpline.GetPosition(waveIndex);</span><br><span class="line">            waterSpline.SetPosition(waveIndex, <span class="keyword">new</span> Vector3(wavePosition.x, transform.localPosition.y, wavePosition.z));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//collier的碰撞检查</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D other</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.gameObject.tag.Equals(<span class="string">&quot;FallingObject&quot;</span>)) &#123;</span><br><span class="line">            FallingObject fallingObject = other.gameObject.GetComponent&lt;FallingObject&gt;();</span><br><span class="line">            Rigidbody2D rb = fallingObject.rigidbody2D;</span><br><span class="line">            <span class="keyword">var</span> speed = rb.velocity;</span><br><span class="line"></span><br><span class="line">            velocity += speed.y/resistance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳水"><a href="#跳水" class="headerlink" title="跳水"></a>跳水</h2><p>  <strong>更新控制</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">JumpInWatetWaveChange</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 物体跳入水中进行的扰动</span></span><br><span class="line">    <span class="keyword">foreach</span>(WaterSpring waterSpringComponent <span class="keyword">in</span> springs) &#123;</span><br><span class="line">        waterSpringComponent.WaveSpringUpdate(springStiffness, dampening);</span><br><span class="line">        waterSpringComponent.WavePointUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="弹簧模拟"><a href="#弹簧模拟" class="headerlink" title="弹簧模拟"></a>弹簧模拟</h3><p><strong>WaveSpringUpdate</strong></p><p>该方法模拟了一个简单的弹簧系统，用于更新某个对象（可能是水面或波浪）的高度。以下是代码的逐行解释：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WaveSpringUpdate</span>(<span class="params"><span class="built_in">float</span> springStiffness, <span class="built_in">float</span> dampening</span>)</span> &#123; </span><br></pre></td></tr></table></figure><ul><li>定义了一个公共方法<code>WaveSpringUpdate</code>，它接受两个参数：<code>springStiffness</code>（弹簧刚度）和<code>dampening</code>（阻尼）。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height = transform.localPosition.y;</span><br></pre></td></tr></table></figure><ul><li>获取当前对象在Y轴上的位置，并将其存储在变量<code>height</code>中。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = height - target_height;</span><br></pre></td></tr></table></figure><ul><li>计算当前高度与目标高度<code>target_height</code>之间的差值，并存储在变量<code>x</code>中。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loss = -dampening * velocity;</span><br></pre></td></tr></table></figure><ul><li>计算阻尼力，即阻尼乘以当前速度的负值，并存储在变量<code>loss</code>中。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">force = - springStiffness * x + loss;</span><br></pre></td></tr></table></figure><ul><li>计算总的力，即弹簧力（由弹簧刚度乘以高度差）加上阻尼力。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">velocity += force;</span><br></pre></td></tr></table></figure><ul><li>将计算出的总力添加到当前速度上，更新速度。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = transform.localPosition.y;  </span><br></pre></td></tr></table></figure><ul><li>再次获取当前对象在Y轴上的位置，并存储在变量<code>y</code>中。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.localPosition = <span class="keyword">new</span> Vector3(transform.localPosition.x, y+velocity, transform.localPosition.z);</span><br></pre></td></tr></table></figure><ul><li>更新对象的位置，将速度加到Y轴的位置上，从而在Y轴方向上移动对象。</li></ul><p>总的来说，这个方法模拟了一个简单的弹簧-阻尼系统，其中：</p><ul><li><code>springStiffness</code>决定了弹簧恢复到原始位置的力的大小。</li><li><code>dampening</code>决定了系统减速到停止的速度。</li><li><code>height</code>是当前对象在Y轴上的位置。</li><li><code>target_height</code>是对象想要达到的目标高度。</li><li><code>velocity</code>是对象在Y轴上的速度。</li><li><code>force</code>是作用在对象上的总力。</li></ul><p><strong>这个方法在每一帧被调用时，都会根据弹簧力和阻尼力更新对象的位置，模拟波浪或弹簧的运动。</strong></p><p>以上内容总结于智普清言</p><h3 id="波动扩散"><a href="#波动扩散" class="headerlink" title="波动扩散"></a>波动扩散</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 模拟波的传递</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"> <span class="comment">//mao 24-11-20 09:46</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateSprings</span>()</span> &#123; </span><br><span class="line">    <span class="built_in">int</span> count = springs.Count;</span><br><span class="line">    <span class="built_in">float</span>[] left_deltas = <span class="keyword">new</span> <span class="built_in">float</span>[count];</span><br><span class="line">    <span class="built_in">float</span>[] right_deltas = <span class="keyword">new</span> <span class="built_in">float</span>[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            left_deltas[i] = spread * (springs[i].height - springs[i<span class="number">-1</span>].height);</span><br><span class="line">            springs[i<span class="number">-1</span>].velocity += left_deltas[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; springs.Count - <span class="number">1</span>) &#123;</span><br><span class="line">            right_deltas[i] = spread * (springs[i].height - springs[i+<span class="number">1</span>].height);</span><br><span class="line">            springs[i+<span class="number">1</span>].velocity += right_deltas[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在WaterSpringController中根据传播因子<strong>spread</strong>，对没有直接被改变速度的WaterSpring取周边被直接影响速度，下一帧就会在<strong>FixedUpdate</strong>函数中自行模拟弹簧运动</p><h2 id="游泳"><a href="#游泳" class="headerlink" title="游泳"></a>游泳</h2><p>具体见注释</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SwimWaveChange</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 游泳前后扰动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= WavesCount + <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> index = i;</span><br><span class="line">            <span class="keyword">if</span> (waterSwimInDetect.isObjectInWater)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (MathF.Abs(waterSwimInDetect.rb.velocity.x) &lt; <span class="number">0.04f</span> || MathF.Abs(waterSwimInDetect.rb.velocity.y)&gt;<span class="number">0.09f</span>) <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 获取物体当前位置和水面点的相对水平距离</span></span><br><span class="line">                Vector3 objectPos = transform.InverseTransformPoint(waterSwimInDetect.transform.position);</span><br><span class="line">                <span class="comment">//获取shape坐标并转换到世界坐标</span></span><br><span class="line">                Vector3 pointPos = spline.GetPosition(index);</span><br><span class="line">                <span class="comment">// 计算物体与水面点之间的水平距离</span></span><br><span class="line">                <span class="built_in">float</span> distance = pointPos.x - objectPos.x;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//配合跳入水中固有的y值扰动，让在物体游泳的时候别的在波动的地方还可以正常波动</span></span><br><span class="line">                pointOriginPositionY = pointPos.y;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断物体水平速度和物体与水面点的距离</span></span><br><span class="line">                <span class="built_in">bool</span> isTooFar = Mathf.Abs(distance) &gt; swimWaveCreateDistance;</span><br><span class="line">                <span class="built_in">bool</span> isTooClose = Mathf.Abs(distance) &lt; swimWaveEndDistance;</span><br><span class="line">                <span class="built_in">bool</span> isSlow = Mathf.Abs(waterSwimInDetect.rb.velocity.x) &lt; <span class="number">0.004f</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果物体离水面点太远或水平速度小于阈值，则恢复到原始高度</span></span><br><span class="line">                <span class="keyword">if</span> (isTooFar || isSlow || isTooClose)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 恢复水面点的原始高度</span></span><br><span class="line">                    pointPos.y = pointOriginPositionY;</span><br><span class="line">                    spline.SetPosition(index, pointPos);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 这里使用物体和水面点之间的距离进行扰动计算</span></span><br><span class="line">                    <span class="built_in">float</span> disturbance = ((MathF.Cos(distance)+<span class="number">1</span>)/<span class="number">2</span> * heightFactor * waterSwimInDetect.rb.velocity.x) * MathF.Sign(distance);</span><br><span class="line">                    pointPos.y = pointOriginPositionY + disturbance;</span><br><span class="line">                    spline.SetPosition(index, pointPos);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>跳水的模拟需要在游泳前面，具体原因参照在波纹模拟最开始的提示</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    JumpInWatetWaveChange();</span><br><span class="line">    SwimWaveChange();</span><br><span class="line">    <span class="comment">//波传递</span></span><br><span class="line">    UpdateSprings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳水在后面的话，因为游泳没有改变WaterSpring游戏对象的位置，最终游泳的波动会被跳水更新中的以下代码根据游戏对象的位置强制更新</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用该对象的局部坐标同步Render Shape Controller控制的图形形状</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WavePointUpdate</span>()</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (spriteShapeController != <span class="literal">null</span>) &#123;</span><br><span class="line">        Spline waterSpline = spriteShapeController.spline;</span><br><span class="line">        Vector3 wavePosition = waterSpline.GetPosition(waveIndex);</span><br><span class="line">        waterSpline.SetPosition(waveIndex, <span class="keyword">new</span> Vector3(wavePosition.x, transform.localPosition.y, wavePosition.z));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>物体游泳通过的区域需要抚平，想要在游泳的时候保留跳水波动的效果，就使用以下注释为 <strong>非常重要</strong>的部分代码，将跳水影响的高度重新赋值给指定顶点</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vector3 pointPos = spline.GetPosition(index);</span><br><span class="line"><span class="comment">// 计算物体与水面点之间的水平距离</span></span><br><span class="line"><span class="built_in">float</span> distance = pointPos.x - objectPos.x;</span><br><span class="line">                </span><br><span class="line"><span class="comment">//非常重要</span></span><br><span class="line"><span class="comment">//配合跳入水中固有的y值扰动，让在物体游泳的时候别的在波动的地方还可以正常波动</span></span><br><span class="line"> pointOriginPositionY = pointPos.y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断物体水平速度和物体与水面点的距离</span></span><br><span class="line"><span class="built_in">bool</span> isTooFar = Mathf.Abs(distance) &gt; swimWaveCreateDistance;</span><br><span class="line"><span class="built_in">bool</span> isTooClose = Mathf.Abs(distance) &lt; swimWaveEndDistance;</span><br><span class="line"><span class="built_in">bool</span> isSlow = Mathf.Abs(waterSwimInDetect.rb.velocity.x) &lt; <span class="number">0.004f</span>;</span><br></pre></td></tr></table></figure><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241121181651.gif" alt="1dca19e3814f38f63c31 -original-horizontal"></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>这个版本还有部分缺陷，游泳产生的扰动不和跳水的弹簧波动有交互，即，你游你的，我震我的。日后修正。</p><p><strong>注意</strong></p><p>在以上示例中使用到的OnValidate（）Unity事件函数在打包后调用会出现错误，因此要如果要将效果加入到打包工程中，应将该函数中的对应代码加入到Awake、Start或者OEnable中去</p>]]></content>
      
      
      <categories>
          
          <category> Unity2D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader——水效果实现</title>
      <link href="/posts/8f055b02.html"/>
      <url>/posts/8f055b02.html</url>
      
        <content type="html"><![CDATA[<h1 id="水效果"><a href="#水效果" class="headerlink" title="水效果"></a>水效果</h1><h1 id="水面颜色渐变效果"><a href="#水面颜色渐变效果" class="headerlink" title="水面颜色渐变效果"></a>水面颜色渐变效果</h1><h2 id="深度图"><a href="#深度图" class="headerlink" title="深度图"></a>深度图</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用深度图来决定水体表面和底部的距，从而改变该部分水体的颜色，达到一个从岸边到深水区的颜色渐变效果</p><p>深度图在Shader使用</p><p>使用SurfaceShader</p><h3 id="深度图获取"><a href="#深度图获取" class="headerlink" title="深度图获取"></a>深度图获取</h3><p><strong>固定名称</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _CameraDepthTexture;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampler2D_float ，增加精度，预防某些手机精度不够</span></span><br></pre></td></tr></table></figure><p>同时还需要开启摄像机的深度</p><h3 id="深度图采样"><a href="#深度图采样" class="headerlink" title="深度图采样"></a>深度图采样</h3><p>深度图渲染出来后在屏幕空间内，要到屏幕空间进行采样，需要获取到屏幕坐标的UV才能对深度图进行采样</p><h3 id="Input结构体中额外定义"><a href="#Input结构体中额外定义" class="headerlink" title="Input结构体中额外定义"></a><strong>Input结构体中额外定义</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float4 proj;<span class="comment">//屏幕坐标</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed4 _WaterShallowColor;<span class="comment">//浅水区的颜色</span></span><br><span class="line">fixed4 _WaterDeepColor;<span class="comment">//深水区的颜色</span></span><br><span class="line">half _DeepPower;<span class="comment">//水深强度</span></span><br><span class="line">half _TranAmount;<span class="comment">//透明度数</span></span><br></pre></td></tr></table></figure><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a><strong>顶点着色器</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i.proj = ComputeScreenPos(UnityObjectToClipPos(v.vertex));<span class="comment">//根据顶点计算屏幕空间，没有齐次裁剪</span></span><br><span class="line"></span><br><span class="line">COMPUTE_EYEDEPTH(i.proj.z);<span class="comment">//将摄像机的深度传递给固给定的值</span></span><br></pre></td></tr></table></figure><h3 id="surf方法"><a href="#surf方法" class="headerlink" title="surf方法"></a>surf方法</h3><p>提取深度，转换到线性视角空间，求出水平面到水底的深度，使用lerp差值进行过度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的宏的第二个宏是接受一个float4 的变量，返回适合深度图采样的变量，大部分平台都是原路返回</span></span><br><span class="line"><span class="comment">// half depth =  SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture,UNITY_PROJ_COORD(IN.proj));</span></span><br><span class="line">half depth = LinearEyeDepth(tex2Dproj(_CameraDepthTexture,UNITY_PROJ_COORD(IN.proj)).r);<span class="comment">//投影矩阵，将深度转换为一个线性值，转换到屏幕空间的第一个线性值</span></span><br><span class="line"><span class="comment">//摄像机的深度减去当前物体的深度，得到结果是水深</span></span><br><span class="line"><span class="comment">//实际上还</span></span><br><span class="line">half deltaDepth = depth - IN.proj.z;</span><br><span class="line"><span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">fixed4 c = lerp(_WaterShallowColor,_WaterDeepColor,min(_DeepPower,deltaDepth)/_DeepPower);</span><br><span class="line">o.Albedo = c;</span><br><span class="line">o.Alpha = min(_TranAmount,deltaDepth)/_TranAmount;</span><br></pre></td></tr></table></figure><p>IN.proj中的计算在顶点着色器中计算缺少对齐次空间的裁剪，对屏幕空间进行采样的时候需要 &#x2F;w，depth的计算过程中使用的tex2Dproj 就默认使用了这一点</p><p>采样出来的深度图不是线性变化的，需要使用线性化方法处理，LinearEyeDepth就是线性化到视角空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half depth = LinearEyeDepth(tex2Dproj(_CameraDepthTexture,UNITY_PROJ_COORD(IN.proj)).r);</span><br></pre></td></tr></table></figure><p>Unity渲染物体根据渲染循序从小到大进行渲染，这里的水使用的是透明通道，Transparent，放在最后渲染，这个时候的深度图就是纯地面，结果就是depth，IN.proj的通道在顶点着色器中保存的是水平面的深度值，相减就是水深，即从水面水底的距离。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half deltaDepth = depth - IN.proj.z;</span><br></pre></td></tr></table></figure><h1 id="较好的法线移动效果"><a href="#较好的法线移动效果" class="headerlink" title="较好的法线移动效果"></a>较好的法线移动效果</h1><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> _WaterSpeed;<span class="comment">//水法线流动速度</span></span><br><span class="line"><span class="type">float</span> _Refract;<span class="comment">//法线的密集度</span></span><br></pre></td></tr></table></figure><h2 id="surf方法-1"><a href="#surf方法-1" class="headerlink" title="surf方法"></a>surf方法</h2><p>两个采样步骤</p><p>获取偏移，加上偏移采样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float4 bumpOffset1 = tex2D(_Normal,IN.uv_Normal + float2(_WaterSpeed * _Time.x,<span class="number">0</span>));</span><br><span class="line">float4 bumpOffset2 = tex2D(_Normal,IN.uv_Normal + float2(<span class="number">1</span>-IN.uv_Normal.y,IN.uv_Normal.x)+float2(_Time.x * _WaterSpeed,<span class="number">0</span>));</span><br><span class="line">float4 offsetColor = (bumpOffset1+ bumpOffset2)/<span class="number">2</span>;</span><br><span class="line">float2 offset = UnpackNormal(offsetColor).xy * _Refract;</span><br><span class="line">float4 bumpColor1 = tex2D(_Normal,IN.uv_Normal +offset+ float2(_WaterSpeed * _Time.x,<span class="number">0</span>));</span><br><span class="line">float4 bumpColor2 = tex2D(_Normal,offset+float2(<span class="number">1</span>-IN.uv_Normal.y,IN.uv_Normal.x)+float2(_Time.x * _WaterSpeed,<span class="number">0</span>));</span><br><span class="line">o.Normal = UnpackNormal((bumpColor1 + bumpColor2)/<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h1 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h1><p>自定义光照模型，仅加入半兰伯特光照和BlinnPhone</p><p>顺便复习自定义光照函数的输入数据结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fixed4 <span class="title function_">LightingWaterLight</span><span class="params">(SurfaceOutput s,fixed3 lightDir,half3 viewDir,fixed atten)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> diffuse = dot(normalize(lightDir),s.Normal) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    half3 halfView = normalize(lightDir + viewDir);</span><br><span class="line">    <span class="type">float</span> nh = max(<span class="number">0</span>,dot(halfView,s.Normal));</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(nh,s.Specular * <span class="number">128</span>) * s.Gloss;</span><br><span class="line">    fixed4 color;</span><br><span class="line">    color.rgb = (s.Albedo * _LightColor0.rgb * diffuse + _SpecularColor.rgb * spec * _LightColor0.rgb) * atten;</span><br><span class="line">    color.a = s.Alpha + spec * _SpecularColor.a;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="波浪和菲涅尔反射"><a href="#波浪和菲涅尔反射" class="headerlink" title="波浪和菲涅尔反射"></a>波浪和菲涅尔反射</h1><h2 id="抓屏的声明"><a href="#抓屏的声明" class="headerlink" title="抓屏的声明"></a>抓屏的声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GrabPass&#123;<span class="string">&quot;GrabPass&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="抓屏属性定义"><a href="#抓屏属性定义" class="headerlink" title="抓屏属性定义"></a>抓屏属性定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> sampler2D GrabPass;</span><br><span class="line">float4 GrabPass_TexelSize;</span><br></pre></td></tr></table></figure><h2 id="实现波浪和菲涅尔反射"><a href="#实现波浪和菲涅尔反射" class="headerlink" title="实现波浪和菲涅尔反射"></a>实现波浪和菲涅尔反射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">//波浪</span></span><br><span class="line">half waveB = <span class="number">1</span> - min(_WaveRangeA, deltaDepth) / _WaveRangeA;</span><br><span class="line">fixed4 noiserColor = tex2D(_NoiseTex, IN.uv_NoiseTex);</span><br><span class="line">         </span><br><span class="line">fixed4 waveColor = tex2D(_WaveTex, float2(waveB + _WaveRange * <span class="built_in">sin</span>(_Time.x * _WaveSpeed + noiserColor.r), <span class="number">1</span>) + offset);</span><br><span class="line"><span class="comment">// waveColor.rgb *= (1 - (sin(_Time.x * _WaveSpeed + noiserColor.r) + 1) / 2) * noiserColor.r;</span></span><br><span class="line">fixed4 waveColor2 = tex2D(_WaveTex, float2(waveB + _WaveRange * <span class="built_in">sin</span>(_Time.x * _WaveSpeed + _WaveDelta + noiserColor.r), <span class="number">1</span>) + offset);</span><br><span class="line"><span class="comment">// waveColor2.rgb *= (1 - (sin(_Time.x * _WaveSpeed + _WaveDelta + noiserColor.r) + 1) / 2) * noiserColor.r;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抓屏操作</span></span><br><span class="line"><span class="comment">//offset利用前几步的定义</span></span><br><span class="line">offset = normal.xy * _Distortion * GrabPass_TexelSize.xy;</span><br><span class="line">IN.proj.xy = offset * IN.proj.z + IN.proj.xy;<span class="comment">//添加扰动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//充当折射光</span></span><br><span class="line"><span class="comment">//进行齐次裁剪</span></span><br><span class="line">fixed3 refrCol = tex2D(GrabPass, IN.proj.xy / IN.proj.w).rgb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//菲涅尔反射</span></span><br><span class="line">fixed3 reflaction = texCUBE(_Cubemap, WorldReflectionVector(IN, normal)).rgb;</span><br><span class="line"></span><br><span class="line">fixed fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span> - dot(IN.viewDir, WorldNormalVector(IN, normal)</span><br><span class="line">), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用菲涅尔系数进行插值</span></span><br><span class="line">        <span class="comment">//菲涅尔差值计算，先反射，后折射  </span></span><br><span class="line">fixed3 refrAndRefl = lerp(reflaction, refrCol, saturate(fresnel));</span><br><span class="line">         </span><br><span class="line">         o.Albedo = (c + (waveColor.rgb + waveColor2.rgb) * waveB) * refrAndRefl;;</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/28&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Albedo (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _WaterShallowColor(<span class="string">&quot;WaterShallowColor&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _WaterDeepColor(<span class="string">&quot;WaterDeepColor&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _DeepPower(<span class="string">&quot;Deep&quot;</span>,Range(<span class="number">0</span>,<span class="number">100</span>)) = <span class="number">2</span></span><br><span class="line">        _TranAmount(<span class="string">&quot;TranAmount&quot;</span>,Range(<span class="number">0</span>,<span class="number">100</span>)) = <span class="number">0.5</span><span class="comment">//水的透明度</span></span><br><span class="line">        _Normal(<span class="string">&quot;Normal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _WaterSpeed(<span class="string">&quot;WaterSpeed&quot;</span>,<span class="type">float</span>) = <span class="number">2</span> <span class="comment">//水流动的速度</span></span><br><span class="line">        _Refract(<span class="string">&quot;Refract&quot;</span>,Float) = <span class="number">0.2</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Specular&quot;</span>, Float) = <span class="number">0.0</span></span><br><span class="line">        _Glossiness (<span class="string">&quot;Gloss&quot;</span>, Float) = <span class="number">0.5</span></span><br><span class="line">        _SpecularColor(<span class="string">&quot;高光颜色&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _WaveTex(<span class="string">&quot;WaveTex&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _NoiseTex(<span class="string">&quot;NoiseTex&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _WaveSpeed(<span class="string">&quot;WaveSpeed&quot;</span>,<span class="type">float</span>) = <span class="number">1</span></span><br><span class="line">       _WaveRange(<span class="string">&quot;WaveRange&quot;</span>,<span class="type">float</span>) = <span class="number">0.5</span></span><br><span class="line">        _WaveRangeA(<span class="string">&quot;WaveRangeA&quot;</span>,<span class="type">float</span>) = <span class="number">1</span></span><br><span class="line">        _WaveDelta(<span class="string">&quot;WaveDelta&quot;</span>,<span class="type">float</span>) = <span class="number">0.5</span></span><br><span class="line">        _Distortion(<span class="string">&quot;Distortion&quot;</span>,<span class="type">float</span>) = <span class="number">0.5</span></span><br><span class="line">       _Cubemap(<span class="string">&quot;Cubemap&quot;</span>,Cube) = <span class="string">&quot;_Skybox&quot;</span>&#123;&#125;</span><br><span class="line">       _FresnelScale(<span class="string">&quot;Fresnel&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        LOD <span class="number">200</span></span><br><span class="line">        </span><br><span class="line">       GrabPass&#123;<span class="string">&quot;GrabPass&quot;</span>&#125;</span><br><span class="line">        ZWrite Off</span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf WaterLight vertex:vert alpha noshadow</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        sampler2D _CameraDepthTexture;</span><br><span class="line">        sampler2D _Normal;</span><br><span class="line">        sampler2D _WaveTex;<span class="comment">//波浪贴图</span></span><br><span class="line">        sampler2D _NoiseTex;<span class="comment">//噪声贴图</span></span><br><span class="line">        sampler2D GrabPass;</span><br><span class="line">       float4 GrabPass_TexelSize;</span><br><span class="line">       samplerCUBE _Cubemap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">            float4 proj;<span class="comment">//屏幕坐标</span></span><br><span class="line">            float2 uv_Normal;</span><br><span class="line">            float2 uv_WaveTex;</span><br><span class="line">          float2 uv_NoiseTex;</span><br><span class="line">            float3 worldRefl;</span><br><span class="line">          float3 viewDir;</span><br><span class="line">          float3 worldNormal; </span><br><span class="line">          INTERNAL_DATA</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        half _Glossiness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line">        </span><br><span class="line">        fixed4 _WaterShallowColor;<span class="comment">//浅水区的颜色</span></span><br><span class="line">        fixed4 _WaterDeepColor;<span class="comment">//深水区的颜色</span></span><br><span class="line">        half _DeepPower;<span class="comment">//水深强度</span></span><br><span class="line">        half _TranAmount;<span class="comment">//透明度数</span></span><br><span class="line">        <span class="type">float</span> _WaterSpeed;<span class="comment">//水法线流动速度</span></span><br><span class="line">        <span class="type">float</span> _Refract;<span class="comment">//法线的密集</span></span><br><span class="line">        fixed4 _SpecularColor;</span><br><span class="line"></span><br><span class="line">       <span class="type">float</span> _WaveSpeed;</span><br><span class="line">       <span class="type">float</span> _WaveRange;</span><br><span class="line">        <span class="type">float</span> _WaveRangeA;</span><br><span class="line">        <span class="type">float</span> _WaveDelta;</span><br><span class="line">        <span class="type">float</span> _Distortion;</span><br><span class="line">       <span class="type">float</span> _FresnelScale;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        fixed4 <span class="title function_">LightingWaterLight</span><span class="params">(SurfaceOutput s,fixed3 lightDir,half3 viewDir,fixed atten)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> diffuse = dot(normalize(lightDir),s.Normal) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">            half3 halfView = normalize(lightDir + viewDir);</span><br><span class="line">            <span class="type">float</span> nh = max(<span class="number">0</span>,dot(halfView,s.Normal));</span><br><span class="line">            <span class="type">float</span> spec = <span class="built_in">pow</span>(nh,s.Specular * <span class="number">128</span>) * s.Gloss;</span><br><span class="line">            fixed4 color;</span><br><span class="line">            color.rgb = (s.Albedo * _LightColor0.rgb * diffuse + _SpecularColor.rgb * spec * _LightColor0.rgb) * atten;</span><br><span class="line">            color.a = s.Alpha + spec * _SpecularColor.a;</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">        <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">vert</span><span class="params">(inout  appdata_full v,out Input i)</span></span><br><span class="line">        &#123;</span><br><span class="line">            UNITY_INITIALIZE_OUTPUT(Input,i);</span><br><span class="line">            </span><br><span class="line">          i.proj = ComputeScreenPos(UnityObjectToClipPos(v.vertex));</span><br><span class="line">          COMPUTE_EYEDEPTH(i.proj.z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutput o)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//下面的宏的第二个宏是接受一个float4 的变量，返回适合深度图采样的变量，大部分平台都是原路返回</span></span><br><span class="line">            <span class="comment">// half depth =  SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture,UNITY_PROJ_COORD(IN.proj));</span></span><br><span class="line">            half depth = LinearEyeDepth(tex2Dproj(_CameraDepthTexture,UNITY_PROJ_COORD(IN.proj)).r);<span class="comment">//投影矩阵，将深度转换为一个线性值，转换到屏幕空间的第一个线性值</span></span><br><span class="line">            <span class="comment">//摄像机的深度减去当前物体的深度，得到结果是水深</span></span><br><span class="line">            <span class="comment">//实际上还</span></span><br><span class="line">            half deltaDepth = depth - IN.proj.z;</span><br><span class="line">            <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = lerp(_WaterShallowColor,_WaterDeepColor,min(_DeepPower,deltaDepth)/_DeepPower);</span><br><span class="line"></span><br><span class="line">            float4 bumpOffset1 = tex2D(_Normal,IN.uv_Normal + float2(_WaterSpeed * _Time.x,<span class="number">0</span>));</span><br><span class="line">            float4 bumpOffset2 = tex2D(_Normal,IN.uv_Normal + float2(<span class="number">1</span>-IN.uv_Normal.y,IN.uv_Normal.x)+float2(_Time.x * _WaterSpeed,<span class="number">0</span>));</span><br><span class="line">            float4 offsetColor = (bumpOffset1+ bumpOffset2)/<span class="number">2</span>;</span><br><span class="line">            float2 offset = UnpackNormal(offsetColor).xy * _Refract;</span><br><span class="line">            float4 bumpColor1 = tex2D(_Normal,IN.uv_Normal +offset+ float2(_WaterSpeed * _Time.x,<span class="number">0</span>));</span><br><span class="line">            float4 bumpColor2 = tex2D(_Normal,offset+float2(<span class="number">1</span>-IN.uv_Normal.y,IN.uv_Normal.x)+float2(_Time.x * _WaterSpeed,<span class="number">0</span>));</span><br><span class="line">            </span><br><span class="line">            float3 normal = UnpackNormal((bumpColor1 + bumpColor2)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//波浪</span></span><br><span class="line">            half waveB = <span class="number">1</span> - min(_WaveRangeA, deltaDepth) / _WaveRangeA;</span><br><span class="line">          fixed4 noiserColor = tex2D(_NoiseTex, IN.uv_NoiseTex);</span><br><span class="line">            </span><br><span class="line">          fixed4 waveColor = tex2D(_WaveTex, float2(waveB + _WaveRange * <span class="built_in">sin</span>(_Time.x * _WaveSpeed + noiserColor.r), <span class="number">1</span>) + offset);</span><br><span class="line">          <span class="comment">// waveColor.rgb *= (1 - (sin(_Time.x * _WaveSpeed + noiserColor.r) + 1) / 2) * noiserColor.r;</span></span><br><span class="line">          fixed4 waveColor2 = tex2D(_WaveTex, float2(waveB + _WaveRange * <span class="built_in">sin</span>(_Time.x * _WaveSpeed + _WaveDelta + noiserColor.r), <span class="number">1</span>) + offset);</span><br><span class="line">          <span class="comment">// waveColor2.rgb *= (1 - (sin(_Time.x * _WaveSpeed + _WaveDelta + noiserColor.r) + 1) / 2) * noiserColor.r;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//抓屏操作</span></span><br><span class="line">            offset = normal.xy * _Distortion * GrabPass_TexelSize.xy;</span><br><span class="line">          IN.proj.xy = offset * IN.proj.z + IN.proj.xy;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//充当折射光</span></span><br><span class="line">          fixed3 refrCol = tex2D(GrabPass, IN.proj.xy / IN.proj.w).rgb;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//菲涅尔反射</span></span><br><span class="line">          fixed3 reflaction = texCUBE(_Cubemap, WorldReflectionVector(IN, normal)).rgb;</span><br><span class="line"></span><br><span class="line">          fixed fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span> - dot(IN.viewDir, WorldNormalVector(IN, normal)</span><br><span class="line">          ), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用菲涅尔系数进行插值</span></span><br><span class="line">            <span class="comment">//菲涅尔差值计算，先反射，后折射  </span></span><br><span class="line">          fixed3 refrAndRefl = lerp(reflaction, refrCol, saturate(fresnel));</span><br><span class="line">            </span><br><span class="line">            o.Albedo = (c + (waveColor.rgb + waveColor2.rgb) * waveB) * refrAndRefl;;</span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Normal = normal;</span><br><span class="line">            o.Specular = _Metallic;</span><br><span class="line">            o.Gloss = _Glossiness;</span><br><span class="line">            o.Alpha = min(_TranAmount,deltaDepth)/_TranAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="效果示例"><a href="#效果示例" class="headerlink" title="效果示例"></a>效果示例</h1><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241115175137.png" alt="image-20241115175131218" style="zoom:67%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241115175615.png" alt="image-20241115175602292" style="zoom:67%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241121182919.gif" alt="2024-11-21 18-04-02 -big-original" style="zoom:150%;" />]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader——中级，Shader动画</title>
      <link href="/posts/93e23347.html"/>
      <url>/posts/93e23347.html</url>
      
        <content type="html"><![CDATA[<h1 id="Shader动画"><a href="#Shader动画" class="headerlink" title="Shader动画"></a>Shader动画</h1><h1 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h1><p><strong>序列帧动画</strong></p><p>对贴图进行采样</p><p><strong>滚动动画</strong></p><p><strong>顶点动画</strong></p><p>最常用的</p><h1 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h1><p>过程上类似于赛璐璐动画的实现，一张贴图上均匀分布动画的不同帧数，配合缩放和位移进行采样即可</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/024&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">       _HorAmount(<span class="string">&quot;HorAmount&quot;</span>, <span class="type">float</span>) = <span class="number">4</span></span><br><span class="line">       _VerAmount(<span class="string">&quot;VerAmount&quot;</span>, <span class="type">float</span>) = <span class="number">4</span></span><br><span class="line">       _Speed(<span class="string">&quot;Speed&quot;</span>,Range(<span class="number">1</span>,<span class="number">100</span>)) = <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">          Zwrite off</span><br><span class="line">          Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">          <span class="type">float</span> _HorAmount;</span><br><span class="line">          <span class="type">float</span> _VerAmount;</span><br><span class="line">          <span class="type">float</span> _Speed;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="comment">//物理公式，路程  = 速度 * 时间</span></span><br><span class="line">             <span class="comment">//time就是路程，一个单位的time走过一帧</span></span><br><span class="line">             <span class="comment">//time除以一行有多少个再进行floor操作，结果上类似于用整数的除法，结果就是row</span></span><br><span class="line">             <span class="comment">//列数column最后就顺理成章的出现</span></span><br><span class="line">             <span class="type">float</span> time = <span class="built_in">floor</span>(_Time.y * _Speed);</span><br><span class="line">             <span class="type">float</span> row = <span class="built_in">floor</span>(time / _HorAmount);</span><br><span class="line">             <span class="type">float</span> column = time - row * _HorAmount;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//</span></span><br><span class="line">             half2 uv = i.uv +half2(column,-row);</span><br><span class="line">             uv.x /= _HorAmount;</span><br><span class="line">             uv.y /= _VerAmount;</span><br><span class="line">             <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, uv);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滚动动画"><a href="#滚动动画" class="headerlink" title="滚动动画"></a>滚动动画</h1><p>对uv进行直接的相加</p><p>下面的是在顶点着色器中时间的，可以让UV随时间向右变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.uv = TRANSFORM_TEX(v.uv, _MainTex) + float2(_ScrollX,<span class="number">0</span>) * _Time.y;</span><br></pre></td></tr></table></figure><h1 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h1><p>最常用的</p><p>在顶点着色器中的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.vertex.y = v.vertex.y + _Arange * <span class="built_in">sin</span>(_Time.y * _Speed + v.vertex.x * _Frequency);</span><br></pre></td></tr></table></figure><h1 id="广告牌原理"><a href="#广告牌原理" class="headerlink" title="广告牌原理"></a>广告牌原理</h1><p>时刻让物体永远朝向摄像机</p><p>表面法线，物体中心到摄像机的位置组成的向量</p><p>计算方式是将摄像机的坐标从世界空间转换到模型空间，然后用新的相机坐标减去模型的锚点，锚点是模型绕着旋转的点，一般取模型坐标的原点</p><p>还有就是在制作组模型的过程中，手动将一个顶点刷上特殊的颜色来作为锚点</p><p><strong>三个正交基向量</strong></p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241114113057.png" alt="image-20241114102836888" style="zoom:67%;" /><p>求解过程是先求出表面法线normal，这个在上文有所提及，</p><p>然后求出up法线的近似向量，（0,1,0），这个并不是真正的up向量，只是为了和表面法向量确定一个平面，</p><p>然后利用这两个向量cross，叉乘，求出Right，right垂直normal和up组成的平面，</p><p>最后normal和right再cross，求出up</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>顶点着色器中的修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认配置锚点为模型坐标原点</span></span><br><span class="line">float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//将相机坐标从世界坐标转换到模型坐标</span></span><br><span class="line">float3 view = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得表面法线</span></span><br><span class="line">            <span class="comment">//_Verical=1，朝向相机，=0，向上朝向相机，即y轴不动</span></span><br><span class="line">            <span class="comment">//最后进行归一化</span></span><br><span class="line">float3 normalDir = view - center;</span><br><span class="line">normalDir.y = normalDir.y * _Verical;</span><br><span class="line">normalDir = normalize(normalDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断float=1，用大于0.999</span></span><br><span class="line">            <span class="comment">//通过就代表近似up向量=normal，cross叉乘会出错    </span></span><br><span class="line">float3 upDir = <span class="built_in">abs</span>(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得变换后的局部坐标</span></span><br><span class="line">float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line"></span><br><span class="line">o.vertex = UnityObjectToClipPos(float4(localPos,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>改行将三个正交基向量确定的坐标系的Y走锁定在（0，1，0）上，最后的结果是绕Y轴追踪摄像机</p><p>对于Quad好用，但是对于Plane，勾选后会导致整个面片消失</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normalDir.y = normalDir.y * _Verical;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader——经验</title>
      <link href="/posts/74dd94d1.html"/>
      <url>/posts/74dd94d1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><p>某些手机端使用samlper2D会造成贴图精度不够，这个时候使用sampler2D_float来提升精度</p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 经验 </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader——中级，高级纹理</title>
      <link href="/posts/987fbb5a.html"/>
      <url>/posts/987fbb5a.html</url>
      
        <content type="html"><![CDATA[<h1 id="高级纹理"><a href="#高级纹理" class="headerlink" title="高级纹理"></a>高级纹理</h1><h1 id="CubeMap"><a href="#CubeMap" class="headerlink" title="CubeMap"></a>CubeMap</h1><p>类似于天空盒，正方体的六个面分别渲染</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="手动拖拽6张无缝贴图"><a href="#手动拖拽6张无缝贴图" class="headerlink" title="手动拖拽6张无缝贴图"></a><strong>手动拖拽6张无缝贴图</strong></h3><p>在Assets中中新建一个Cubemap，位置在Legacy&#x2F;CubeMap中，也可以自行搜索，选择图片之前要先选择清晰度，之后再改无效</p><h3 id="程序化生成"><a href="#程序化生成" class="headerlink" title="程序化生成"></a><strong>程序化生成</strong></h3><p><strong>代码</strong></p><p>实际上该操作是以指定物体为中心，将周围常见渲染到cubemap上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RenderCubeMap</span> : <span class="title">ScriptableWizard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform renderPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Tools/3D Render Cubemap&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateCubeMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScriptableWizard.DisplayWizard&lt;RenderCubeMap&gt;(<span class="string">&quot;Render Cubemap&quot;</span>, <span class="string">&quot;Create&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnWizardCreate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject go = <span class="keyword">new</span> GameObject(<span class="string">&quot;Cumapcam&quot;</span>);</span><br><span class="line">        Camera cam = go.AddComponent&lt;Camera&gt;();</span><br><span class="line">        go.transform.position = renderPos.position;</span><br><span class="line">        cam.RenderToCubemap(cubemap);</span><br><span class="line">        DestroyImmediate(go);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnWizardUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        helpString = <span class="string">&quot;Render cubemap&quot;</span>;</span><br><span class="line">        isValid = (cubemap != <span class="literal">null</span>) &amp;&amp; (renderPos != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在Assets文件中创建</strong></p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241113091212.png" alt="image-20241113091201901" style="zoom: 80%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241113091429.png" alt="image-20241113091422626" style="zoom:67%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241113091634.png" alt="image-20241113091624120" style="zoom: 80%;" /><h3 id="反射探针"><a href="#反射探针" class="headerlink" title="反射探针"></a><strong>反射探针</strong></h3><p>手动在场景中创建反射探针，在操作窗口点击Bake生成，会以当前翻身探针为中心生成Cubemap</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241113093920.png" alt="image-20241113093915943"></p><p>在场景的世界坐标000默认存在一个反射探针，同样可以用于Cubemap创建，使用方式是lightmap中的生成</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>使用的依据是物理中的反射过程</p><p>reflect函数字面意思虽然是反射，但是反射的不一定是光线，任何向量都能作反射向量，<strong>texCUBE用视角方向的反方向求取反射向量来采样cubemap的像素，是比较常用的例子</strong></p><p><strong>补充</strong></p><p>Unity的视角向量是指向相机本身的，灯光的向量也是从模型点指向自身的，在实际使用过程中，指向自身的灯光向量才能计算和法线的cos值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/19&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _CubeMap(<span class="string">&quot;CubeMap&quot;</span>,Cube) = <span class="string">&quot;_Skybox&quot;</span>&#123;&#125;</span><br><span class="line">        _ReflectionColor(<span class="string">&quot;ReflectionColor&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _ReflectionAmount(<span class="string">&quot;ReflectionAmount&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 worldPos :TEXCOORD2;</span><br><span class="line">                float3 worldNormal:TEXCOORD3;</span><br><span class="line">                float3 worldView : TEXCOORD4;</span><br><span class="line">                float3 worldRef : TEXCOORD5;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            fixed4 _ReflectionColor;</span><br><span class="line">            half _ReflectionAmount;</span><br><span class="line">            samplerCUBE _CubeMap;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata_base v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldView = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                o.worldRef = reflect(-o.worldView,o.worldNormal);</span><br><span class="line">                </span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 viewDir = normalize(i.worldView);</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                fixed3 diffuse = col.rgb * _LightColor0.rgb * (dot(worldLightDir,worldNormal) * <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br><span class="line">                fixed3 reflection = texCUBE(_CubeMap,i.worldRef).rgb * _ReflectionColor;</span><br><span class="line">                fixed3 resColor= ambient + lerp(diffuse,reflection,_ReflectionAmount);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, resColor);</span><br><span class="line">                <span class="keyword">return</span> fixed4(resColor,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241113104858.png" alt="image-20241113104852230" style="zoom:67%;" /><h1 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h1><p>基本过程和反射类似，具体是在顶点着色器中的函数使用不同，反射是reflect，则是则是refract</p><p>参数讲解，第一个是入射光线，第二是世界法线，第三个是折射率</p><p>顶点着色器中新添加内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.worldRefra = refract(-normalize(o.worldView),normalize(o.worldNormal),_RefractRotio);</span><br></pre></td></tr></table></figure><p>在片元着色器中的过程没有什么区别</p><h1 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h1><p>不同角度去看一个反射面，折射和反射光的占比不同</p><p>水，垂直于平面去看就是折射大，近似平行于水面就是反射大</p><p>菲涅尔反射式一种描述反射和折射关系的公式</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="Schlick菲涅尔近似等式："><a href="#Schlick菲涅尔近似等式：" class="headerlink" title="Schlick菲涅尔近似等式："></a>Schlick菲涅尔近似等式：</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241113110924.png" alt="image-20241113110919934"></p><h3 id="Empricial菲涅尔近似等式："><a href="#Empricial菲涅尔近似等式：" class="headerlink" title="Empricial菲涅尔近似等式："></a>Empricial菲涅尔近似等式：</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241113110940.png" alt="image-20241113110936437"></p><p>使用最多的是Schick近似公式</p><p><strong>应用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视角方向，世界法线，菲涅尔系数</span></span><br><span class="line">fixed3 fresnel = _FresnelScale + (<span class="number">1</span>-_FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span>-dot(viewDir,worldNormal),<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h1 id="镜面效果"><a href="#镜面效果" class="headerlink" title="镜面效果"></a>镜面效果</h1><p><strong>利用RenderTexture来进行实现</strong></p><h2 id="常用途径"><a href="#常用途径" class="headerlink" title="常用途径"></a>常用途径</h2><ul><li>小地图</li><li>镜子</li></ul><p><strong>RenderTexture</strong></p><p>将相机拍摄到的图输出到RenderTexture上，需要手动在Assets中进行创建，可直接作为一个shader的TEX</p><p>使用RenderTextrue进行实际上是利用延迟渲染的输出，具体特性自行搜索</p><p>对一个镜子来说，摄像机的图片左右会有翻转，需要手动改变uv.x的方向，在顶点着色器中进行如下配置就行，RenderTexture可以直接被MainTex使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.uv.x = <span class="number">1</span> - o.uv.x;</span><br></pre></td></tr></table></figure><h1 id="抓屏"><a href="#抓屏" class="headerlink" title="抓屏"></a>抓屏</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p>之间的版本不想使用，因为有带宽的消耗，现在能用，但是要考虑性能，比如每一个shader都有一个抓屏就有点浪费，一个Shader声明后，别的shader直接 use该通道即可，否则即视为进行了多次抓屏，用法上抓屏命令中的名字相同即可，</p><h2 id="使用顺序"><a href="#使用顺序" class="headerlink" title="使用顺序"></a><strong>使用顺序</strong></h2><p>多个Shader中使用同一个抓屏，就会使用渲染队列考靠前的</p><h2 id="常用途径："><a href="#常用途径：" class="headerlink" title="常用途径："></a><strong>常用途径：</strong></h2><p>1.截取全屏作为截图储存 （常用)。<br>2.截取全屏,模糊处理当作背景。<br>3.接入屏幕中某些指定的画面。</p><h2 id="抓屏命令："><a href="#抓屏命令：" class="headerlink" title="抓屏命令："></a><strong>抓屏命令：</strong></h2><p>GrabPass{“Name”}</p><p>释义： 定义抓屏通道 GrabPass{“_GrabPassTexture”}</p><p>多Shader使用同一个GrabPass也是这样</p><h2 id="声明抓屏通道名称："><a href="#声明抓屏通道名称：" class="headerlink" title="声明抓屏通道名称："></a><strong>声明抓屏通道名称：</strong></h2><p>GrabPassTexture 表示抓屏通道的名称，如果声明了抓屏通道的名称，只需在shader属性声明区声明一下，Unity会自动把抓屏的图形填充到我们声明的GrabPassTexture中，我们可直接通过_GrabPassTexture直接使用该贴图。</p><h2 id="不声明抓屏通道名称"><a href="#不声明抓屏通道名称" class="headerlink" title="不声明抓屏通道名称:"></a><strong>不声明抓屏通道名称:</strong></h2><p>如果不填写抓屏的名称，那么Unity就会默认使用_GrabPassTexture进行保存，我们只需要在Shader属性声明区声明_GrabPassTexture属性，Unity会自动把抓屏完成的贴图填充进去</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/GrabPss&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//设置渲染顺序为最后渲染，这样抓到的屏幕图形则是在所有物体渲染完成后的图像</span></span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Overlay&quot;</span>&#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        <span class="comment">//定义抓屏通道  &#123;&quot;_GrabPassTexture&quot;&#125;  表示抓屏的名称，如果声明的抓屏的名称，只需在shader中在声明一下，Unity会自动把抓屏的图形填充到我们声明的_GradaPss中</span></span><br><span class="line">        <span class="comment">//如果不填写抓屏的名称，那么Unity就会默认使用_GrabTexture进行保存</span></span><br><span class="line">        GrabPass&#123;<span class="string">&quot;_GrabPassTexture&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//抓屏Texture属性</span></span><br><span class="line">            sampler2D _GrabPassTexture;</span><br><span class="line">            fixed4 _GrabPassTexture_ST;</span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//因为采样得到的图片是反的所以我们这里翻转X轴 </span></span><br><span class="line">                o.uv.x=<span class="number">1</span>-o.uv.x;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _GrabPassTexture);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_GrabPassTexture, i.uv);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/23&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">       _MainTex(<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">       _Diffuse(<span class="string">&quot;Color&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">       _BumpMap(<span class="string">&quot;Normal Map&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">       _BumpScale(<span class="string">&quot;Bump Scale&quot;</span>, <span class="type">float</span>) = <span class="number">1</span></span><br><span class="line">       _Cubemap(<span class="string">&quot;CubeMap&quot;</span>,Cube) = <span class="string">&quot;_Skybox&quot;</span>&#123;&#125;</span><br><span class="line">       _Distortion(<span class="string">&quot;Distortion&quot;</span>,Range(<span class="number">0</span>,<span class="number">100</span>)) = <span class="number">10</span></span><br><span class="line">       _RefractAmount(<span class="string">&quot;RefractAmount&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">       Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent+100&quot;</span>&#125;</span><br><span class="line">       LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">       GrabPass&#123;<span class="string">&quot;GrabPass&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">       Pass</span><br><span class="line">       &#123;</span><br><span class="line">          CGPROGRAM</span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> multi_compile __ SNOW_ON</span></span><br><span class="line">          <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">          <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">struct</span> v2f</span><br><span class="line">          &#123;</span><br><span class="line">             float4 vertex : SV_POSITION;</span><br><span class="line">             float4 uv :TEXCOORD0;</span><br><span class="line">             float4 TtoW0 : TEXCOORD1;</span><br><span class="line">             float4 TtoW1 :TEXCOORD2;</span><br><span class="line">             float4 TtoW2 :TEXCOORD3;</span><br><span class="line">             float4 scrPos: TEXCOORD4;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          sampler2D _MainTex;</span><br><span class="line">          float4 _MainTex_ST;</span><br><span class="line">          fixed4 _Diffuse;</span><br><span class="line">          sampler2D _BumpMap;</span><br><span class="line">          float4 _BumpMap_ST;</span><br><span class="line">          <span class="type">float</span> _BumpScale;</span><br><span class="line">          sampler2D GrabPass;</span><br><span class="line">          float4 GrabPass_TexelSize;</span><br><span class="line">          <span class="type">float</span> _Distortion;</span><br><span class="line">          samplerCUBE _Cubemap;</span><br><span class="line">          <span class="type">float</span> _RefractAmount;</span><br><span class="line"></span><br><span class="line">          v2f <span class="title function_">vert</span><span class="params">(appdata_tan v)</span></span><br><span class="line">          &#123;</span><br><span class="line">             v2f o;</span><br><span class="line">             o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             o.scrPos = ComputeGrabScreenPos(o.vertex);</span><br><span class="line">             o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">             o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line"></span><br><span class="line">             fixed3 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">             fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">             fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">             fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">             o.TtoW0 = float4(worldTangent.x,worldBinormal.x,worldNormal.x, worldPos.x);</span><br><span class="line">             o.TtoW1 = float4(worldTangent.y,worldBinormal.y,worldNormal.y, worldPos.y);</span><br><span class="line">             o.TtoW2 = float4(worldTangent.z,worldBinormal.z,worldNormal.z, worldPos.z);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> o;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">          &#123;</span><br><span class="line">             fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT;</span><br><span class="line"></span><br><span class="line">             fixed4 albedo = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">             float3 worldPos = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);</span><br><span class="line"></span><br><span class="line">             fixed3 lightDir = UnityWorldSpaceLightDir(worldPos);</span><br><span class="line">             fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">             <span class="comment">//求法线</span></span><br><span class="line">             fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw);</span><br><span class="line">             fixed3 tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">             tangentNormal.xy *= _BumpScale;</span><br><span class="line">             fixed3 worldNormal = normalize(float3(dot(i.TtoW0.xyz, tangentNormal), dot(i.TtoW1.xyz, tangentNormal),dot(i.TtoW2.xyz,tangentNormal)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//采样抓屏贴图</span></span><br><span class="line">float2 offset = tangentNormal.xy * _Distortion * GrabPass_TexelSize.xy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给扰动值offset乘上屏幕空间的深度z，在屏幕空间越深的地方，扰动越明显</span></span><br><span class="line">i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//i.scrPos，是使用</span></span><br><span class="line"><span class="comment">//o.vertex = UnityObjectToClipPos(v.vertex);</span></span><br><span class="line"><span class="comment">//o.scrPos = ComputeGrabScreenPos(o.vertex);</span></span><br><span class="line"><span class="comment">//这两个方法取得的，这里的屏幕空间坐标没有进行齐次除法，并不是真正的屏幕空间</span></span><br><span class="line"><span class="comment">//使用xy/w，就能得到</span></span><br><span class="line">fixed3 refrCol = tex2D(GrabPass,i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line"></span><br><span class="line">             fixed3 reflCol = texCUBE(_Cubemap, reflect(-viewDir, worldNormal)).rgb * albedo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             fixed3 color = reflCol * (<span class="number">1</span> - _RefractAmount) + refrCol * _RefractAmount;</span><br><span class="line">             <span class="keyword">return</span> fixed4(color,<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ENDCG</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241113162917.png" alt="image-20241113162911745" style="zoom:67%;" /><h3 id="抓屏中用到的特殊属性"><a href="#抓屏中用到的特殊属性" class="headerlink" title="抓屏中用到的特殊属性"></a><strong>抓屏中用到的特殊属性</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sampler2D GrabPass; <span class="comment">//GrabPassName配合的</span></span><br><span class="line">float4 GrabPass_TexelSize;</span><br></pre></td></tr></table></figure><ul><li>这不是缩放值，而是一个包含纹理尺寸和纹素大小（texel size）的向量。具体来说，<code>GrabPass_TexelSize</code>的<code>xy</code>分量通常表示纹理的一个纹素（即纹理中的一个像素或纹理单元）对应的屏幕空间尺寸（以世界单位或屏幕空间的某种度量表示，这取决于Unity的内部实现和渲染设置）。<code>zw</code>分量可能表示纹理的总尺寸（宽度和高度）的倒数，但具体含义可能因Unity的版本和渲染管道而异。</li><li>重要的是要理解<code>GrabPass_TexelSize</code>的<code>xy</code>分量提供了从纹理坐标到屏幕空间坐标（或反之）进行转换的比例因子。这对于实现精确的屏幕空间效果至关重要，因为它允许你根据纹理的分辨率和屏幕的分辨率来计算偏移量或进行其他相关的数学计算。</li></ul><h1 id="Command-Buffers"><a href="#Command-Buffers" class="headerlink" title="Command_Buffers"></a>Command_Buffers</h1><p>Unity默认渲染管线提供的C#接口，在每个渲染顺序完成后给吹一张图片让我们进行处理</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h2><p>Unity2017版本以及之前的shader可视化开发可以使用插件，shader forge，但是shaderfoege对默认渲染管线的支持不是很好，同时shaderforge有关的纹理叫做程序化纹理，随着版本的更新，暂时不需要学习，当前Unity提供的可视化shader工具叫做 shader graph</p><h2 id="深度图采样"><a href="#深度图采样" class="headerlink" title="深度图采样"></a>深度图采样</h2><p>高度物、水效果</p><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>某些手机端使用samlper2D会造成贴图精度不够，这个时候使用sampler2D_float来提升精度</p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader——中级，LightMap</title>
      <link href="/posts/815f1d7.html"/>
      <url>/posts/815f1d7.html</url>
      
        <content type="html"><![CDATA[<h1 id="LightMap"><a href="#LightMap" class="headerlink" title="LightMap"></a>LightMap</h1><h1 id="渲染类型"><a href="#渲染类型" class="headerlink" title="渲染类型"></a>渲染类型</h1><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112105625.png" alt="image-20241112105621401"></p><h2 id="Lighting设置"><a href="#Lighting设置" class="headerlink" title="Lighting设置"></a>Lighting设置</h2><p>在比较新的版本中，Lighting中的设置位置发生的变化，需要通过Windows-》Rendering进入，按照图示前往</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112110338.png" alt="image-20241112110331875" style="zoom:67%;" /><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112110340.png" alt="image-20241112110246754"></p><p>skybox：环境光是天空盒的颜色</p><p>Gradient：对天空，中间，大地的颜色做了一个详细的区分</p><p>color：单一颜色代表环境光</p><p><strong>反射光的选项</strong></p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112141643.png" alt="image-20241112141637421" style="zoom:67%;" /><p><strong>实时光和烘焙光各自的控制</strong></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112141753.png" alt="image-20241112141749786"></p><h2 id="实时光照GI"><a href="#实时光照GI" class="headerlink" title="实时光照GI"></a>实时光照GI</h2><h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><p>在2023.2版本中，一个场景需要新建一个LightAssets，然后才能对这些数据进行修改</p><p>将场景中的需要进行实时光照贴图渲染的游戏对象在设置窗口右上角的Static选项框中勾选下图所示的左侧有对钩的选项就可以启动光照贴图，然后再去Lighting窗口中点击最下面的 <strong>Generate Lighting</strong>选项就能生成实时光照贴图，需要注意场景中的需要进行实时光照贴图的灯光的选项也应该是RealTime</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112145412.png" alt="image-20241112145408506"></p><p>实时光照贴图有一定的精度区分，在Lighting的设置中，下图红框所所示的数字就是实时光照贴图的精度，这个值越大，贴图越精细</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112145418.png" alt="image-20241112145201797"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112145420.png" alt="image-20241112145157361"></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112151113.png" alt="image-20241112151107945"></p><ol><li>Directional Mode：直射模式</li><li>Albedo Boost：间接光照的强度</li><li>Indirect Intensity:光的发射率，金属材质就稍微调高</li><li>LightMap Parameters:对光照贴图进行设置</li></ol><h3 id="GIcache"><a href="#GIcache" class="headerlink" title="GIcache"></a>GIcache</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112175929.png" alt="image-20241112150346082"></p><p>实际上实时光的光照贴图是一种预计算技术，在游戏过程中如果场景发生变化，会根据保存在GIcache中的数据进行计算</p><h2 id="MixedGI"><a href="#MixedGI" class="headerlink" title="MixedGI"></a>MixedGI</h2><p>取消Lighting设置的RealTime，并将灯光的Mode设置为Mixed，并且，这里的结果都写死的，并不是实时光照中的参考计预计算</p><p>补充一些知识，选用Subtractive技术，静态物体的阴影不会作用在动态物体上，需要使用Light Props或者被称为光照探针等一些技术</p><p>手游使用Subtractive技术偏多，Unity推荐使用ShadowMask</p><p>这里有三种光照模式提供选择</p><p><strong>Mixed Lighting:</strong></p><p><strong>Bake Indirect</strong>:只烘培间接光照，直接光以及阴影进行实时计算。运行时改变灯光，直接光照和阴影就会变，但间接光不变（如果间接光弱，视觉影响不大）。只减少间接光照的实时计算，适合对光照要求较高的场景，内存消耗小，当然性能的消耗也大。</p><p><strong>shadowmask</strong>：对静态物体直接光照产生的阴影也会被烘培到ShadowMask中，动态物体不受影响。运行时改变灯光只有间接光照和静态物体的阴影不受影响。内存中多了一份Shadowmask，比上一部少了静态物体阴影的计算，占用性能小了一点。在2023版本中，需要对在ProjectSetting中的Quality下的<strong>ShadowMask Mode</strong>进行一个设置，默认开启的是<strong>DistanceShadowMask</strong>，要实现上述描述的效果，要调整为<strong>ShadowMask</strong>，同时在该模式下还具备<strong>Shadow  Distance</strong>的属性设置，在摄像机多少距离内才产生阴影。下面给出正式的解释</p><p><strong>单就阴影来说</strong></p><ul><li><p>当Bake过后光源没有发生变化的时候，两者区别不大（就是工作方式有些区别）</p></li><li><p>当Bake过后光源变化了的时候，两者区别明显</p><p>在Distance之外，两种模式没有区别，距离外动态物体都不能投射阴影，静态物理都靠预先计算的结果。</p><p>在Distance之内，DistanceShadowMask，使用ShadowMap实时计算动态物体静态物体阴影。而ShadowMask 只实时计算动态物体的阴影。</p></li></ul><p><strong>substrative</strong>：静态物体：直接光和间接光都烘焙到光照贴图中；动态物体：接收直接光，可以在静态物体上投射主方向光的阴影。运行时改变光照，静态物体直接光、间接光、阴影不受影响，动态物体的直接光、主灯光（平行光）投射的阴影受影响、其他灯光无阴影。性能消耗最小，应用广。</p><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><h4 id="参照图片"><a href="#参照图片" class="headerlink" title="参照图片"></a>参照图片</h4><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112171806.png" alt="image-20241112171755390" style="zoom: 150%;" /><p><strong>Lightmapper （Progressive Cpu）</strong></p><p>Prioritize View ：烘培的先后顺序，先烘培摄像机视锥体里面已经启用的元素，然后在烘培视锥体以外的。</p><p>Direct Samples： 直接光照采样数量 影响质量、速度</p><p>Indirect Samples ：间接光照采样数量 影响质量、速度</p><p>Enviroment Samples：环境光采样数量 影响质量、速度</p><p> Bounces: 间接光的反射次数。跟踪路径时要执行的间接反弹次数。 对于大多数场景来说，两次反弹就足够了。 对于一些室内场景，可能需要更多。</p><p><strong>Filtering:滤波</strong></p><ol><li>Direct Denoiser:减少直射光噪点。</li><li>Direct Filter：直射光滤波。None:无。Gaussian：高斯滤波器。A-Trous：A-Trous滤波器。Indirect Denoiser:减少间接光噪点。</li><li>Indirect Filter：间接光滤波。None:无。Gaussian：高斯滤波器。A-Trous：A-Trous滤波器。 Ambient Denoiser:减少环境光噪点。</li><li>Indirect Filter：环境光滤波。None:无。Gaussian：高斯滤波器。A-Trous：A-Trous滤波器。</li></ol><p>Indirect Resolution：使用此值指定用于间接照明计算的每个单元的纹理元素数。 增加此值可提高间接光的视觉质量，但也会增加烘烤光照贴图所需的时间。 默认值是2。</p><p>Lightmap Resolution：使用此值指定用于光照贴图的每个单位的纹理像素数。 增加此值可提高光照贴图质量，但也会增加烘烤时间。 默认值是40。</p><p>Lightmap Padding：使用此值可指定烘焙光照贴图中不同形状之间的分隔（以texel为单位）。 默认值是2。</p><p>Lightmap Size：光照贴图大小。</p><p>Compress Lightmaps:压缩的光照贴图需要较少的存储空间，但压缩过程会将不需要的视觉效果引入到纹理中。 选中此复选框可压缩光照贴图，或取消选中它以保持其未压缩状态。 该复选框默认打勾。</p><p>Ambient Occlusion:允许您控制环境遮挡中表面的相对亮度。 较高的值表示遮挡区和全亮区之间的较大对比度。 这仅适用于由GI系统计算的间接照明</p><p>Directional Mode:可以设置光照贴图来存储关于物体表面上每个点处主导入射光的信息。</p><p> Directional:在方向模式下，会生成第二个光照贴图来存储入射光的主要方向。 这允许漫射法线贴图材料与GI一起工作。 定向模式需要大约两倍的额外光照贴图数据的存储空间。 定向光照贴图无法在SM2.0硬件或使用GLES2.0时解码。 他们将回退到非定向光照贴图。</p><p>  Non-directiona:无方向模式。</p><p>ndirect Intensity:控制实时存储的间接光照和烘焙光照贴图的亮度，亮度值介于0和5之间。大于1的值会增加间接光的强度，而小于1的值会降低间接光的强度。 默认值是1。</p><p>Albedo Boost:控制通过强化场景中材质的反照率来控制表面之间反射的光量，数值介于1和10之间。增加此值可将反射率值绘制为白色以进行间接光线计算。 默认值1是物理上准确的。</p><p><strong>Lightmapper （Enlighten）</strong></p><ol><li>Indirect Resolution：间接光照分辨率，数值越高，光照细节越高</li><li>Lightmap Resolution：光照贴图分辨率（每单位长度多少体素），通常设置为Indirect Resolution的10倍左右</li><li>Lightmap Padding：修正两个物体的Lightmap之间的距离，以避免颜色渗透</li><li>Lightmap Size：光照贴图大小</li><li>Compress Lightmaps：是否压缩光照贴图</li><li>Ambient Occlusion：是否烘焙环境光遮罩</li><li>Final Gather：是否对最后一次GI光线反射后的光照结果再进行一次FG计算，勾选上会有较好的质量表现，但烘焙时间会增加</li><li>Directional Mode:可以设置光照贴图来存储关于物体表面上每个点处主导入射光的信息。</li><li>Directional:在方向模式下，会生成第二个光照贴图来存储入射光的主要方向。 这允许漫射法线贴图材料与GI一起工作。 定向模式需要大约两倍的额外光照贴图数据的存储空间。 定向光照贴图无法在SM2.0硬件或使用GLES2.0时解码。 他们将回退到非定向光照贴图。</li><li>Non-directiona:选它。不要考虑。</li><li>Indirect Intensity：间接光照的强度</li><li>Albedo Boost:控制通过强化场景中材质的反照率来控制表面之间反射的光量，数值介于1和10之间。</li></ol><p><strong>补充知识</strong></p><p>同时开启实时实时光照GI和BakeGi</p><p>起到决定性作用的是光源的mode</p><h1 id="在Shader中的运行"><a href="#在Shader中的运行" class="headerlink" title="在Shader中的运行"></a>在Shader中的运行</h1><p>统一是SurfaceShader中根据设定自动生成的</p><p>顶点着色器中的设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DYNAMICLIGHTMAP_ON <span class="comment">//实时光照GI</span></span></span><br><span class="line">o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LIGHTMAP_ON<span class="comment">//bake光照GI</span></span></span><br><span class="line">o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>片元着色器中的设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup lighting environment</span></span><br><span class="line">UnityGI gi;</span><br><span class="line">UNITY_INITIALIZE_OUTPUT(UnityGI, gi);</span><br><span class="line">gi.indirect.diffuse = <span class="number">0</span>;</span><br><span class="line">gi.indirect.specular = <span class="number">0</span>;</span><br><span class="line">gi.light.color = _LightColor0.rgb;</span><br><span class="line">gi.light.dir = lightDir;</span><br><span class="line"><span class="comment">// Call GI (lightmaps/SH/reflections) lighting function</span></span><br><span class="line">UnityGIInput giInput;</span><br><span class="line">UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);</span><br><span class="line">giInput.light = gi.light;</span><br><span class="line">giInput.worldPos = worldPos;</span><br><span class="line">giInput.worldViewDir = worldViewDir;</span><br><span class="line">giInput.atten = atten;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)</span></span><br><span class="line">  giInput.lightmapUV = IN.lmap;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  giInput.lightmapUV = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_SHOULD_SAMPLE_SH &amp;&amp; !UNITY_SAMPLE_FULL_SH_PER_PIXEL</span></span><br><span class="line">  giInput.ambient = IN.sh;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  giInput.ambient.rgb = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">giInput.probeHDR[<span class="number">0</span>] = unity_SpecCube0_HDR;</span><br><span class="line">giInput.probeHDR[<span class="number">1</span>] = unity_SpecCube1_HDR;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)</span></span><br><span class="line">  giInput.boxMin[<span class="number">0</span>] = unity_SpecCube0_BoxMin; <span class="comment">// .w holds lerp value for blending</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNITY_SPECCUBE_BOX_PROJECTION</span></span><br><span class="line">  giInput.boxMax[<span class="number">0</span>] = unity_SpecCube0_BoxMax;</span><br><span class="line">  giInput.probePosition[<span class="number">0</span>] = unity_SpecCube0_ProbePosition;</span><br><span class="line">  giInput.boxMax[<span class="number">1</span>] = unity_SpecCube1_BoxMax;</span><br><span class="line">  giInput.boxMin[<span class="number">1</span>] = unity_SpecCube1_BoxMin;</span><br><span class="line">  giInput.probePosition[<span class="number">1</span>] = unity_SpecCube1_ProbePosition;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">LightingStandard_GI(o, giInput, gi);</span><br><span class="line"></span><br><span class="line"><span class="comment">// realtime lighting: call lighting function</span></span><br><span class="line">c += LightingStandard (o, worldViewDir, gi);</span><br><span class="line">UNITY_APPLY_FOG(_unity_fogCoord, c); <span class="comment">// apply fog</span></span><br><span class="line">UNITY_OPAQUE_ALPHA(c.a);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader——中级，SurfaceShader</title>
      <link href="/posts/fef60aa9.html"/>
      <url>/posts/fef60aa9.html</url>
      
        <content type="html"><![CDATA[<h1 id="Unity，SurfaceShader"><a href="#Unity，SurfaceShader" class="headerlink" title="Unity，SurfaceShader"></a>Unity，SurfaceShader</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ol><li>Surface Shader和CG其他部分一样，代码也是要写在CGPROGRAM和ENDCG之间。但区别是，它必须写在SubShader内部，而不能写在Pass内部。Surface Shader自己会自动生成所需的各个Pass。由上面的编译格式可以看出，surfaceFunction和lightModel是必须指定的。</li><li>surfaceFunction通常就是名为surf的函数（函数名可以任意），它的函数格式是固定的：</li><li>void surf (Input IN, inout SurfaceOutput o)</li><li>void surf (Input IN, inout SurfaceOutputStandard o)</li><li>void surf (Input IN, inout SurfaceOutputStandardSpecular o)</li><li>lightModel也是必须指定的。由于Unity内置了一些光照函数——Lambert（diffuse）和Blinn-Phong（specular），因此这里在默认情况下会使用内置的Lambert模型。当然我们也可以自定义，给出的Blinn-Phong同时也计算了Lambert</li><li>optionalparams包含了很多可用的指令类型，包括开启、关闭一些状态，设置生成的Pass类型，指定可选函数等。除了上述的surfaceFuntion和lightModel，我们还可以自定义两种函数：vertex:VertexFunction和finalcolor:ColorFunction。也就是说，Surface Shader允许我们自定义四种函数。</li></ol><h2 id="最重要的定义"><a href="#最重要的定义" class="headerlink" title="最重要的定义"></a>最重要的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> surface surfaceFunction lightModel [optionalparams]</span></span><br><span class="line"><span class="comment">//      Surface 关键函数  光照模型 操作参数，当前的意义是打开前向渲染的所有阴影      </span></span><br><span class="line">pragma surface surf Standard fullforwardshadows</span><br><span class="line"><span class="comment">//光照模型一般以Light开头</span></span><br></pre></td></tr></table></figure><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241108110506.png" alt="image-20241108110459784" style="zoom:67%;" /><h2 id="SurfaceShader编译成为基本Shader形式后的重要内容解释"><a href="#SurfaceShader编译成为基本Shader形式后的重要内容解释" class="headerlink" title="SurfaceShader编译成为基本Shader形式后的重要内容解释"></a>SurfaceShader编译成为基本Shader形式后的重要内容解释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;UnityShaderVariables.cginc&quot;</span><br><span class="line">#include &quot;UnityShaderUtilities.cginc&quot;</span><br></pre></td></tr></table></figure><p>上面的代码用来引入</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241108111721.png" alt="image-20241108111716064" style="zoom:67%;" /><p>建议将该内容创建在和Shader同级的目录</p><p>功能是当Shader第一次渲染后保存编译结果，之后就直接调用该文件中的内容，节省开销</p><h2 id="输入结构体"><a href="#输入结构体" class="headerlink" title="输入结构体"></a>输入结构体</h2><p>默认使用的是在UnityCG.cging中的 appdata_full，结构体</p><h2 id="计算函数"><a href="#计算函数" class="headerlink" title="计算函数"></a>计算函数</h2><ol><li><p><strong>最重要的</strong></p><p>void surf (Input IN, inout SurfaceOutput o)</p><p>void surf (Input IN, inout SurfaceOutputStandard o)</p><p>void surf (Input IN, inout SurfaceOutputStandardSpecular o)</p></li><li><p><strong>顶点修改</strong></p><p>void vert (inout appdata_full v)</p><p>void vert(inout appdata_full v, out Input o)</p></li><li><p><strong>unity老版本（新版本兼容）不包含GI的</strong></p><p>half4 Lighting<Name> (SurfaceOutput s, half3 lightDir, half atten)</p><p>half4 Lighting<Name> (SurfaceOutput s, half3 lightDir, half3 viewDir, half atten)</p></li><li><p><strong>unity新版本（包含GI，要自定义GI函数）</strong></p><p>half4 Lighting<Name> (SurfaceOutput s, UnityGI gi)</p><p>half4 Lighting<Name> (SurfaceOutput s, half3 viewDir, UnityGI gi)</p><p><strong>新老版本中的函数的第一个参数需要和Surf函数中的第二个参数对应</strong></p></li><li><p>&#x2F;<strong>延迟渲染</strong></p><p>half4 Lighting<Name>_Deferred (SurfaceOutput s, UnityGI gi, out half4 outDiffuseOcclusion, out half4 outSpecSmoothness, out half4 outNormal)</p></li><li><p><strong>遗留的延迟渲染</strong></p><p>half4 Lighting<Name>_PrePass (SurfaceOutput s, half4 light)</p></li><li><p><strong>自定义GI</strong></p><p>half4 Lighting<Name>_GI (SurfaceOutput s, UnityGIInput data, inout UnityGI gi);</p></li><li><p>&#x2F;<strong>&#x2F;最终颜色修改</strong></p><p>void final(Input IN, SurfaceOutput o, inout fixed4 color)</p><p>void final(Input IN, SurfaceOutputStandard o, inout fixed4 color)</p><p>void final(Input IN, SurfaceOutputStandardSpecular o, inout fixed4 color)</p></li></ol><h2 id="插入函数"><a href="#插入函数" class="headerlink" title="插入函数"></a>插入函数</h2><p><strong>光照模型</strong></p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241108215814.png" alt="image-20241108215808520" style="zoom:67%;" /><p><strong>顶点和最终颜色修改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> surface surf Mao fullforwardshadows vertex:vert finalcolor:final <span class="comment">//重要定义中的最后两个就是设定两个函数</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">。。。。。。</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">vert</span><span class="params">(inout appdata_full v)</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">final</span><span class="params">(Input IN, SurfaceOutputStandard o, inout fixed4 color)</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>插入位置</strong></p><p>以新建的SurfaceShader为标准，顶点修改和最终颜色插入到它下面，自定义光照模型在它上面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//大致上要将顶点修改和最终颜色修改加入到这个位置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">    <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">    <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">    UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">        <span class="comment">// put more per-instance properties here</span></span><br><span class="line">    UNITY_INSTANCING_BUFFER_END(Props)</span><br></pre></td></tr></table></figure><h2 id="Surface结构体限制"><a href="#Surface结构体限制" class="headerlink" title="Surface结构体限制"></a>Surface结构体限制</h2><p>两个结构体就是指struct Input和SurfaceOutput。其中Input结构体是允许我们自定义的。如下表。这些变量只有在真正使用的时候才会被计算生成。在一个贴图变量之前加上uv两个字母，就代表提取它的uv值，例如uv_MainTex 。</p><p><strong>Input</strong></p><table><thead><tr><th><strong>变量</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>float3  viewDir</td><td>视角方向  （view direction）。可用于计算边缘光照等。</td></tr><tr><td>float4  with COLOR semantic</td><td>每个顶点插值后的颜色</td></tr><tr><td>float4  screenPos</td><td>屏幕空间中的位置。  为了反射效果，需要包含屏幕空间中的位置信息。</td></tr><tr><td>float3  worldPos</td><td>世界空间中的位置。</td></tr><tr><td>float3  worldRefl</td><td>世界空间中的反射向量。  如果surface shader没有赋值o.Normal，将会包含世界反射向量。</td></tr><tr><td>float3  worldNormal</td><td>世界空间中的法线向量。如果surface  shader没有赋值o.Normal，将会包含世界法向量</td></tr><tr><td>float3  worldRefl; INTERNAL_DATA</td><td>世界空间中的反射向量。如果surface  shader没有赋值o.Normal，将会包含这个参数。为了获得逐像素法线贴图的反射向量，请使用WorldReflectionVector (IN,  o.Normal)。</td></tr><tr><td>float3  worldNormal; INTERNAL_DATA</td><td>世界空间中的法线向量。如果surface  shader没有赋值o.Normal，将会包含世界法向量。为了获得逐像素法线贴图的法向量，请使用WorldNormalVector (IN,  o.Normal)，获得法线贴图的世界坐标向量</td></tr></tbody></table><p><strong>SuffaceSahder</strong></p><p>另一个结构体是（SurfaceOutput、SurfaceOutputStandard和SurfaceOutputStandardSpecular）。我们也可以自定义这个结构体内的变量，<strong>自定义最少需要有4个成员变量：Albedo、Normal、Emission和Alpha，缺少一个都会报错。关于它最难理解的也就是每个变量的具体含义以及工作机制（对像素颜色的影响）。</strong></p><p><strong>SurfaceOutput的示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SurfaceOutput</span> &#123;</span></span><br><span class="line">  fixed3 Albedo;</span><br><span class="line">  fixed3 Normal;</span><br><span class="line">  fixed3 Emission;</span><br><span class="line">  half Specular;</span><br><span class="line">  fixed Gloss;</span><br><span class="line">  fixed Alpha;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Albedo</strong>：我们通常理解的对光源的反射率。它是通过在Fragment Shader中计算颜色叠加时，和一些变量（如vertex lights）相乘后，叠加到最后的颜色上的。(漫反射颜色)</p></li><li><p><strong>Normal</strong>：即其对应的法线方向。只要是受法线影响的计算都会受到影响。</p></li><li><p><strong>Emission</strong>：自发光。会在Fragment 最后输出前（调用final函数前，如果定义了的话），使用下面的语句进行简单的颜色叠加：</p><p>c.rgb +&#x3D; o.Emission;</p></li><li><p><strong>Specular</strong>：高光反射中的指数部分的系数。影响一些高光反射的计算。按目前的理解，也就是在光照模型里会使用到（如果你没有在光照函数等函数——包括Unity内置的光照函数，中使用它，这个变量就算设置了也没用）。有时候，你只在surf函数里设置了它，但也会影响最后的结果。这是因为，你可能使用了Unity内置的光照模型，如BlinnPhong，它会使用如下语句计算高光反射的强度（在Lighting.cginc里）：</p><p>float spec &#x3D; pow (nh, s.Specular*128.0) * s.Gloss;</p></li><li><p><strong>Gloss</strong>：高光反射中的强度系数。和上面的Specular类似，一般在光照模型里使用。</p></li><li><p><strong>Alpha</strong>：通常理解的透明通道。在Fragment Shader中会直接使用下列方式赋值（如果开启了透明通道的话）：c.a &#x3D; o.Alpha;</p></li></ul><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p><strong>透明度混合与透明度测试</strong></p><p>alpha or alpha:auto  为简单光照选择褪色透明度(等同于alpha:fade) ，以及基于物理照明的预乘透明度(等同于alpha:premul) </p><p>alpha:blend        开启透明度混合</p><p>alpha:fade         开启传统渐变透明</p><p>alpha:premul       开启预乘a透明度</p><p>alphatest:VariableName  根据VariableName的变量来控制透明度混合和透明度测试，VariableName是一个float型的变量，剔除不满足条件的片元，此时往往需要用到addshadow来生成正确阴影投射的Pass</p><p>keepalpha         默认不透明表面着色器将1写入A通道，不管alpha输出值以及光照函数的返回值</p><p>decal:add          对其他表面上的物体使用additive blending</p><p>decal:blend        对其他表面上的物体使用alpha blending</p><p><strong>自定义修改函数</strong></p><p>vertex:VertexFunction     顶点修改函数，用于修改计算顶点位置、信息等</p><p>finalcolor:ColorFunction    最终颜色修改函数</p><p>finalgbuffer:ColorFunction  自定义延迟路径，用于更改gbuffer</p><p>finalprepass:ColorFunction  自定义预处理路径</p><p><strong>阴影</strong></p><p>addshadow          生成一个阴影投射的Pass，为一些使用了顶点动画、透明度测试的物体产生正确的阴影</p><p>fullforwardshadows   支持前向渲染路径中所有光源类型的阴影，shader默认只支持最重要平行光的阴影，添加该参数可以支持点光源或聚光灯的阴影效果 </p><p>tessellate:TessFunction 使用DX11 GPU曲面细分</p><p>控制代码生成(表面着色器默认处理所有坑能的光照、阴影、光照烘培，可手动调整跳过一些不必要的加载提升性能)</p><p>exclude_path:deferred, exclude_path:forward, exclude_path:prepass  不为某个渲染路径生成代码</p><p>noshadow      禁用阴影</p><p>noambient      不应用任何环境光以及光照探针</p><p>novertexlights   在前向渲染路径中不应用任何逐顶点光照及光照探针</p><p>nolightmap     不应用任何光照烘培</p><p>nodynlightmap  不应用实时GI</p><p>nodirlightmap   不应用directional lightmaps</p><p>nofog         不应用任何雾效</p><p>nometa      生成meta这个Pass(that’s used by lightmapping &amp; dynamic global illumination to extract surface information)</p><p>noforwardadd   不应用前向渲染中所有的additive pass，使得shader只支持一个重要平行光，其他光用逐顶点&#x2F;SH光源计算光照影响，使shader更精简</p><p>nolppv         不应用光照探针代理Light Probe Proxy Volume(LPPV)</p><p>noshadowmask  不应用Shadowmask</p><p><strong>其他</strong></p><p>softvegetation    只有当Soft Vegetation(软植被)开启时该shader才被渲染</p><p>interpolateview   在顶点而不是片元着色器中计算 view direction并插值，需多使用一张纹理插值器，提升渲染速度</p><p>halfasview      Pass half-direction vector into the lighting function instead of view-direction. Half-direction will be computed and normalized per vertex. This is faster, but not entirely correct.</p><p>dualforward     在前向渲染中使用dual lightmaps</p><p>dithercrossfade   使表面着色器支持 dithering effects</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="BlinnPhong"><a href="#BlinnPhong" class="headerlink" title="BlinnPhong"></a>BlinnPhong</h2><p>流程上使用了官方实现的简单光照模型，同时在Properties中的属性要对应，就比如高光反射的颜色就需要命名为 _SpecColor，同时还不需要自己在CGPROGRAM中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Surface01&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Albedo (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//surfaceShader中官方给出的BlinnPhong光照中的高光颜色名</span></span><br><span class="line">_SpecColor (<span class="string">&quot;SpecColor&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Gloss (<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Specular (<span class="string">&quot;Specular&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf BlinnPhong fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//surfaceShader中不需要声明贴图的ST</span></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        half _Gloss;</span><br><span class="line">        half _Specular;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">        <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutput o)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">            o.Albedo = c.rgb;</span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Specular = _Specular;</span><br><span class="line">            o.Gloss = _Gloss;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="法线贴图采样"><a href="#法线贴图采样" class="headerlink" title="法线贴图采样"></a>法线贴图采样</h2><p>唯一的代码只需要在Surf函数中输入以下代码就行</p><p>Normal在使用法线贴图的时候就代表贴图法线</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutputStandard o)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">            o.Albedo = c.rgb;</span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Glossiness;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//法线贴图</span></span><br><span class="line">            float3 normal = UnpackNormal(tex2D(_BumpMap,IN.uv_BumpMap));</span><br><span class="line">            normal.xy *= _BumpScale;</span><br><span class="line">            o.Normal =  normal;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="最终颜色控制"><a href="#最终颜色控制" class="headerlink" title="最终颜色控制"></a>最终颜色控制</h2><p>Properties<strong>控制</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_FinalColor(<span class="string">&quot;FinalColor&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>关键 pragma设置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> surface surf Standard fullforwardshadows finalcolor:final</span></span><br></pre></td></tr></table></figure><p><strong>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">final</span><span class="params">(Input IN, SurfaceOutputStandard o, inout fixed4 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    color *= _FinalColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241108230534.png" alt="image-20241108230530783"></p><h2 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h2><p><strong>Properties中设置</strong></p><p>Range中的最小值取一个0.0001，一是为了作为被除数 的时候算式有效，二是让最小值尽可能大</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_RimPower(<span class="string">&quot;RimPower&quot;</span>,Range(<span class="number">0.0001</span>,<span class="number">8</span>)) = <span class="number">1</span> </span><br></pre></td></tr></table></figure><p><strong>Input结构体</strong></p><p>注意拼写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">    float2 uv_BumpMap; <span class="comment">//输入结构体uv贴图要注意的格式</span></span><br><span class="line">    float3 viewDir; <span class="comment">//因为需要用到视角坐标，这里需要添加，但是拼写必须和这个一样</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>属性定义</strong></p><p>给_RimPower一个float，配合Properties中的 0.0001</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed4 _RimColor;</span><br><span class="line"><span class="type">float</span> _RimPower;</span><br></pre></td></tr></table></figure><p><strong>Surf方法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half rim = <span class="number">1.0</span> - saturate(dot(normalize(IN.viewDir),o.Normal));</span><br><span class="line">o.Emission = _RimColor * <span class="built_in">pow</span>(rim,<span class="number">1</span>/_RimPower); <span class="comment">//使用的自发光通道</span></span><br></pre></td></tr></table></figure><h2 id="卡通效果"><a href="#卡通效果" class="headerlink" title="卡通效果"></a>卡通效果</h2><p><strong>Properties定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Step(<span class="string">&quot;Steps&quot;</span>,Range(<span class="number">1</span>,<span class="number">30</span>)) = <span class="number">5</span> </span><br><span class="line">_ToonEffect(<span class="string">&quot;ToonEffect&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>))  =<span class="number">0.5</span></span><br></pre></td></tr></table></figure><p><strong>重要的pragrma</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> surface surf Toon fullforwardshadows nolightmap finalcolor:final</span></span><br></pre></td></tr></table></figure><p><strong>自定义光照函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">half4 <span class="title function_">LightingToon</span> <span class="params">(SurfaceOutput s, half3 lightDir, half3 viewDir, half atten)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">float</span> diffuseLight = dot(lightDir,s.Normal) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">          diffuseLight = smoothstep(<span class="number">0</span>,<span class="number">1</span>,diffuseLight);</span><br><span class="line">          <span class="type">float</span> toon = <span class="built_in">floor</span>(diffuseLight * _Step) / _Step;</span><br><span class="line">          diffuseLight = lerp(diffuseLight,toon,_ToonEffect);</span><br><span class="line">          fixed3 diffuse = _LightColor0 * s.Albedo * diffuseLight;</span><br><span class="line">          <span class="keyword">return</span> half4(diffuse,<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h2><p><strong>Properties设置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_OutLine(<span class="string">&quot;OutLine&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">_OutLineColor(<span class="string">&quot;OutLineColor&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>Pass通道</strong></p><p>一整个直接在SurfaceSahder 的CGPROGRAM上面直接新开一个Pass通道就行</p><p>这里使用的是裁剪空间下的法线外拓</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">    LOD <span class="number">200</span></span><br><span class="line">    </span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">        Name <span class="string">&quot;OutLine&quot;</span></span><br><span class="line">        Cull Front</span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        fixed4 _OutLineColor;</span><br><span class="line">        <span class="type">float</span> _OutLine;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">v2f</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_base v)</span></span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            float3 normal = normalize(mul((float3x3)UNITY_MATRIX_IT_MV,v.normal));</span><br><span class="line">            float2 viewNormal = TransformViewToProjection(normal.xy);</span><br><span class="line">            o.pos.xy += viewNormal * _OutLine;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 <span class="title function_">frag</span><span class="params">(v2f i)</span>:SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _OutLineColor; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> surface surf Toon fullforwardshadows nolightmap finalcolor:final</span></span><br></pre></td></tr></table></figure><h2 id="XRay"><a href="#XRay" class="headerlink" title="XRay"></a>XRay</h2><p>在Properties中的设置很常规，是边缘光的翻版</p><p>在SurfaceShader中直接加入的Pass通道如下</p><p>注意深度测试和blend的参数设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Name <span class="string">&quot;XRay&quot;</span></span><br><span class="line">    Blend SrcAlpha One</span><br><span class="line">    ZWrite Off</span><br><span class="line">    ZTest Greater</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">    fixed4 _XRayColor;</span><br><span class="line">    <span class="type">float</span> _XRayPower;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        float4 pos : SV_POSITION;</span><br><span class="line">        float3 viewDir : TEXCOORD0;</span><br><span class="line">        float3 worldNormal : TEXCOORD1;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    v2f <span class="title function_">vert</span><span class="params">(appdata_base v)</span></span><br><span class="line">    &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">        o.viewDir = UnityWorldSpaceViewDir(v.vertex);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">    &#123;</span><br><span class="line">        float3 viewDir = normalize(i.viewDir);</span><br><span class="line">        float3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">        <span class="type">float</span> rim  = <span class="number">1.0</span> - saturate(dot(viewDir,worldNormal));</span><br><span class="line">        <span class="keyword">return</span> _XRayColor * <span class="built_in">pow</span>(rim,<span class="number">1</span>/_XRayPower);</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="熔岩流动"><a href="#熔岩流动" class="headerlink" title="熔岩流动"></a>熔岩流动</h2><p>基于uv实现完整的熔岩流动效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/1607&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Albedo (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Normal(<span class="string">&quot;Normal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">        _Mask(<span class="string">&quot;Mask&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _Fire(<span class="string">&quot;Fire&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _FirePower(<span class="string">&quot;FirePower&quot;</span>,Range(<span class="number">0</span>,<span class="number">200</span>)) = <span class="number">1</span></span><br><span class="line">        _FireSpeed(<span class="string">&quot;FireSpeed&quot;</span>,Vector) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        _FireLightChangeSpeed(<span class="string">&quot;FireChangeSpeed&quot;</span>,Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf StandardSpecular fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        sampler2D _Normal;</span><br><span class="line">        sampler2D _Mask;</span><br><span class="line">        sampler2D _Specular;</span><br><span class="line">        sampler2D _Fire;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        half _Smoothness;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line">        half2 _FireSpeed;</span><br><span class="line">        half _FirePower;</span><br><span class="line">        <span class="type">float</span> _FireLightChangeSpeed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">        <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutputStandardSpecular o)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">            o.Albedo = c.rgb;</span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Smoothness = _Smoothness;</span><br><span class="line">            o.Normal = UnpackNormal(tex2D(_Normal,IN.uv_MainTex));</span><br><span class="line">            <span class="comment">//现在使用的x的速度是最慢的，不过自己加上一个系数进行控制就没什么影响</span></span><br><span class="line">            float2 uvFlow = IN.uv_MainTex * _Time.x * _FireSpeed;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//遮罩颜色 和 火焰贴图颜色 和 变化强度</span></span><br><span class="line">            o.Emission = (tex2D(_Mask,IN.uv_MainTex) * tex2D(_Fire,uvFlow) * (_FirePower *(_SinTime.w + _FireLightChangeSpeed))).rgb;</span><br><span class="line">            o.Specular = tex2D(_Specular,IN.uv_MainTex).rgb;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="UnityShader%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%8CSurfaceShader.assets/image-20241109170052173.png" alt="image-20241109170052173" style="zoom:67%;" /><p>补充</p><p>遮罩可以控制区域的显示和不显示</p><p>遮罩的制作</p><p>1.将mask贴图的rgb通道都进行一个采样，然后和现有的贴图进行相乘，颜色一样就会变得更亮，黑色相乘就是0，最后不</p><p>2.将mask贴图的某一个通道进行单独的采样</p><h2 id="基于法线贴图扭曲UV"><a href="#基于法线贴图扭曲UV" class="headerlink" title="基于法线贴图扭曲UV"></a>基于法线贴图扭曲UV</h2><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/1608&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [HDR]_Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Albedo (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _DistortTex(<span class="string">&quot;DistortTex&quot;</span>,<span class="number">2</span>D)= <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">        _Speed(<span class="string">&quot;Speed&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">        _UVDisPower(<span class="string">&quot;UVDisPower&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _Glossiness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metallic&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        sampler2D _DistortTex;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        half _Glossiness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line">        half _Speed;</span><br><span class="line">        half _UVDisPower;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">        <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutputStandard o)</span></span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv1 = IN.uv_MainTex + _Time.x * _Speed * float2(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">            float2 uv2 = IN.uv_MainTex + _Time.x * _Speed * float2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//withScale结尾的函数可以对法线强度进行干预</span></span><br><span class="line">            float3 distort = UnpackNormalWithScale(tex2D(_DistortTex,IN.uv_MainTex),_UVDisPower);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对主贴图进行两个采样</span></span><br><span class="line">            float4 mainTex1 = tex2D(_MainTex,(float3(uv1,<span class="number">0</span>) + distort).xy);</span><br><span class="line">            float4 mainTex2 = tex2D(_MainTex,(float3(uv2,<span class="number">0</span>) + distort).xy);</span><br><span class="line">            float4 color = _Color * mainTex1 * mainTex2;</span><br><span class="line">            </span><br><span class="line">            o.Albedo = color;</span><br><span class="line">            o.Emission = color;</span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Glossiness;</span><br><span class="line">            o.Alpha = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241109173504.png" alt="image-20241109173459564" style="zoom:67%;" /><h2 id="glow效果"><a href="#glow效果" class="headerlink" title="glow效果"></a>glow效果</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/1609&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Albedo (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _MainMix(<span class="string">&quot;MainMix&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.3</span></span><br><span class="line">        _Normal(<span class="string">&quot;Normal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">        <span class="comment">//此贴图是常规贴图，a通道另有它用</span></span><br><span class="line">        _BurnNormal(<span class="string">&quot;BurnNormal&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _NormalTill(<span class="string">&quot;NormalTill&quot;</span>,Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">        _Glossiness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metallic&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></span><br><span class="line">        _Mask(<span class="string">&quot;Mask&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _BurnTill(<span class="string">&quot;BurnTill&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">        _BurnOffset(<span class="string">&quot;BurnOffset&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">        _BurnRange(<span class="string">&quot;BurnRange&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _BurnColor(<span class="string">&quot;BurnColor&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        _GlowColor(<span class="string">&quot;GlowColor&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _GlowPower(<span class="string">&quot;GlowPower&quot;</span>,Range(<span class="number">0</span>,<span class="number">2</span>)) = <span class="number">0.5</span></span><br><span class="line">        _GlowFrequency(<span class="string">&quot;GlowFrequency&quot;</span>,Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">0.4</span></span><br><span class="line">        _GlowOver(<span class="string">&quot;GlowOver&quot;</span>,Range(<span class="number">0</span>,<span class="number">2</span>)) = <span class="number">0.2</span></span><br><span class="line">        _Glow(<span class="string">&quot;Glow&quot;</span>,Range(<span class="number">0</span>,<span class="number">2</span>)) = <span class="number">0.2</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        half _Glossiness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        sampler2D _Normal;</span><br><span class="line">        sampler2D _BurnNormal;</span><br><span class="line">        sampler2D _Mask;</span><br><span class="line">        half _NormalTill;</span><br><span class="line">        half _BurnTill;</span><br><span class="line">        half _BurnOffset;</span><br><span class="line">        half _BurnRange;</span><br><span class="line">        fixed4 _BurnColor;</span><br><span class="line">        half _MainMix;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//glow相关</span></span><br><span class="line">        fixed4 _GlowColor;</span><br><span class="line">        half _GlowPower;</span><br><span class="line">        half _GlowFrequency;</span><br><span class="line">        half _GlowOver;</span><br><span class="line">        half _Glow;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">        <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutputStandard o)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这新添加的代码实际上就是将一个法线贴图通过mask和另一张法线贴图限制在一起</span></span><br><span class="line">            float3 normal1 = UnpackNormal(tex2D(_Normal,IN.uv_MainTex));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//直接对贴图进行法线采样，需要贴图本身的设置就是Normal map</span></span><br><span class="line">            <span class="comment">//没有设置的情况下是取用贴图的rg通道进行操作</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            fixed4 burnTex = tex2D(_BurnNormal,IN.uv_MainTex * _NormalTill);</span><br><span class="line">            fixed4 burnNormal = fixed4(<span class="number">1</span>,burnTex.g,<span class="number">0</span>,burnTex.r);</span><br><span class="line">            float3 normal2 = UnpackNormal(burnNormal);</span><br><span class="line">            float2 maskUV = IN.uv_MainTex * _BurnTill + _BurnOffset * float2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            fixed3 maskColor = tex2D(_Mask,maskUV);</span><br><span class="line">            <span class="type">float</span> maskR = _BurnRange + maskColor.r;</span><br><span class="line">            o.Normal= lerp(normal1,normal2,maskR);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">            fixed4 diffuse = lerp(c * _MainMix,_BurnColor,maskR);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在时间扰动中添加burnTex的a值作为变量，图片各个点d不同的情况下，发光点的观感随机</span></span><br><span class="line">            fixed4 glow = _GlowColor * _GlowPower * (<span class="number">0.5</span> * <span class="built_in">sin</span>(_Time.y * _GlowFrequency) + _GlowOver * burnTex.a);</span><br><span class="line">            <span class="comment">//burnTex.a和maskColor.r是两个遮罩</span></span><br><span class="line">            <span class="comment">//burn是控制燃烧的部分中需要发光的部分</span></span><br><span class="line">            <span class="comment">//maskColor是控制那些区域是燃烧的</span></span><br><span class="line">            o.Emission = glow * burnTex.a * maskColor.r * _Glow;</span><br><span class="line">            o.Albedo = diffuse.rgb;</span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Glossiness;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241111172557.png" alt="image-20241111125009922" style="zoom:67%;" /><h2 id="法线外扩变换"><a href="#法线外扩变换" class="headerlink" title="法线外扩变换"></a>法线外扩变换</h2><p>在SurfaceShader中加入对顶点的调整</p><p>唯一要特别注意的是在DX环境下对vert的初始化处理</p><p>最后的公式记忆就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vertFun</span> <span class="params">(inout appdata_full v, out Input o)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNITY_INITIALIZE_OUTPUT(Input, o);<span class="comment">//在DX环境下需要注意初始化</span></span><br><span class="line">    float3 normal = v.normal.xyz;</span><br><span class="line">    float3 vertexPos = v.vertex.xyz;</span><br><span class="line">    v.vertex.xyz += normal * max(<span class="built_in">sin</span>((vertexPos.y + _Time.x) * _ExtrusionFrency) / _ExtrusionSwing ,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单模糊"><a href="#简单模糊" class="headerlink" title="简单模糊"></a>简单模糊</h2><p>均值模糊，高斯模糊</p><p><strong>Properties额外定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//加上该控制标签，并且将Range的范围限定为0,1，最终的结果就是一个bool</span></span><br><span class="line">      [Toggle]_ToggleBulr(<span class="string">&quot;ToggleBulr&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">_BlurSize(<span class="string">&quot;Bulr Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">0.1</span>)) = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>surf函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">//多次采样并按照给定的比例进行相加，进行一个模糊处理</span></span><br><span class="line"> fixed4 c = tex2D (_MainTex, IN.uv_MainTex);</span><br><span class="line">fixed4 offset1 = tex2D (_MainTex, IN.uv_MainTex + float2(<span class="number">0</span>, _BlurSize));</span><br><span class="line">fixed4 offset2 = tex2D (_MainTex, IN.uv_MainTex + float2(_BlurSize, <span class="number">0</span>));</span><br><span class="line">fixed4 offset3 = tex2D (_MainTex, IN.uv_MainTex + float2(_BlurSize, _BlurSize));</span><br><span class="line">fixed4 offsetColor = c*<span class="number">0.4</span> + offset1*<span class="number">0.2</span> + offset2*<span class="number">0.2</span> + offset3*<span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//step函数的作用，第一个参数是0.5，第二个值大于0.5 Return 1，小于0,5，Return 0</span></span><br><span class="line">fixed4 color = lerp(c,offsetColor,step(<span class="number">0.5</span>,_ToggleBulr));</span><br><span class="line">    o.Albedo = color.rgb;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241111151448.png" alt="image-20241111151441855" style="zoom:50%;" /><h2 id="溶解效果"><a href="#溶解效果" class="headerlink" title="溶解效果"></a>溶解效果</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/1612&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Albedo (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">       _Normal(<span class="string">&quot;Normal&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">       _NormalScale(<span class="string">&quot;NormalScale&quot;</span>, Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">        _Glossiness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metallic&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></span><br><span class="line">       _DisolveTex(<span class="string">&quot;DisolveTex&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">       _Threshold(<span class="string">&quot;Threshold&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">       _EdgeLength(<span class="string">&quot;EdgeLength&quot;</span>, Range(<span class="number">0.0001</span>,<span class="number">0.2</span>)) = <span class="number">0.1</span></span><br><span class="line">       _BurnTex(<span class="string">&quot;BurnTex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">       _BurnInstensity(<span class="string">&quot;BurnInstensity&quot;</span>, Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">       sampler2D _Normal;</span><br><span class="line">       half _NormalScale;</span><br><span class="line">       sampler2D _DisolveTex;</span><br><span class="line">       half _Threshold;</span><br><span class="line">       sampler2D _BurnTex;</span><br><span class="line">       half _EdgeLength;</span><br><span class="line">       half _BurnInstensity;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">          float2 uv_Normal;</span><br><span class="line">          float2 uv_DisolveTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        half _Glossiness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">        <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutputStandard o)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//常规法线提取处理</span></span><br><span class="line">          o.Normal = UnpackScaleNormal(tex2D(_Normal, IN.uv_Normal),_NormalScale);</span><br><span class="line">            o.Albedo = c.rgb;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//标准不合适的进行裁剪</span></span><br><span class="line">          <span class="type">float</span> cutout = tex2D(_DisolveTex, IN.uv_DisolveTex).r;</span><br><span class="line">          clip(cutout - _Threshold);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//因为裁剪值小于0的已经能被舍弃，而给出的噪声图中的r值是连续变化的</span></span><br><span class="line">          <span class="comment">//所以temp的应该是从边缘开始到未裁剪中心逐渐变大</span></span><br><span class="line">            <span class="comment">//使用 除法 / 宽度是为了在Unity操作窗口中比较只直观的看到宽度变化</span></span><br><span class="line">            <span class="comment">//saturate在这里的作用是为了将大于1 的值给限制成1</span></span><br><span class="line">          <span class="type">float</span> temp = saturate((cutout - _Threshold) / _EdgeLength);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用向未裁剪中心逐步变大的temp作为燃烧图的uv</span></span><br><span class="line">            <span class="comment">//实际效果是从左下角到右上角进行颜色采样，表现出渐变的效果</span></span><br><span class="line">          fixed4 edgeColor = tex2D(_BurnTex,float2(temp,temp));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用lerp对燃烧颜色渐变处理，超过1就a通道设置为0</span></span><br><span class="line">          fixed4 finalColor = _BurnInstensity * lerp(edgeColor, fixed4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), temp);</span><br><span class="line">          o.Emission = finalColor;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Glossiness;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241111162621.png" alt="image-20241111162614375" style="zoom:67%;" /><h2 id="区域过度"><a href="#区域过度" class="headerlink" title="区域过度"></a>区域过度</h2><p><strong>Properties设置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_Dis(<span class="string">&quot;Dis&quot;</span>,Range(<span class="number">0.1</span>,<span class="number">10</span>)) = <span class="number">1</span></span><br><span class="line">_StartPoint(<span class="string">&quot;StratPoint&quot;</span>,Range(<span class="number">-10</span>,<span class="number">10</span>)) = <span class="number">1</span></span><br><span class="line">_Tex2(<span class="string">&quot;Tex2&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">_UnderInfluence(<span class="string">&quot;UnderInfluence&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>Surface函数</strong></p><p>唯一需要注意是startPoint的计算是从世界坐标原点开始的</p><p>clamp（a,b,c），将a限制在b和c之间</p><p>lerp就是渐变</p><p>&#x2F;Dis，还是为了在Unity操作窗中直观的看到渐变效果</p><p>在lerp中，dis设置的很小就会让temp的值很接近1，clampTemp&#x3D;1的话就会是C的颜色，因此dis越小，渐变越短</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutputStandard o)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line"><span class="type">float</span> temp =  saturate((IN.worldPos.y + _StartPoint)/_Dis);</span><br><span class="line">         fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line"><span class="type">float</span> clampTemp = clamp(temp, _UnderInfluence,<span class="number">1</span>);</span><br><span class="line">fixed4 color = lerp(tex2D(_Tex2,IN.uv_Tex2),c,clampTemp);</span><br><span class="line">         o.Albedo = color.rgb;</span><br><span class="line">         <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">         o.Metallic = _Metallic;</span><br><span class="line">         o.Smoothness = _Glossiness;</span><br><span class="line">         o.Alpha = c.a;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241111172126.png" alt="image-20241111172122698" style="zoom:67%;" /><h2 id="AlphaTEST"><a href="#AlphaTEST" class="headerlink" title="AlphaTEST"></a>AlphaTEST</h2><p><strong>Propertie中添加内容</strong></p><p>常规的透明度测试中用到的透明度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Cutoff(<span class="string">&quot;Cutoff&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br></pre></td></tr></table></figure><p><strong>subshader中内容</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">     Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    LOD <span class="number">200</span></span><br><span class="line">    Cull off <span class="comment">//关闭一面渲染</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">    <span class="comment">//启动alphatest并禁止接受阴影的，但是在alpha的前提下投射阴影</span></span><br><span class="line">    <span class="comment">//noshadow 禁止接受投影</span></span><br><span class="line">    <span class="comment">//addShadow 在透明度测试的前提下投射阴影</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> surface surf Standard alphatest:_Cutoff noshadow addshadow</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112103429.png" alt="image-20241111180116963" style="zoom:67%;" /><h2 id="AlphaBlend"><a href="#AlphaBlend" class="headerlink" title="AlphaBlend"></a>AlphaBlend</h2><p>Tags中的type和队列改变成为对应的就不用提了</p><p>背面也能看见就需要Cull Off</p><p>添加宏</p><p>最后还要将FallBack就取消掉，默认是Diffuse，会产生阴影</p><p>一般花花草草用的是透明度测试，粒子特效才用AlphaBlend</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span>&#125;</span><br><span class="line">    LOD <span class="number">200</span></span><br><span class="line">    Cull Off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="comment">//透明度混合宏，干掉阴影，加上混合，关闭接受阴影</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> surface surf Standard alpha:blend noshadow</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241111181332.png" alt="image-20241111181327631" style="zoom:67%;" /><h2 id="雪效果"><a href="#雪效果" class="headerlink" title="雪效果"></a>雪效果</h2><p>两种实现，使用模型的世界法线，使用法线贴图的世界法线</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241112102153.png" alt="image-20241112102147702" style="zoom:67%;" /><p>在这两个方法出出现的最重要方法是 WorldNormalVector，实际上该方法进行了下面的操作</p><p>求得法线的旋转矩阵，具体操作见<a href="https://mao1mao2mao3mao4.github.io/posts/4139c4a.html">Unity —— Shader入门，法线贴图 | mao的博客 (mao1mao2mao3mao4.github.io)</a>的4.3小节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);</span><br><span class="line">o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);</span><br><span class="line">o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);</span><br></pre></td></tr></table></figure><p>在surfshader中，虽然 Input结构体中可以自定义worldNormal，但是在实际使用中，只有在o.Normal没有被赋值的情况下才能正常使用，否则都需要在Input结构体的worldNormal下面添加以下定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   float2 uv_MainTex;</span><br><span class="line">   float2 uv_NormalTex;</span><br><span class="line">   float2 uv_SonwTex;</span><br><span class="line">   float2 uv_SnowNormal;</span><br><span class="line">   float3 worldNormal;</span><br><span class="line">   INTERNAL_DATA <span class="comment">//新加定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这里简单介绍两种用法</strong></p><ol><li>传递法线贴图中提取的法线并传入，返回该法线贴图的法线在世界空间下的法线</li><li>传递float3（0,0,1），因为法线渲染矩阵的组成，b通道就代表模型在世界坐标下的法线，因此返回模型在世界坐标下的法线</li></ol><p><strong>模型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/1617&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">       _Color(<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">       _MainTex(<span class="string">&quot;Albedo (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">       _SonwTex(<span class="string">&quot;SnowTex&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">       _NormalTex(<span class="string">&quot;Noraml&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">       _SnowNormal(<span class="string">&quot;SnowNoraml&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">       _SnowDir(<span class="string">&quot;SnowDir&quot;</span>,Vector) = (<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">       _SnowAmount(<span class="string">&quot;_SnowAmount&quot;</span>, Range(<span class="number">0</span>,<span class="number">2</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">       Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">       LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line">       CGPROGRAM</span><br><span class="line">       <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">       <span class="meta">#<span class="keyword">pragma</span> surface surf StandardSpecular fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">       <span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">       sampler2D _MainTex;</span><br><span class="line">       sampler2D _NormalTex;</span><br><span class="line">       sampler2D _SonwTex;</span><br><span class="line">       sampler2D _SnowNormal;</span><br><span class="line"></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">       &#123;</span></span><br><span class="line">          float2 uv_MainTex;</span><br><span class="line">          float2 uv_NormalTex;</span><br><span class="line">          float2 uv_SonwTex;</span><br><span class="line">          float2 uv_SnowNormal;</span><br><span class="line">          float3 worldNormal;</span><br><span class="line">          INTERNAL_DATA</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       half _Glossiness;</span><br><span class="line">       half _Metallic;</span><br><span class="line">       fixed4 _Color;</span><br><span class="line">       float4 _SnowDir;</span><br><span class="line">       half _SnowAmount;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">       <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">       <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">       UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">          <span class="comment">// put more per-instance properties here</span></span><br><span class="line">       UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">       <span class="type">void</span> <span class="title function_">surf</span><span class="params">(Input IN, inout SurfaceOutputStandardSpecular o)</span></span><br><span class="line">       &#123;</span><br><span class="line">          float3 normalTex = UnpackNormal(tex2D(_NormalTex, IN.uv_NormalTex));</span><br><span class="line">          float3 snowNorTex = UnpackNormal(tex2D(_SnowNormal, IN.uv_SnowNormal));</span><br><span class="line">          fixed3 wNormal = WorldNormalVector(IN, float3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">          fixed3 finalNormal = lerp(normalTex, snowNorTex, saturate(dot(wNormal, _SnowDir.xyz)) * _SnowAmount);</span><br><span class="line">          o.Normal = finalNormal;</span><br><span class="line"></span><br><span class="line">          fixed3 fWNormal = WorldNormalVector(IN, finalNormal);</span><br><span class="line">          <span class="type">float</span> lerpVal = saturate(dot(fWNormal, _SnowDir.xyz));</span><br><span class="line">          <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">          fixed4 c = lerp(tex2D(_MainTex, IN.uv_MainTex), tex2D(_SonwTex, IN.uv_SonwTex), lerpVal * _SnowAmount);</span><br><span class="line">          o.Albedo = c.rgb;</span><br><span class="line">          <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">          o.Alpha = c.a;</span><br><span class="line">       &#125;</span><br><span class="line">       ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>法线贴图</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/1616&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Albedo (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _SnowTex(<span class="string">&quot;SnowTex&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        _NormalTex(<span class="string">&quot;Normal&quot;</span>,<span class="number">2</span>D)= <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">        _SnowDir(<span class="string">&quot;SnowDir&quot;</span>,Vector) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _SnowAmount(<span class="string">&quot;SnowAmount&quot;</span>,Range(<span class="number">0</span>,<span class="number">2</span>)) = <span class="number">1</span></span><br><span class="line">        _Glossiness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metallic&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf StandardSpecular fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        sampler2D _NormalTex;</span><br><span class="line">        sampler2D _SnowTex;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">            float2 uv_NormalTex;</span><br><span class="line">            float2 uv_SnowTex;</span><br><span class="line">            float3 worldNormal;</span><br><span class="line">            INTERNAL_DATA</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        half _Glossiness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line">        float4 _SnowDir;</span><br><span class="line">        half _SnowAmount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">        <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutputStandardSpecular o)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将法线贴图中的向量提取出来并转换为世界坐标下</span></span><br><span class="line">            float3 normalTex = UnpackNormal(tex2D(_NormalTex,IN.uv_NormalTex));</span><br><span class="line">            o.Normal = normalTex;</span><br><span class="line">            <span class="comment">//真正的世界法线</span></span><br><span class="line">            fixed3 wNormal = WorldNormalVector(IN,normalTex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//法线贴图的法线和雪方向的点乘</span></span><br><span class="line">            <span class="type">float</span> lerpVal = saturate(dot(wNormal,_SnowDir.xyz));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = lerp( tex2D(_MainTex, IN.uv_MainTex),tex2D(_SnowTex,IN.uv_SnowTex),lerpVal * _SnowAmount) * _Color;</span><br><span class="line">            o.Albedo = c.rgb;</span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Specular = _Metallic;</span><br><span class="line">            o.Smoothness = _Glossiness;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>Surface的可操作性并不是很强</p><p>虽然给出了很多操作符号，还是建议用Pass通道搭配Surface使用，两个Surface使用效率不高</p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader——中级</title>
      <link href="/posts/53323d01.html"/>
      <url>/posts/53323d01.html</url>
      
        <content type="html"><![CDATA[<h1 id="UnityShader中级"><a href="#UnityShader中级" class="headerlink" title="UnityShader中级"></a>UnityShader中级</h1><h1 id="复杂光照"><a href="#复杂光照" class="headerlink" title="复杂光照"></a>复杂光照</h1><p>Unity 渲染路径:Forward  Deferred  Legacy Vertex Lit   Legacy Deferred</p><table><thead><tr><th><strong>标签名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Always</td><td>不管使用哪种渲染路径，该pass总会被渲染，但不会计算任何光照</td></tr><tr><td>ForwardBase</td><td>用于<strong>前向渲染</strong>。该pass会计算环境光，最重要的平行光，逐顶点&#x2F;SH光源和Lightmaps</td></tr><tr><td>ForwardAdd</td><td>用于<strong>前向渲染</strong>。该pass会计算额外的逐像素光源，每个pass对应一个光源。</td></tr><tr><td>Deferred</td><td>用于<strong>延迟渲染</strong>。该pass会渲染G缓冲（G-buffer）</td></tr><tr><td>ShadowCaster</td><td>把物体的深度信息渲染到阴影映射纹理或一张深度纹理中</td></tr><tr><td>PrepassBase</td><td>用于<strong>遗留的延迟渲染</strong>。该pass会渲染法线和高光反射的指数部分。</td></tr><tr><td>PrepassFinal</td><td>用于<strong>遗留的延迟渲染</strong>。该pass会通过合并纹理，光照和自发光来渲染得到最后颜色</td></tr><tr><td>Vertex, VertexLMRGBM和VertexLM</td><td>用于<strong>遗留的顶点照明渲染</strong></td></tr></tbody></table><h2 id="在Shader对光照渲染模式进行设置"><a href="#在Shader对光照渲染模式进行设置" class="headerlink" title="在Shader对光照渲染模式进行设置"></a>在Shader对光照渲染模式进行设置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Shader指定光照渲染模式</span></span><br><span class="line">Tags&#123;<span class="string">&quot;LightMode&quot;</span>= <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>注意：用空格进行不同标签的分割</p><p>ForwardBase向下兼容Deferred，但是不支持阴影</p><p>不同标签互不兼容</p><h1 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h1><p>Unity 前向渲染：逐顶点，逐像素处理，球谐函数。</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241104160536.png" alt="image-20241104160530282" style="zoom:80%;" /><h2 id="两种光源的区分"><a href="#两种光源的区分" class="headerlink" title="两种光源的区分"></a>两种光源的区分</h2><ul><li>逐像素光源，光照更细腻，对性能要求更高，会对Shader的计算产生影响</li></ul><p></p><p>就像是在顶点着色器中计算颜色一样，锯齿状的边缘会非常明显</p><p>多个平行光，挑一个最重要的来进行计算，如果剩下的平行光数量满足在 质量 中 对逐像素 光源数量的限制，并且在光源的RenderMode中设置的是Auto，那么剩下的平行就会自动成为 逐像素光源，然后放到ForwardAdd里面去计算，超过限制就成为逐顶点光源</p><ul><li>逐像素光源：</li><li>1，当光源设置为Import时，是逐像素光源。（不受限制与质量设置里面pixel light count ）（Forward Add）</li><li>2，光源为auto时，个数在pixel light count 以内的光源都是逐像素光源。（Forward Add）</li><li>3，光源为auto时，个数超过pixel light count ，那么按光源对物体影响重要程度排序后，前pixel light count个数的光源为逐像素光源。（Forward Add）</li><li>4，最重要的平行光为逐像素光源。（Forward Base）</li><li></li><li>逐顶点光源：（unity默认要求逐顶点光源不超过4个，超过的按SH光源处理，也就是球协函数）</li><li>1，当光源设置为NotImport时，是逐顶点光源。（Forward Base）</li><li>2，超过pixel light count 的光源为逐顶点光源。（Forward Base）</li></ul><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241104162629.png" alt="image-20241104162623187" style="zoom:67%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241104162532.png" alt="image-20241104162522370" style="zoom:80%;" /><h2 id="逐顶点光源计算"><a href="#逐顶点光源计算" class="headerlink" title="逐顶点光源计算"></a>逐顶点光源计算</h2><p>逐顶点光源计算中函数用到的参数可以在下载到的对应shader文件 UnityShaderVariables.cginc 中查找到</p><p>单纯在一个没有FallBack，仅仅实现了一个ForWardBase的Shader中进行计算，只会有一次DrawCall</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LIGHTMAP_OFF</span></span><br><span class="line">                <span class="comment">//球协函数计算</span></span><br><span class="line">                float3 shLight = ShadeSH9(float4(v.normal,<span class="number">1.0</span>));</span><br><span class="line">                o.vertexLight = shLight;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VERTEXLIGHT_ON</span></span><br><span class="line">                <span class="comment">//逐顶点光源计算</span></span><br><span class="line">                <span class="comment">//光源设定，unity_LightColor0/1/2/3</span></span><br><span class="line">                float3 vertexLight = Shade4PointLights(unity_4LightPosX0,unity_4LightPosY0,unity_4LightPosZ0,</span><br><span class="line"></span><br><span class="line">                                       unity_LightColor0.rgb,unity_LightColor1.rgb,unity_LightColor2.rgb,unity_LightColor3.rgb, </span><br><span class="line">                                                       unity_4LightAtten0,</span><br><span class="line">                                                       o.worldNormal,o.worldNormal);</span><br><span class="line">                o.vertexLight += vertexLight;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>每次Pass通道运行的时候回默认获取当前光照的颜色</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_LightColor0.rgb</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/11&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse(<span class="string">&quot;Diffuse&quot;</span>,Color) =(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>,Range(<span class="number">8.0</span>,<span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc&quot;</span></span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 worldNormal :TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float3 vertexLight : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">             float4 _Diffuse;</span><br><span class="line">            float4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;   </span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata_base v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LIGHTMAP_OFF</span></span><br><span class="line">                <span class="comment">//球协函数计算</span></span><br><span class="line">                float3 shLight = ShadeSH9(float4(v.normal,<span class="number">1.0</span>));</span><br><span class="line">                o.vertexLight = shLight;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VERTEXLIGHT_ON</span></span><br><span class="line">                <span class="comment">//逐顶点光源计算</span></span><br><span class="line">                float3 vertexLight = Shade4PointLights(unity_4LightPosX0,unity_4LightPosY0,unity_4LightPosZ0,</span><br><span class="line">                                                       unity_LightColor0.rgb,unity_LightColor1.rgb,unity_LightColor2.rgb,unity_LightColor3.rgb,</span><br><span class="line">                                                       unity_4LightAtten0,</span><br><span class="line">                                                       o.worldNormal,o.worldNormal);</span><br><span class="line">                o.vertexLight += vertexLight;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float3 environmentLightColor = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">//世界法线标准化</span></span><br><span class="line">                <span class="comment">//视角方向计算</span></span><br><span class="line">                <span class="comment">//光线方向计算</span></span><br><span class="line">                float3 normal = normalize(i.worldNormal);</span><br><span class="line">                float3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                float3 lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//满发射光线计算</span></span><br><span class="line">                float3 diffuseColor = _LightColor0.rgb * _Diffuse.rgb * (dot(lightDir,normal) * <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//高光反射计算</span></span><br><span class="line">                float3 halfView = normalize(lightDir + viewDir);</span><br><span class="line">                float3 specularColor = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>,dot(normal,halfView)),_Gloss); <span class="comment">//高光反射还需要继续计算</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//可以将高光颜色和漫反射颜色乘上一个衰减系数</span></span><br><span class="line">                <span class="comment">//不过平行光不会衰减</span></span><br><span class="line">                <span class="comment">//也可以在后面加上逐顶点着色的颜色</span></span><br><span class="line">                float3 resColor = environmentLightColor + (specularColor + diffuseColor) + i.vertexLight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> float4(resColor,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">           Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Blend One One</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span>  multi_compile_fwdadd</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//包含光照衰减的方法</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span> </span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">struct</span> v2f </span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 worldNormal :TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                LIGHTING_COORDS(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">//使用 TEXCOORD2 和 3的衰减光，两个参数值，一个衰减，一个阴影</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">             float4 _Diffuse;</span><br><span class="line">            float4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;   </span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata_base v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//光照衰减</span></span><br><span class="line">                TRANSFER_VERTEX_TO_FRAGMENT(o);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float3 environmentLightColor = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">//世界法线标准化</span></span><br><span class="line">                <span class="comment">//视角方向计算</span></span><br><span class="line">                <span class="comment">//光线方向计算</span></span><br><span class="line">                float3 normal = normalize(i.worldNormal);</span><br><span class="line">                float3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                float3 lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//满发射光线计算</span></span><br><span class="line">                float3 diffuseColor = _LightColor0.rgb * _Diffuse.rgb * (dot(lightDir,normal) * <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//高光反射计算</span></span><br><span class="line">                float3 halfView = normalize(lightDir + viewDir);</span><br><span class="line">                float3 specularColor = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>,dot(normal,halfView)),_Gloss); <span class="comment">//高光反射还需要继续计算</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//衰减</span></span><br><span class="line">                <span class="type">float</span> atten = LIGHT_ATTENUATION(i);</span><br><span class="line">                <span class="comment">//可以将高光颜色和漫反射颜色乘上一个衰减系数</span></span><br><span class="line">                <span class="comment">//不过平行光不会衰减</span></span><br><span class="line">                <span class="comment">//也可以在后面加上逐顶点着色的颜色</span></span><br><span class="line">                float3 resColor = environmentLightColor + (specularColor + diffuseColor) * atten;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> float4(resColor,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">            </span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前向渲染补充"><a href="#前向渲染补充" class="headerlink" title="前向渲染补充"></a>前向渲染补充</h2><ul><li>1，ForwardAdd这个Pass需要和ForwardBase一起使用，否则会被Unity忽略掉（unity5.x）,在新版本中，不会忽略，但是渲染会出错。</li><li>2，在Forward和Deferred渲染路径下，Forward的Pass均能被正常渲染。</li><li>3，ForwardAdd对每一个逐像素光源都会执行一次Pass，所以不要在ForwardAdd里面计算 unity_4LightPos[x,y,z]0中的数据。会重复计算。</li></ul><p>在Frame Debugger，中的其他光源排序，按照光源的强度，大小和距离进行排序</p><h1 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h1><h2 id="延迟渲染原理："><a href="#延迟渲染原理：" class="headerlink" title="延迟渲染原理："></a>延迟渲染原理：</h2><p>延迟渲染主要包含了两个Pass。在第一个Pass中，我们不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要是通过深度缓冲技术来实现，当发现一个片元是可见的，我们就把它的相关信息存储到G缓冲区中。然后，在第二个Pass中，我们利用G缓冲区的各个片元信息，例如表面法线、视角方向、漫发射系数等，进行真正的光照计算。</p><h2 id="延迟渲染缺点："><a href="#延迟渲染缺点：" class="headerlink" title="延迟渲染缺点："></a>延迟渲染缺点：</h2><p>1，不支持真正的抗锯齿功能。</p><p>2，不能处理半透明物体。</p><p>3，对显卡有一定要求。如果要使用延迟渲染的话，显卡必须支持MRT、Shader Mode 3.0及以上、深度渲染纹理以及双面的模板缓冲。</p><h2 id="延迟渲染优点："><a href="#延迟渲染优点：" class="headerlink" title="延迟渲染优点："></a>延迟渲染优点：</h2><p>1，所有光都是逐像素光源。计算复杂度前向渲染 O（m*n）,延迟渲染O（m+n）。</p><p>2，制作后处理等，可直接获取深度值。</p><p>1）第一个Pass用于渲染G缓冲。在这个Pass中，我们会把物体的漫反射颜色、高光发射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的G缓冲区中。对于每个物体来说，这个Pass仅会执行一次。</p><p>2)第二个Pass用于计算真正的光照模型。这个Pass会使用上一个Pass中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。</p><h2 id="G缓冲"><a href="#G缓冲" class="headerlink" title="G缓冲"></a>G缓冲</h2><p>默认的G缓冲区（注意，不同Unity版本的渲染纹理存储内容会有所不同）包含了以下几个渲染纹理（Render Texture，RT）。</p><p>RT0：格式是ARGB32（每个通道8位），RGB通道用于存储漫反射颜色，A通道储存遮挡。</p><p>RT1：格式是ARGB32（每个通道8位），RGB通道用于存储高光反射颜色，A通道同于用于存储高光反射的指数部分。</p><p>RT2：格式是ARGB2101010，RGB通道用于存储世界空间法线，A通道没有被使用。</p><p>RT3：格式是ARGB2101010&#x2F;ARGBHalf（每个通道16位），(低动态光照渲染&#x2F;高动态光照渲染)用于存储自发光+lightmap+反射探针深度缓冲和模板缓冲。</p><p>当在第二个Pass中计算光照时，默认情况下仅可以使用Unity内置的Standard 光照模型。</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241105103530.png" alt="image-20241105103522669" style="zoom: 50%;" /><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="第一个Pass"><a href="#第一个Pass" class="headerlink" title="第一个Pass"></a>第一个Pass</h3><p>在没有自定义Deferred第二个Pass的情况下，片元着色器frag中输出的每个元素都要按照给定的顺序，漫反射光，高光，法线，深度缓冲</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高光反射，系数</span></span><br><span class="line">_Gloss(<span class="string">&quot;Gloss&quot;</span>,Range(<span class="number">8.0</span>,<span class="number">256</span>)) = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟渲染输出结构体</span></span><br><span class="line">            <span class="keyword">struct</span> DeferredOutData</span><br><span class="line">            &#123;</span><br><span class="line">               float4 gBuffer0 : SV_TARGET0;</span><br><span class="line">               float4 gBuffer1 : SV_TARGET1;</span><br><span class="line">               float4 gBuffer2 : SV_TARGET2;</span><br><span class="line">               float4 gBuffer3 : SV_TARGET3;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            </span><br><span class="line">            float4 _Diffuse;</span><br><span class="line">            float4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata_base v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DeferredOutData <span class="title function_">frag</span> <span class="params">(v2f i)</span></span><br><span class="line">            &#123;</span><br><span class="line">                DeferredOutData d;</span><br><span class="line">                float3 color = tex2D(_MainTex,i.uv).rgb * _Diffuse.rgb;</span><br><span class="line">                <span class="comment">//漫反射颜色</span></span><br><span class="line">                d.gBuffer0.rgb = color;</span><br><span class="line">                d.gBuffer0.a =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//高光反射，a通道存储高光反射的幂</span></span><br><span class="line">                d.gBuffer1.rgb = _Specular.rgb;</span><br><span class="line">                d.gBuffer1.a = _Gloss /<span class="number">256</span>; <span class="comment">//a通取值范围的问题，要卡在0到1之间，除的数要和该数在Properties中的最大值相同</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//法线</span></span><br><span class="line">                d.gBuffer2 = float4(i.normal *<span class="number">0.5</span> + <span class="number">0.5</span>); <span class="comment">//同样是a通道的取值范围问题</span></span><br><span class="line">                d.gBuffer3 = float4(color,<span class="number">1</span>); <span class="comment">//存储模板缓冲，也就是计算出来的颜色值</span></span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="在相机中出现需要进行的设置"><a href="#在相机中出现需要进行的设置" class="headerlink" title="在相机中出现需要进行的设置"></a>在相机中出现需要进行的设置</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241105111446.png" alt="image-20241105111442328"></p><h3 id="屏幕后处理（第二个Pass）"><a href="#屏幕后处理（第二个Pass）" class="headerlink" title="屏幕后处理（第二个Pass）"></a>屏幕后处理（第二个Pass）</h3><p>就是延迟渲染的第二Pass，不需要进行深度写入</p><p>方法</p><p>将给定的裁剪空间坐标转换为屏幕空间坐标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> float4 <span class="title function_">ComputeScreenPos</span><span class="params">(float4 pos)</span> &#123;</span><br><span class="line">    float4 o = ComputeNonStereoScreenPos(pos);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(UNITY_SINGLE_PASS_STEREO)</span></span><br><span class="line">    o.xy = TransformStereoScreenSpaceTex(o.xy, pos.w);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在顶点着色器中使用，结果还不一个完整的屏幕空间坐标，需要后续在片元着色器中用xy分量除以zw分量（齐次除法）</p><p>投影空间不是线性的，插值是线性的</p><p>这个方法按照习惯会在顶点着色器中被调用，如果方法帮我们进行齐次除法，最后插值的结果就不会很准确，因此需要我们手动去片元着色器中操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.uv = ComputeScreenPos(o.vertex);</span><br></pre></td></tr></table></figure><p>这一步之后还有很多操作需要被进行，这个时候拿到的uv是在屏幕空间的像素，延迟渲染的屏幕后处理进行的打光操作，打光操作需要在世界空间进行，因此需要把uv转换到齐次裁剪空间，再从齐次裁剪空间到世界空间</p><p>在第一次使用过程中，引入头文件的过程缺少一个 “ 结尾的标点符号，导致两个识别不出来两个Pass</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityDeferredLibrary.cginc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityGBuffer.cginc</span></span></span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/12-Deferred&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//最开始放错了地方，</span></span><br><span class="line">        <span class="comment">//有外面的内部的就无效</span></span><br><span class="line">        <span class="comment">//没外面的里面就近</span></span><br><span class="line"><span class="comment">//ZWrite Off</span></span><br><span class="line">         <span class="comment">//LDR 地动态  HDR 高动态</span></span><br><span class="line"><span class="comment">//LDR Blend DstColor Zero    HDR : Blend One One</span></span><br><span class="line"><span class="comment">//Blend one one</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">            ZWrite Off</span><br><span class="line">   <span class="comment">//LDR 地动态  HDR 高动态</span></span><br><span class="line">   <span class="comment">//LDR Blend DstColor Zero    HDR : Blend One One</span></span><br><span class="line">   Blend [_SrcBlend] [_DstBlend]</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_lightpass</span></span><br><span class="line"><span class="comment">//代表排除不支持MRT的硬件</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> exclude_renderers nomrt</span></span><br><span class="line"><span class="comment">//#pragma multi_compile __ UNITY_HDR_ON</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityDeferredLibrary.cginc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityGBuffer.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">sampler2D _CameraGBufferTexture0;</span><br><span class="line">sampler2D _CameraGBufferTexture1;</span><br><span class="line">sampler2D _CameraGBufferTexture2;</span><br><span class="line">sampler2D _CameraGBufferTexture3;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float3 normal :NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unity_v2f_deferred <span class="title function_">vert</span> <span class="params">(a2v i)</span></span><br><span class="line">&#123;</span><br><span class="line">unity_v2f_deferred o;</span><br><span class="line"> o.pos = UnityObjectToClipPos(i.vertex);</span><br><span class="line">o.uv = ComputeScreenPos(o.pos);</span><br><span class="line">o.ray = UnityObjectToViewPos(i.vertex);</span><br><span class="line"><span class="comment">//_LightAsQuad  当在处理四边形时，也就是直射光时返回1，否则返回0</span></span><br><span class="line">o.ray = lerp(o.ray, i.normal, _LightAsQuad);</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">frag</span> <span class="params">(unity_v2f_deferred i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//不去自己进行手动计算</span></span><br><span class="line"><span class="comment">//需要使用UnityDeferredLibrary.cgnic包中的一个结构体 unity_v2f_deferred</span></span><br><span class="line"><span class="comment">//float3 worldPos;</span></span><br><span class="line"><span class="comment">//float2 uv; </span></span><br><span class="line"><span class="comment">//half3 lightDir;</span></span><br><span class="line"><span class="comment">//float atten;</span></span><br><span class="line"><span class="comment">//float fadeDist;</span></span><br><span class="line"><span class="comment">//UnityDeferredCalculateLightParams(i,worldPos,uv,lightDir,atten,fadeDist);</span></span><br><span class="line"></span><br><span class="line">float2 uv = i.uv.xy / i.uv.w;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过深度和方向重新构建世界坐标</span></span><br><span class="line"><span class="type">float</span> depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,uv);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将取得的深度值变化到线性的区间内</span></span><br><span class="line">depth = Linear01Depth(depth);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ray只能表示方向，长度不一定，_ProjectionParams.z表示远平面</span></span><br><span class="line"><span class="comment">//括号内计算出来的就是rayToFarP和ray向量的比例</span></span><br><span class="line">float3 rayToFarPlane = i.ray * (_ProjectionParams.z / i.ray.z);</span><br><span class="line">float4 viewPos = float4(rayToFarPlane * depth,<span class="number">1</span>);</span><br><span class="line">float3 worldPos = mul(unity_CameraToWorld,viewPos).xyz;</span><br><span class="line"><span class="comment">//从这到上的整个过程是拿到一个存储在屏幕空间的图，然后转换到世界坐标下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//阴影消失的地方</span></span><br><span class="line"><span class="type">float</span> fadeDist = UnityComputeShadowFadeDistance(worldPos,viewPos.z);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//对不同光进行衰减计算，包括阴影计算</span></span><br><span class="line"><span class="comment">//从上到下依次是，区域光，方向光，点光</span></span><br><span class="line"><span class="comment">//虽然spot区域光没有cookie的定义，但是在计算的时候还是要加入的</span></span><br><span class="line"><span class="comment">//2019版</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SPOT)</span></span><br><span class="line">float3 toLight = _LightPos.xyz - worldPos;</span><br><span class="line">half3 lightDir = normalize(toLight);</span><br><span class="line"></span><br><span class="line">float4 uvCookie = mul(unity_WorldToLight,float4(worldPos,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//阴影的实时衰减计算消耗大，一般都是存储在_LightTexture0中，如果使用了cookie，就会存储在_LightTextureB0中</span></span><br><span class="line"><span class="type">float</span> atten = tex2Dbias(_LightTexture0,float4(uvCookie.xy / uvCookie.w,<span class="number">0</span>,<span class="number">-8</span>)).w;</span><br><span class="line"></span><br><span class="line">atten *= uvCookie.w &lt; <span class="number">0</span>;</span><br><span class="line">atten *= tex2D(_LightTextureB0,dot(toLight,toLight) * _LightPos.w).r;</span><br><span class="line"></span><br><span class="line">atten *= UnityDeferredComputeShadow(worldPos,fadeDist,uv);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(DIRECTIONAL) || defined(DIRECTIONAL_COOKIE)</span></span><br><span class="line">half3 lightDir = -_LightDir.xyz; <span class="comment">//关键性位置</span></span><br><span class="line"><span class="type">float</span> atten = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">atten *= UnityDeferredComputeShadow(worldPos,fadeDist,uv);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(DIRECTIONAL_COOKIE)</span></span><br><span class="line">float4 uvCookie = mul(unity_WorldToLight,float4(worldPos,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//方向光不透视，因此不需要进行齐次裁剪</span></span><br><span class="line">atten *= tex2Dbias(_LightTexture0,float4(uvCookie.xy,<span class="number">0</span>,<span class="number">-8</span>)).w;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(POINT) || defined(POINT_COOKIE)</span></span><br><span class="line">float3 toLight = _LightPos.xyz - worldPos;</span><br><span class="line">half3 lightDir = normalize(toLight);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> atten = tex2D(_LightTextureB0,dot(toLight,toLight) * _LightPos.w).r;</span><br><span class="line">atten *= UnityDeferredComputeShadow(worldPos,fadeDist,uv);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(POINT_COOKIE)</span></span><br><span class="line">float4 uvCookie = mul(unity_WorldToLight,float4(worldPos,<span class="number">1</span>));</span><br><span class="line">atten *= texCUBEbias(_LightTexture0,float4(uvCookie.xyz,<span class="number">-8</span>)).w;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">half3 lightDir = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> atten = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">half3 lightColor = _LightColor.rgb * atten;</span><br><span class="line"></span><br><span class="line">half4 gbuffer0 = tex2D(_CameraGBufferTexture0, uv);</span><br><span class="line">half4 gbuffer1 = tex2D(_CameraGBufferTexture1, uv);</span><br><span class="line">half4 gbuffer2 = tex2D(_CameraGBufferTexture2, uv);</span><br><span class="line"></span><br><span class="line">half3 diffuseColor = gbuffer0.rgb;</span><br><span class="line">half3 specularColor = gbuffer1.rgb;</span><br><span class="line"><span class="type">float</span> gloss = gbuffer1.a * <span class="number">256</span>;</span><br><span class="line">float3 worldNormal = normalize(gbuffer2.xyz * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">float3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">float3 halfView = normalize(viewDir + lightDir);</span><br><span class="line"></span><br><span class="line">half3 diffuse = lightColor * diffuseColor * (dot(worldNormal,lightDir) * <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br><span class="line">half3 specular = lightColor * specularColor * <span class="built_in">pow</span>(max(<span class="number">0</span>,dot(worldNormal,halfView)),gloss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> float4(diffuse + specular,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//转码pass，主要是对于LDR转码</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">   ZTest Always</span><br><span class="line">   Cull Off</span><br><span class="line">   Zwrite Off</span><br><span class="line">   Stencil</span><br><span class="line">   &#123;</span><br><span class="line">   ref[_stencilNonBackground]</span><br><span class="line">   readMask[_StencilNonBackground]</span><br><span class="line">   compback equal</span><br><span class="line">   compfront equal</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   CGPROGRAM</span><br><span class="line"></span><br><span class="line">   <span class="comment">//要求Shader版本子在3.0以上</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排除不支持MRT的硬件</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> exclude_renderers nomrt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">sampler2D _LightBuffer;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">   float4 vertex : SV_POSITION;</span><br><span class="line">   float2 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f <span class="title function_">vert</span><span class="params">(float4 vertex : POSITION,float2 texcoord : TEXCOORD0)</span></span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.vertex = UnityObjectToClipPos(vertex);</span><br><span class="line">o.texcoord.xy = texcoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某个不知名平台的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNITY_SINGLE_PASS_STEREO</span></span><br><span class="line">o.texcoord = TransformStereoScreenSpaceTex(o.texcoord, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">frag</span><span class="params">(v2f i)</span>:SV_Target</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//针对某个解码？</span></span><br><span class="line"><span class="comment">//猜测可能高动态和低动态的差别</span></span><br><span class="line"><span class="keyword">return</span> -log2(tex2D(_LightBuffer,i.texcoord));</span><br><span class="line">&#125;</span><br><span class="line">  ENDCG</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241105200203.png" alt="image-20241105200158797"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//不去自己进行手动计算</span></span><br><span class="line"><span class="comment">//需要使用UnityDeferredLibrary.cgnic包中的一个结构体 unity_v2f_deferred</span></span><br><span class="line">float3 worldPos;</span><br><span class="line">float2 uv; </span><br><span class="line">half3 lightDir;</span><br><span class="line"><span class="type">float</span> atten;</span><br><span class="line"><span class="type">float</span> fadeDist;</span><br><span class="line">UnityDeferredCalculateLightParams(i,worldPos,uv,lightDir,atten,fadeDist);</span><br></pre></td></tr></table></figure><p>这样的操作需要的前置cginc头文件是 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityDeferredLibrary.cginc&quot;</span></span></span><br></pre></td></tr></table></figure><h1 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h1><h2 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h2><p>通常在屏幕后处理和UI的Shader中用的比较多</p><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>如果一个Shader本身有自己的深度需求和透明需求，这个时候还要控制某些东西渲染，某些东西不渲染，或者在某个区域渲染，在某个区域不渲染，这样的一个功能需求的时候，就会用到模板测试</p><p>说白了还是根据给出的条件来判断某个片元是否应该抛弃</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Stencil-（模板测试-蒙版测试）"><a href="#Stencil-（模板测试-蒙版测试）" class="headerlink" title="Stencil （模板测试&#x2F;蒙版测试）:"></a>Stencil （模板测试&#x2F;蒙版测试）:</h3><p>与深度测试，透明度测试类似，决定一个片元是否被扔掉。深度测试的比较数据在深度缓冲中，透明度测试的比较对象是颜色缓冲中的值，而模版测试的比较数据在Stencil中，并且模板测试要先于深度测试与透明度测试，在fragment函数之前就会执行模板测试。</p><p>Ref 就是参考值，当参数允许赋值时，会把参考值赋给当前像素</p><p>ReadMask 对当前参考值和已有值进行mask操作，默认值255，一般不用</p><p>WriteMask 写入Mask操作，默认值255，一般不用</p><p>Comp 比较方法。是拿Ref参考值和当前像素缓存上的值进行比较。默认值Always</p><p>Pass 当模版测试和深度测试都通过时，进行处理</p><p>Fail 当模版测试和深度测试都失败时，进行处理</p><p>ZFail 当模版测试通过而深度测试失败时，进行处理</p><h3 id="Comp-："><a href="#Comp-：" class="headerlink" title="Comp ："></a>Comp ：</h3><ol><li>Always</li><li>Greater - 大于</li><li>GEqual - 大于等于</li><li>Less - 小于</li><li>LEqual - 小于等于</li><li>Equal - 等于</li><li>NotEqual - 不等于</li><li>Always - 永远通过</li><li>Never - 永远通不过</li></ol><h3 id="pass，Fail，ZFail："><a href="#pass，Fail，ZFail：" class="headerlink" title="pass，Fail，ZFail："></a>pass，Fail，ZFail：</h3><ol><li>Keep 保持(即不把参考值赋上去，直接不管)</li><li>Zero 归零</li><li>Replace 替换(拿参考值替代原有值)</li><li>IncrSat 值增加1，但不溢出，如果到255，就不再加</li><li>DecrSat 值减少1，但不溢出，值到0就不再减</li><li>Invert 反转所有位，如果1就会变成254</li><li>IncrWrap 值增加1，会溢出，所以255变成0</li><li>DecrWrap 值减少1，会溢出，所以0变成255</li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>写在Pass里面的不能被Unity识别，至少在设置窗口没显示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;<span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry-1999&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="根据摄像机对物体的渲染顺序进行模板缓冲写入"><a href="#根据摄像机对物体的渲染顺序进行模板缓冲写入" class="headerlink" title="根据摄像机对物体的渲染顺序进行模板缓冲写入"></a>根据摄像机对物体的渲染顺序进行模板缓冲写入</h3><p>根据自定义的 参考值 _Stencil_Ref,以及配合一下代码，实现反深度测试的效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZTest Off</span><br><span class="line">            Stencil</span><br><span class="line">            &#123;</span><br><span class="line">                Ref[_Stencil_Ref]</span><br><span class="line"> </span><br><span class="line">                Comp GEqual <span class="comment">//大于等于</span></span><br><span class="line">                Pass Replace <span class="comment">//替换原有值 ，初始值为0，替换掉的是上一个参考值</span></span><br><span class="line">              </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>一个材质和Shader可以确定唯一的表现效果</p><p>可以使用多个材质配合一个Shader来实现Shader复用</p><h3 id="根据渲染顺序来进行模板缓冲写入"><a href="#根据渲染顺序来进行模板缓冲写入" class="headerlink" title="根据渲染顺序来进行模板缓冲写入"></a>根据渲染顺序来进行模板缓冲写入</h3><h4 id="充当背景的物体设置"><a href="#充当背景的物体设置" class="headerlink" title="充当背景的物体设置"></a>充当背景的物体设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _refVal(<span class="string">&quot;refVal&quot;</span>,<span class="type">int</span>) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Stencil</span><br><span class="line">            &#123;</span><br><span class="line">                Ref[_refVal]</span><br><span class="line">              </span><br><span class="line">                Pass Replace</span><br><span class="line">                Fail Replace</span><br><span class="line">                ZFail Replace</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="需要穿透的物体设置"><a href="#需要穿透的物体设置" class="headerlink" title="需要穿透的物体设置"></a>需要穿透的物体设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _refVal(<span class="string">&quot;refVal&quot;</span>,<span class="type">int</span>) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry+2&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Stencil</span><br><span class="line">            &#123;</span><br><span class="line">                Ref[_refVal]</span><br><span class="line">                Comp GEqual</span><br><span class="line">                Pass Replace</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="穿透物体设置"><a href="#穿透物体设置" class="headerlink" title="穿透物体设置"></a>穿透物体设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">   &#123;</span><br><span class="line">       _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">       _refVal(<span class="string">&quot;refVal&quot;</span>,<span class="type">int</span>) = <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   SubShader</span><br><span class="line">   &#123;</span><br><span class="line">      Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry+1&quot;</span> &#125;</span><br><span class="line">      ColorMask <span class="number">0</span> <span class="comment">//RBGA，设置那个就输出对应的颜色通道值，0就代表不输出颜色</span></span><br><span class="line">       LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">       Pass</span><br><span class="line">       &#123;</span><br><span class="line">             Stencil</span><br><span class="line">           &#123;</span><br><span class="line">               Ref[_refVal]</span><br><span class="line">               Comp GEqual</span><br><span class="line">               Pass Replace</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241106191956.png" alt="image-20241106191951377"></p><p>注意：在透视投影的情况下，这种形式下的挖洞需要有单独的背景或者游戏对象去支持，单纯的天空盒会是黑色</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241106192134.png" alt="image-20241106192127579" style="zoom:80%;" /><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241106192223.png" alt="image-20241106192218959"></p><h3 id="区域蒙版"><a href="#区域蒙版" class="headerlink" title="区域蒙版"></a>区域蒙版</h3><p>实践效果参照Unity的UI组件Mask的效果，在给定区域内才能正常显示，超出范围会被裁剪</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241107093154.png" alt="image-20241107093146161" style="zoom:67%;" /><h4 id="作为背景Stencil设置"><a href="#作为背景Stencil设置" class="headerlink" title="作为背景Stencil设置"></a>作为背景Stencil设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _refVal(<span class="string">&quot;RefVal&quot;</span>,<span class="type">int</span>) =<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>  <span class="string">&quot;Queue&quot;</span>= <span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">           Stencil</span><br><span class="line">           &#123;</span><br><span class="line">                Ref[_refVal]</span><br><span class="line">                Comp Always <span class="comment">//总是将该参考值写入缓冲</span></span><br><span class="line">                Pass Replace</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h4 id="需要被裁剪的Stencil设置"><a href="#需要被裁剪的Stencil设置" class="headerlink" title="需要被裁剪的Stencil设置"></a>需要被裁剪的Stencil设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        _refVal(<span class="string">&quot;RefVal&quot;</span>,<span class="type">int</span>) =<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>  <span class="string">&quot;Queue&quot;</span>= <span class="string">&quot;Geometry+1&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">           Stencil</span><br><span class="line">           &#123;</span><br><span class="line">                Ref[_refVal]</span><br><span class="line">                Comp Equal <span class="comment">//只有当当前参考值和上一步相等的时候才会被渲染</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h1 id="光照衰减"><a href="#光照衰减" class="headerlink" title="光照衰减"></a>光照衰减</h1><p>Unity在内部使用一张名为_LightTexture0的纹理来计算光源衰减。我们通常只关心_LightTexture0对角线上的纹理颜色值，这些值表明了再光源空间中不同位置的点的衰减值。例如（0,0）点表明了与光源位置重合的点的衰减值，而（1,1）点表明了再光源空间中所关心的距离最远的点的衰减。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 lightCoord = mul(_LightMatrix0,float4(i.worldPos,<span class="number">1</span>)).xyz; </span><br><span class="line"></span><br><span class="line">fixed atten = tex2D(_LightTexture0,dot(lightCoord,lightCoord).rr).UNITY_ATTEN_CHANNEL; </span><br></pre></td></tr></table></figure><p>现将世界坐标与_LightMatrix0相乘得到在光源空间中的位置，用光源空间中顶点距离的平方来对纹理采样，然后，使用宏UINITY_ATTEN_CHANNEL来得到衰减纹理中的衰减值所在的分量，以得到最终的衰减值。</p><p>数学公式计算光照衰减</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> distance = length(_WorldSpaceLightPos0.xyz - i.worldPosition.xyz); </span><br><span class="line"></span><br><span class="line">atten = <span class="number">1.0</span>/distance; </span><br></pre></td></tr></table></figure><p>对于点光源和方向光可以简单用这个来进行计算，区域光就不能使用，区域光的各个参数不可控制，一般来说都是使用Unity中自带的</p><h1 id="阴影映射原理"><a href="#阴影映射原理" class="headerlink" title="阴影映射原理"></a>阴影映射原理</h1><h2 id="Unity中阴影"><a href="#Unity中阴影" class="headerlink" title="Unity中阴影"></a>Unity中阴影</h2><p>1，Shadow Map:它会首先把摄像机位置放在与光源重合的位置上，那么场景中该光源的阴影区域就是摄像机看不到的地方。 </p><p>摄像机放置到光源位置上就会产生一个深度映射纹理，根据这个深度图区判断一个点是不是在阴影内</p><p>2，Screenspace Shadow Map:Unity首先会通过调用LightMode 为 ShadowCaster的Pass来得到可投射阴影是光源的阴影映射纹理以及摄像机的深度纹理。然后，根据光源的阴影映射纹理和摄像机的深度纹理来得到屏幕空间的阴影图。如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，就说明该表面虽然是可见的，但是却出于该光源的阴影中。通过这样的方式，阴影图就包含了屏幕空间中所有阴影的区域。如果我们想要一个物体接收来自其他物体的阴影，只需要在Shader中对阴影图进行采样。</p><p> 总结来说就是分别在光源位置和摄像机位置产生一张阴影采样图，通过这两张图得到一个屏幕空间的阴影图。</p><p>阴影采样图的产生</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ShadowCaster&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>就可以，一般在FallBack中就会存在一个阴影的Pass，不需要特别去写</p><p>一个物体接收来自其他物体的阴影，以及它向其他物体投射阴影是两个过程。</p><p>1,如果我们想要一个物体接收来自其他物体的阴影，就必须在Shader中对阴影映射纹理（包括屏幕空间的阴影图）进行采样，把采样结果和最后的光照结果相乘来产生阴影效果。</p><p>2,如果我们想要一个物体向其他物体投射阴影，就必须把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。在Unity 中，这个过程通过为该物体执行LightMode 为ShadowCaster 的 Pass 来实现的。如果使用了屏幕空间的投射映射技术，Unity还会使用这个Pass 产生一张摄像机的深度纹理。</p><h2 id="阴影产生"><a href="#阴影产生" class="headerlink" title="阴影产生"></a>阴影产生</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241107102318.png" alt="image-20241107102313002"></p><p>实现产生阴影的Pass通道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> Pass &#123;</span><br><span class="line">        Name <span class="string">&quot;ShadowCaster&quot;</span></span><br><span class="line">        Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ShadowCaster&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> target 2.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_shadowcaster</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_instancing <span class="comment">// allow instanced shadow pass for most of the shaders</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> v2f &#123;</span><br><span class="line">    V2F_SHADOW_CASTER;</span><br><span class="line">    UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f <span class="title function_">vert</span><span class="params">( appdata_base v )</span></span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(v);</span><br><span class="line">    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);</span><br><span class="line">    TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">frag</span><span class="params">( v2f i )</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241107104048.png" alt="image-20241107104041223" style="zoom:67%;" /><h2 id="接受阴影"><a href="#接受阴影" class="headerlink" title="接受阴影"></a>接受阴影</h2><p>前向渲染手动配置接受阴影</p><p>头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br></pre></td></tr></table></figure><p>v2f结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 pos : SV_POSITION; <span class="comment">//使用Unity定义的阴影宏，这个就需要定义为pos</span></span><br><span class="line">    float3 worldNormal :TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    float3 vertexLight : TEXCOORD2;</span><br><span class="line">    SHADOW_COORDS(<span class="number">3</span>) <span class="comment">//接受阴影需要用到的宏，传入的参数是分配的TEXCOORD的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="vert内容"><a href="#vert内容" class="headerlink" title="vert内容"></a>vert内容</h3><p>需要放在顶点着色器最后面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRANSFER_SHADOW(o);</span><br><span class="line"><span class="keyword">return</span> o;</span><br></pre></td></tr></table></figure><h3 id="frag内容"><a href="#frag内容" class="headerlink" title="frag内容"></a>frag内容</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fixed shadow = SHADOW_ATTENUATION(i);</span></span><br><span class="line"><span class="comment">//这个宏同时包含了光照衰减和阴影，atten在宏中被定义和赋值，这不需要定义</span></span><br><span class="line">UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</span><br><span class="line"><span class="comment">//可以将高光颜色和漫反射颜色乘上一个衰减系数</span></span><br><span class="line"><span class="comment">//不过平行光不会衰减</span></span><br><span class="line"><span class="comment">//也可以在后面加上逐顶点着色的颜色</span></span><br><span class="line">float3 resColor = environmentLightColor + (specularColor + diffuseColor) * atten;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> float4(resColor,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241107110807.png" alt="image-20241107110759451" style="zoom:67%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241107145325.png" alt="image-20241107145319588" style="zoom:67%;" /><h2 id="AlphaTest下的阴影"><a href="#AlphaTest下的阴影" class="headerlink" title="AlphaTest下的阴影"></a>AlphaTest下的阴影</h2><h3 id="前置属性设置"><a href="#前置属性设置" class="headerlink" title="前置属性设置"></a>前置属性设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">  &#123;</span><br><span class="line">      _MainTex(<span class="string">&quot;MainTex&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//本身是慢翻身颜色，但是在FallBack的方法中的定义名称为 _Color，所以这里要求同步</span></span><br><span class="line">      _Color(<span class="string">&quot;Diffuse&quot;</span>,Color) =(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">      _Specular(<span class="string">&quot;Specular&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">      _Gloss(<span class="string">&quot;Gloss&quot;</span>,Range(<span class="number">8.0</span>,<span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//同理还有这个也需要同步</span></span><br><span class="line">      _Cutoff(<span class="string">&quot;CutOut&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  SubShader</span><br><span class="line">  &#123;</span><br><span class="line">      Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;TransparentCutOut&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest&quot;</span> &#125;</span><br><span class="line">      LOD <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="在片元着色器中的输出格式"><a href="#在片元着色器中的输出格式" class="headerlink" title="在片元着色器中的输出格式"></a>在片元着色器中的输出格式</h3><p>片元裁剪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//uv计算</span></span><br><span class="line"></span><br><span class="line">  float4 texColor = tex2D(_MainTex,i.uv);</span><br><span class="line"> clip(texColor.a - _Cutoff);<span class="comment">//如果传递的值小于零，那么当前片元就会被裁剪掉，相当于普通的ifelse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//漫反射光线计算</span></span><br><span class="line"> float3 diffuseColor = _LightColor0.rgb * _Color.rgb * (dot(lightDir,normal) * <span class="number">0.5</span> + <span class="number">0.5</span>) * texColor;</span><br></pre></td></tr></table></figure><p>混合输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fixed shadow = SHADOW_ATTENUATION(i);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这个函数同时包含了光照衰减和阴影，atten在宏中被定义和赋值，这不需要定义</span></span><br><span class="line"></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</span><br><span class="line"><span class="comment">//可以将高光颜色和漫反射颜色乘上一个衰减系数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//不过平行光不会衰减</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//也可以在后面加上逐顶点着色的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//光照衰减只有漫反射光和高光反射会有，环境光和球协函数不能有</span></span><br><span class="line">float3 resColor = environmentLightColor + (diffuseColor + specularColor) * atten+ i.vertexLight;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> float4(resColor,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241107165927.png" alt="image-20241107165816713" style="zoom:67%;" /><h2 id="AlphaBlend阴影"><a href="#AlphaBlend阴影" class="headerlink" title="AlphaBlend阴影"></a>AlphaBlend阴影</h2><p>Tags设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;true&quot;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">ZWrite Off <span class="comment">//半透明物体需要取消深度吸入，但同时，阴影的计算会出现问题，因此，半透明物体是不会进行阴影计算的</span></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br></pre></td></tr></table></figure><p>可以让透明物体强制投射影子和接受影子</p><p>投射影子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack <span class="string">&quot;Diffuse&quot;</span></span><br></pre></td></tr></table></figure><p>接受影子</p><p>将渲染顺序限制在AlphaTest和Transparent之间</p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader入门——卡通效果实现</title>
      <link href="/posts/d132fa0f.html"/>
      <url>/posts/d132fa0f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Unity卡通着色Shader实现"><a href="#Unity卡通着色Shader实现" class="headerlink" title="Unity卡通着色Shader实现"></a>Unity卡通着色Shader实现</h1><h2 id="另外一篇已经被实现的边缘着色"><a href="#另外一篇已经被实现的边缘着色" class="headerlink" title="另外一篇已经被实现的边缘着色"></a>另外一篇已经被实现的边缘着色</h2><p><a href="https://mao1mao2mao3mao4.github.io/posts/b6499ec4.html">Unity——Shader实现边缘发光效果 | mao的博客 (mao1mao2mao3mao4.github.io)</a></p><h1 id="法线外拓的三种方式来自文心一言的回答"><a href="#法线外拓的三种方式来自文心一言的回答" class="headerlink" title="法线外拓的三种方式来自文心一言的回答"></a>法线外拓的三种方式来自文心一言的回答</h1><p>要将模型空间下的法线转换到视角空间下，你需要使用模型到视图矩阵（<code>UNITY_MATRIX_MV</code>），但需要注意法线变换的特殊性。法线变换需要使用逆转置矩阵（Inverse Transpose Matrix）来保持其垂直性。Unity提供了一个宏<code>UNITY_MATRIX_IT_MV</code>（尽管你之前的代码中名称有误，但这里是为了说明正确的使用方式），它实际上已经包含了模型到视图矩阵的逆转置。</p><h2 id="1-模型空间下"><a href="#1-模型空间下" class="headerlink" title="1.模型空间下"></a>1.模型空间下</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241102171656.png" alt="image-20241102171649400" style="zoom:80%;" /><h2 id="2-视角空间下"><a href="#2-视角空间下" class="headerlink" title="2.视角空间下"></a>2.视角空间下</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241102173027.png" alt="image-20241102173012923" style="zoom: 67%;" /><h2 id="3-裁剪空间下"><a href="#3-裁剪空间下" class="headerlink" title="3.裁剪空间下"></a>3.裁剪空间下</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241102173932.png" alt="image-20241102173924641" style="zoom:80%;" /><h1 id="基础阴影实现"><a href="#基础阴影实现" class="headerlink" title="基础阴影实现"></a>基础阴影实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"> Shader <span class="string">&quot;Unlit/07&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Diffuse(<span class="string">&quot;Diffuse&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//漫反射颜色</span></span><br><span class="line">        _OutLine(<span class="string">&quot;Outline&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _OutLineColor(<span class="string">&quot;OutLineColo&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.1</span> <span class="comment">//描边颜色</span></span><br><span class="line">        _Steps(<span class="string">&quot;Steps&quot;</span>,Range(<span class="number">1</span>,<span class="number">30</span>)) = <span class="number">1</span> <span class="comment">//颜色区分的阶数</span></span><br><span class="line">        _ToonEffect(<span class="string">&quot;ToonEffect&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span> <span class="comment">//卡通化影响程度</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">          Cull Front</span><br><span class="line"></span><br><span class="line">           CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _OutLine;</span><br><span class="line">            <span class="type">float</span> _OutLineColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            float4 <span class="title function_">vert</span> <span class="params">(appdata_base v)</span> : SV_POSITION</span><br><span class="line">            &#123;</span><br><span class="line">                v.vertex += v.normal * _OutLine;</span><br><span class="line">                <span class="keyword">return</span> UnityObjectToClipPos(v.vertex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">()</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">return</span> _OutLineColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc &quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 worldNormal : TEXCOORD3;</span><br><span class="line">                float3 worldPos : texcoord4;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            float4 _Diffuse; <span class="comment">//漫反射颜色</span></span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _OutLine;</span><br><span class="line">            <span class="type">float</span> _OutLineColor;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _Steps;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _ToonEffect;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata_tan v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                 float4 texColor  = tex2D(_MainTex,i.uv);</span><br><span class="line"></span><br><span class="line">                float3 environmentLightColor = UNITY_LIGHTMODEL_AMBIENT.xyz; </span><br><span class="line"></span><br><span class="line">                float3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                float3 lightDir =normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                float3 diffuseColor = _LightColor0.rbg * _Diffuse.rbg * (dot(lightDir,i.worldNormal) *<span class="number">0.5</span> + <span class="number">0.5</span>) * texColor.rbg;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//颜色卡通化</span></span><br><span class="line">                <span class="comment">//将颜色平滑在【0,1】之间</span></span><br><span class="line">                diffuseColor =  smoothstep(<span class="number">0</span>,<span class="number">1</span>,diffuseColor);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//颜色离散化</span></span><br><span class="line">                <span class="comment">//floor向下取整，diffusColor的值因为Cos值限制在0到1 之间，不乘结果就只有0和1</span></span><br><span class="line">                <span class="comment">//放大再缩小</span></span><br><span class="line">                float3 toon = <span class="built_in">floor</span>(diffuseColor * _Steps) / _Steps; </span><br><span class="line">                diffuseColor = lerp(toon,diffuseColor,_ToonEffect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                float3 resColor = environmentLightColor + diffuseColor;</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> col = float4(resColor,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h1><p>在世界空间下求得模型边缘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//边缘光</span></span><br><span class="line">                <span class="comment">//本身和视角平行的，也就是最边缘的cos值为0，但是这样不利于颜色控制，所以使用1-</span></span><br><span class="line">                <span class="type">float</span> rim = <span class="number">1</span>-  dot(viewDir,i.worldNormal); </span><br><span class="line"><span class="comment">//使用除法是为了方便在Unity操作窗口中对边缘光的大小效果进行一个直观的调节，数值越小，边缘光就越小</span></span><br><span class="line">                float3 rimColor = _RimColor * <span class="built_in">pow</span>(rim , <span class="number">1</span>/_RimPower); </span><br></pre></td></tr></table></figure><h1 id="XRay"><a href="#XRay" class="headerlink" title="XRay"></a>XRay</h1><p>人物被物体遮挡，透过遮挡物看见人物的功能</p><p>实际上是调整深度和深度写入中的功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//关闭深度写入，翻转深度测试</span></span><br><span class="line">          <span class="comment">//A遮挡B，B是Xray物体</span></span><br><span class="line">          <span class="comment">//翻转深度测试后，物体被遮挡后才会被渲染，也就是通过深度测试，紧接着就会进行深度写入操作</span></span><br><span class="line">          <span class="comment">//这样的话深度缓冲中最新的数据就是该XRay物体，那么在A和B之间绘制一个物体C的时候，物体C会被绘制到A的前面</span></span><br><span class="line">          ZWrite Off</span><br><span class="line">          ZTest Greater</span><br><span class="line">          Blend SrcAlpha One <span class="comment">//使用源alpha进行渲染    </span></span><br><span class="line"></span><br><span class="line">          CGPROGRAM</span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">          <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">          <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//透视颜色和透视强度</span></span><br><span class="line">          float4 _XRayColor;</span><br><span class="line">          <span class="type">float</span> _XRayPower;</span><br><span class="line"></span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">             float4 vertex : SV_POSITION;</span><br><span class="line">             float3 worldNormal : TEXCOORD1;</span><br><span class="line">             float3 worldPos: TEXCOORD2;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          v2f <span class="title function_">vert</span><span class="params">(appdata_base v)</span></span><br><span class="line">          &#123;</span><br><span class="line">             v2f o;</span><br><span class="line">             o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">             o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> o;</span><br><span class="line">          </span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          float4 <span class="title function_">frag</span><span class="params">(v2f i)</span>:SV_Target</span><br><span class="line">          &#123;</span><br><span class="line">              float3 normal = normalize(i.worldNormal);</span><br><span class="line">              float3 pos = i.worldPos;</span><br><span class="line"></span><br><span class="line">              float3 viewDir = normalize(UnityWorldSpaceViewDir(pos));</span><br><span class="line">              float3 lightDir = normalize(UnityWorldSpaceLightDir(pos));</span><br><span class="line">              </span><br><span class="line">              <span class="type">float</span> rim = <span class="number">1</span> - dot(viewDir,normal);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//当人物被遮挡的时候发出边缘光</span></span><br><span class="line">              <span class="keyword">return</span> _XRayColor * <span class="built_in">pow</span>(rim,<span class="number">1</span>/_XRayPower);</span><br><span class="line">          &#125;</span><br><span class="line">          ENDCG</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>请注意，所有透明有关的shader要正确设置自己的渲染顺序</p><p>这里通过固有关键字名称+数字的形式，不能有括号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry+600&quot;</span> &#125; <span class="comment">//和半透明相关的都需要在透明度上下功夫</span></span><br></pre></td></tr></table></figure><h2 id="Shader优化"><a href="#Shader优化" class="headerlink" title="Shader优化"></a>Shader优化</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241104095836.png" alt="image-20241104095829434" style="zoom:80%;" /><h1 id="卡通场景"><a href="#卡通场景" class="headerlink" title="卡通场景"></a>卡通场景</h1><h2 id="杂项知识"><a href="#杂项知识" class="headerlink" title="杂项知识"></a>杂项知识</h2><ul><li>使用的内容和人物2DShader一致，新添加了对法线的使用</li></ul><p><a href="https://mao1mao2mao3mao4.github.io/posts/4139c4a.html">Unity —— Shader入门，法线贴图 | mao的博客 (mao1mao2mao3mao4.github.io)</a></p><ul><li>新增对UsePass的使用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UsePass <span class="string">&quot;Unlit/07/OutLine&quot;</span> <span class="comment">//直接使用别的Shader中的Pass，前提是该Pass中使用的参数要在Propreties中定义</span></span><br><span class="line">        <span class="comment">//在Unity2018之后的版本中，对Pass的使用可以不大写</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241104110448.png" alt="image-20241104110442625" style="zoom:67%;" /><ul><li>Properties属性栏中，属性，例如：_MainTex，这样的属性名，如果在ShaderA，B中都有声明，A中首先引用一张图片，那么B在Unity操作窗口中同样会有这一张图片的引用</li></ul><h2 id="雪的制作"><a href="#雪的制作" class="headerlink" title="雪的制作"></a>雪的制作</h2><h3 id="Properties属性添加"><a href="#Properties属性添加" class="headerlink" title="Properties属性添加"></a>Properties属性添加</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Snow(<span class="string">&quot;Snow&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>))= <span class="number">0.5</span><span class="comment">//雪的大小</span></span><br><span class="line">_SnowColor(<span class="string">&quot;SnowColor&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//雪的颜色</span></span><br><span class="line">_SnowDir(<span class="string">&quot;SnowDir&quot;</span>,<span class="built_in">vector</span>) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//雪的方向 </span></span><br></pre></td></tr></table></figure><h3 id="Shader宏定义"><a href="#Shader宏定义" class="headerlink" title="Shader宏定义"></a>Shader宏定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//对于一个宏变量的处理，表示开关状态，一般用 __ 表示未定义状态</span></span><br><span class="line">         <span class="comment">//不然如果是一个有含义的变量去处理，在使用的时候需要对两个变量就行管理</span></span><br><span class="line">         <span class="comment">//可能会出现同时有效的情况</span></span><br><span class="line">         <span class="comment">//__代表的是默认不开的情况</span></span><br><span class="line"><span class="comment">//在命名上有一定规则</span></span><br><span class="line">         <span class="meta">#<span class="keyword">pragma</span> mutil_compile __ _SNOW_ON </span></span><br></pre></td></tr></table></figure><h3 id="Shader效果实现"><a href="#Shader效果实现" class="headerlink" title="Shader效果实现"></a>Shader效果实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">if</span> _SNOW_ON</span></span><br><span class="line"> <span class="keyword">if</span>(dot(worldNormal,_SnowDir.xyz) &gt; lerp(<span class="number">1</span>，<span class="number">-1</span>，_Snow)) <span class="comment">//lerp，前者是开始值，后置是目标值</span></span><br><span class="line"> &#123;</span><br><span class="line">   resColor.rbg = _SnowColor.rbg;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  resColor.rbg = resColor.rbg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="C-脚本宏控制"><a href="#C-脚本宏控制" class="headerlink" title="C#脚本宏控制"></a>C#脚本宏控制</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShaderSnow</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> SNOW_ON = <span class="string">&quot;SNOW_ON&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Tools/Shader/打开或则关闭雪的宏&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenRimLight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Shader.IsKeywordEnabled(SNOW_ON))</span><br><span class="line">        &#123;</span><br><span class="line">            Shader.DisableKeyword(SNOW_ON);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Shader.EnableKeyword(SNOW_ON);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-全局变量控制"><a href="#C-全局变量控制" class="headerlink" title="C#全局变量控制"></a>C#全局变量控制</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方式和在Shader的Properties定义的一样，只不过这里有，Properties就不能定义     </span></span><br><span class="line"><span class="built_in">string</span> Snow = <span class="string">&quot;_Snow&quot;</span>;</span><br><span class="line">       </span><br><span class="line">Shader.SetGlobalFloat(Snow, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— Shader入门，纹理应用和透明效果</title>
      <link href="/posts/3783ec90.html"/>
      <url>/posts/3783ec90.html</url>
      
        <content type="html"><![CDATA[<h1 id="UnityShader入门——纹理应用和透明效果"><a href="#UnityShader入门——纹理应用和透明效果" class="headerlink" title="UnityShader入门——纹理应用和透明效果"></a>UnityShader入门——纹理应用和透明效果</h1><h1 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h1><p>最简单的，用一张贴图去实现，给出的贴图应该是渐变的色块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> halfLambert = dot(i.worldNormal,lightDir)* <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">//漫反射</span></span><br><span class="line">float3 diffue =  _LightColor0.rgb * _Diffse.rgb  * tex2D(_RampTex,float2(halfLambert,halfLambert));</span><br></pre></td></tr></table></figure><p>渐变纹理按照半兰伯特光照的颜色排序，在 x 轴上渐变</p><h2 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h2><p>对blinn phong高光使用该效果，可以控制高光颜色强度</p><p>局部着色器实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float3 halfPhongMask = tex2D(_SpecularMask,i.uvMask).r * _SpecularMaskStrength;<span class="comment">//提取遮罩贴图并 和强度进行相关</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//高光反射</span></span><br><span class="line">  <span class="comment">//float3 halfView = normalize(_WorldSpaceCameraPos + _WorldSpaceLightPos0);</span></span><br><span class="line">  float3 halfView = normalize(viewDir + lightDir);</span><br><span class="line"> float3 phong = _LightColor0.rgb * _Specular.rbg * <span class="built_in">pow</span>(max(<span class="number">0</span>,dot(i.worldNormal,halfView)),_Gloss) *                  halfPhongMask; <span class="comment">//加入遮罩</span></span><br></pre></td></tr></table></figure><h1 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h1><ol><li><p>透明度测试：</p><p>只要一个片元的透明度不满足条件（通常小于某个阈值），那么就舍弃对应的片元。被舍弃的片元不会在进行任何的处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体来处理，即进行深度测试，深度写入等等。虽然简单，但是很极端，要么完全透明，要么完全不透明。</p></li><li><p>透明度混合：</p><p>可以得到真正的半透明效果，它会使当前片元的透明度作为混合因子，与已经储存在颜色缓冲中的颜色值进行混合么，得到新的颜色。但是，透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。注意：透明度混合只关闭了深度写入，但没有关闭深度测试。这表示当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前深度缓冲中的深度值，如果深度值距离摄像机更远，那么就不会在进行混合操作。比如一个不透明物体在透明物体前面，我们先渲染不透明物体，可以正常的挡住不透明物体。</p></li></ol><h2 id="正确的渲染顺序"><a href="#正确的渲染顺序" class="headerlink" title="正确的渲染顺序"></a>正确的渲染顺序</h2><p>首先将所有的不透明物体开始深度测试和深度写入，然后将所有透明物体排序，从远到近进行渲染</p><h2 id="渲染队列"><a href="#渲染队列" class="headerlink" title="渲染队列"></a>渲染队列</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>队列索引号</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Background</td><td>1000</td><td>这个渲染队列会在其他任何队列之前被渲染，通常用来渲染背景</td></tr><tr><td>Geometry</td><td>2000</td><td>默认的渲染对了，大多数物体使用这个队列，不透明物体使用这个队列</td></tr><tr><td>AlphaTest</td><td>2450</td><td>需要透明度测试的物体使用的队列</td></tr><tr><td>Transparent</td><td>3000</td><td>这个队列的物体会在所有Geometry和AlphatTest物体渲染之后，再按照从后往前的顺序进行渲染。任何透明物体都使用该队列</td></tr><tr><td>Overlay</td><td>4000</td><td>该队列实现一些叠加效果。任何最后渲染的物体在该对了。</td></tr></tbody></table><p>输入地方在Tags中进行选择，渲染顺序是根据队列索引号从效到大，如果想要使用不同的队列索引号，需要在Tags中使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent - 500&quot;</span><span class="comment">//渲染顺序</span></span><br></pre></td></tr></table></figure><p>以上操作使用的就是 2500 的队列索引号</p><h1 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h1><p>使用基础的 if 判断，将透明度小于给定裁剪透明值的给抛弃掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> float4 uvColor = tex2D(_MainTex,i.uv);</span><br><span class="line">               </span><br><span class="line"><span class="keyword">if</span>(uvColor.a - _Alpha_CullOf &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">       discard;<span class="comment">//裁剪</span></span><br><span class="line"> &#125;</span><br><span class="line">                </span><br><span class="line">        float3 diffuseColor = _LightColor0.rbg * _Diffse.rbg * (max(<span class="number">0</span>,dot(viewDir,i.worldNormal)) *<span class="number">0.5</span> + <span class="number">0.5</span>) * uvColor.rbg;</span><br></pre></td></tr></table></figure><p>Tags中的设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;AlphaTest&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;true&quot;</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了性能考虑，建议规范化书写Tags里面的内容</p><h1 id="FallBack"><a href="#FallBack" class="headerlink" title="FallBack"></a>FallBack</h1><p>不同的类型的FallBack也不同</p><p>Diffuse - Diffuse</p><p>目前对于AlphaTest没找到一个合适的</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241101171606.png" alt="image-20241101171559468" style="zoom:80%;" /><h1 id="透明混合"><a href="#透明混合" class="headerlink" title="透明混合"></a>透明混合</h1><p>在UnityShader中，只要有关键字Blend,就代表开启混合（除Blend off以外），OpenGL和DX的使用是需要手动开启的</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Blend  SrcFactor DstFactor</td><td>开启混合，并设置混合因子。源颜色（该片元颜色）乘以SrcFactor,目标颜色（已经存在于颜色缓冲的颜色）会乘以DstFactor,然后把两者相加后在存入颜色缓冲区</td></tr><tr><td>Blend  SrcFactor  DstFactor,SrcFactorA  DstFactorA</td><td>与上面一样，只是使用不同的因子来混合透明通道</td></tr></tbody></table><h2 id="混合因子"><a href="#混合因子" class="headerlink" title="混合因子"></a>混合因子</h2><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>One</td><td>因子为1</td></tr><tr><td>Zero</td><td>因子为0</td></tr><tr><td>SrcColor</td><td>因子为元颜色值。当用于混合RGB的混合等式时，使用SrcColor的RGB分量作为混合因子；当用于混合A的混合公式的时候，使用SrcColor的A分量作为混合因子。</td></tr><tr><td>SrcAlpha</td><td>因子为源颜色的透明度值（A通道）</td></tr><tr><td>DstColor</td><td>因子目标颜色值。相当于混合RGB通道的混合等式时，使用DstColor的RGB分量作为混合因子；当用于混合A通道的混合等式时，使用DstColor的A分量作为混合因子。</td></tr><tr><td>DstAlpha</td><td>因子为目标颜色的透明度值（A通道）</td></tr><tr><td>OneMinusSrcColor</td><td>因子为（1-源颜色）。相当于混合RGB通道的混合等式时，使用结果RGB分量作为混合因子；当用于混合A通道的混合等式时，使用结果的A分量作为混合因子。</td></tr><tr><td>OneMinusSrcAlpha</td><td>因子为（1-源颜色的透明度值）</td></tr><tr><td>OneMinusDstColor</td><td>因子为（1-目标颜色）。相当于混合RGB通道的混合等式时，使用结果RGB分量作为混合因子；当用于混合A通道的混合等式时，使用结果的A分量作为混合因子。</td></tr><tr><td>OneMinusDstAlpha</td><td>因子为（1-目标颜色的透明度值）</td></tr></tbody></table><h2 id="混合操作"><a href="#混合操作" class="headerlink" title="混合操作"></a>混合操作</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241101165121.png" alt="image-20241101165115772"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241101165130.png" alt="image-20241101165125154"></p><h2 id="常见混合操作类型"><a href="#常见混合操作类型" class="headerlink" title="常见混合操作类型"></a>常见混合操作类型</h2><ol><li><p>&#x2F;&#x2F;正常（Normal）透明度混合</p><p>Blend SrcAlpha OneMinusSrcAlpha</p></li><li><p>&#x2F;&#x2F;柔和相加</p><p>Blend OneMinusDstColor One</p></li><li><p>&#x2F;&#x2F;正片叠底</p><p>Blend DstColor Zero</p></li><li><p>&#x2F;&#x2F;两倍相乘</p><p>Blend DstColor SrcColor</p></li><li><p>&#x2F;&#x2F;变暗</p><p>BlendOp min</p></li><li><p>Blend One One</p><p>&#x2F;&#x2F;变亮</p></li><li><p>Blend OneMinusDstColor One</p></li><li><p>Blend One OneMinusSrcColor</p><p>&#x2F;&#x2F;线性减淡</p></li><li><p>Blend One One</p></li></ol><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/06&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(<span class="string">&quot;MainTex&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        _Diffse(<span class="string">&quot;Diffuse&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        _AlphaRange(<span class="string">&quot;AlphaRange&quot;</span>,Range(<span class="number">0</span>,<span class="number">1</span>))= <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;true&quot;</span> <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        ZWrite Off <span class="comment">//关闭深度写入</span></span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha <span class="comment">//选择合适的混合模式</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">           Tags&#123;<span class="string">&quot;LightMode&quot;</span>= <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">             <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc &quot;</span></span></span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">                <span class="keyword">struct</span> v2f</span><br><span class="line">                &#123;</span><br><span class="line">                    float4 vertex : SV_POSITION;</span><br><span class="line">                    float2 uv: TEXCOORD0;</span><br><span class="line">                    float3 worldPos: TEXCOORD1;</span><br><span class="line">                    float3 worldNormal : TEXCOORD2;</span><br><span class="line"></span><br><span class="line">             </span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            </span><br><span class="line">            float4 _Diffse;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _AlphaRange;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata_tan v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//切线空间的视线和光线方向获取</span></span><br><span class="line"></span><br><span class="line">                float3 environmentLightColor = UNITY_LIGHTMODEL_AMBIENT.xyz; </span><br><span class="line"></span><br><span class="line">                float3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                float3 lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">               float4 uvColor = tex2D(_MainTex,i.uv);</span><br><span class="line">               </span><br><span class="line">            </span><br><span class="line">                </span><br><span class="line">              </span><br><span class="line">               float3 diffuseColor = _LightColor0.rbg * _Diffse.rbg * (dot(viewDir,i.worldNormal) * <span class="number">0.5</span> + <span class="number">0.5</span>) * uvColor.rbg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                float3 resColor = environmentLightColor + diffuseColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                float4 col = float4(resColor,uvColor.a * _AlphaRange);<span class="comment">//源物体的a值操作 关键点</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FallBack <span class="string">&quot;Transparent/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="容易出错"><a href="#容易出错" class="headerlink" title="容易出错"></a>容易出错</h2><p>透明混合中对于半透明物体前后关系交叉，深度判断容易出错的情况，在原有的pass上方新建一个下面这个就行</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241101172243.png" alt="image-20241101172238962"></p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— Shader入门，法线贴图</title>
      <link href="/posts/4139c4a.html"/>
      <url>/posts/4139c4a.html</url>
      
        <content type="html"><![CDATA[<h1 id="UnityShader入门——法线贴图"><a href="#UnityShader入门——法线贴图" class="headerlink" title="UnityShader入门——法线贴图"></a>UnityShader入门——法线贴图</h1><p>高度映射，模型空间下的法线映射，切线空间下的法线映射</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241031151626.png" alt="image-20241031151622403"></p><h2 id="贴图纹理和法线之间的转换"><a href="#贴图纹理和法线之间的转换" class="headerlink" title="贴图纹理和法线之间的转换"></a>贴图纹理和法线之间的转换</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241102203351.png" alt="image-20241031153135100" style="zoom:80%;" /><p>知识：向量的分量就是 向量的点表示图中，按照逗号进行分割数字</p><h1 id="高度映射"><a href="#高度映射" class="headerlink" title="高度映射"></a>高度映射</h1><p>使用像素的灰度值来表示该位置的深度</p><p>缺点是需要通过一系列的计算来变换为可以使用的法线角度、不利于美术的处理</p><h1 id="模型空间下的法线映射"><a href="#模型空间下的法线映射" class="headerlink" title="模型空间下的法线映射"></a>模型空间下的法线映射</h1><p>坐标系的原点是模型坐标系的原点</p><p>颜色很多，每个点的向量都有可能不同，最后呈现的结果就是花里胡哨的。</p><p>UV点和模型的每一个顶点都是一一对应的，不方便移动改变，有些高级的特效或者粒子特效需要移动UV贴图来实现。</p><p>制作简单</p><p>一般在3S贴图中可能遇见</p><p>优点</p><p>实现简单，更加直观。计算量少。在纹理的边角部分，缝隙较少，可提供平滑的边界。是因为所有法线都是在同一坐标空间中，可以在边角处通过插值进行平滑变换。</p><h1 id="切线空间下的法线映射"><a href="#切线空间下的法线映射" class="headerlink" title="切线空间下的法线映射"></a>切线空间下的法线映射</h1><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241031160150.png" alt="image-20241031160143378" style="zoom:80%;" /><p>叉乘: </p><p>向量叉乘是对两个三维空间中的向量进行的一种二元运算，其结果是一个新的向量，这个向量垂直于由原始两个向量所定义的平面。</p><p>对于两个三维向量a(x1, y1, z1)和b(x2, y2, z2)，它们的叉乘c &#x3D; a × b可以表示为：</p><p>c &#x3D; (y1z2 - y2z1, z1x2 - z2x1, x1y2 - x2y1)</p><p>请自行百关于叉乘的详细信息</p><p>优点</p><p>自由度高。切线空间下的法线纹理是相对法线纹理，即便在一个不同的网格上也可以得到一个合理的结果。可进行UV动画。可以通过移动一个纹理的UV坐标来实现一个凹凸移动的效果可重用法线纹理。可压缩。切线空间下，Z轴方向总是正方向，可以只存储XY轴，推导得到Z轴。</p><p>切线空间中，原来在模型空间下的法线坐标的法线是（0，0,1），这个值转换到通过 切线到颜色的转换后结果是 （0.5,0.5,1），在视觉上表现出来浅蓝色。最终结果大面积呈现为淡蓝色，说明大部分新法线还是原来的法线。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li><p>在顶点着色器中进入到每个顶点的切线坐标系下计算出真实的法线，再交给片元着色器进行染色</p><p>性能比较好，顶点着色器的计算要比片元着色器少</p></li><li><p>在片元着色器将所有法线转换到世界坐标下，然后再去进行计算</p></li></ol><h2 id="进入切线空间"><a href="#进入切线空间" class="headerlink" title="进入切线空间"></a>进入切线空间</h2><h3 id="旋转矩阵的求解"><a href="#旋转矩阵的求解" class="headerlink" title="旋转矩阵的求解"></a>旋转矩阵的求解</h3><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241031163319.png" alt="image-20241031163313590" style="zoom:80%;" /><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/01&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Blutom(<span class="string">&quot;Blutom&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Diffse(<span class="string">&quot;Diff&quot;</span>,color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>,color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>,Range(<span class="number">1</span>,<span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">        _NormalStrength(<span class="string">&quot;NormalStrength&quot;</span>,<span class="type">float</span>) =<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">             <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc &quot;</span></span></span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">                <span class="keyword">struct</span> v2f</span><br><span class="line">                &#123;</span><br><span class="line">                    float4 vertex : SV_POSITION;</span><br><span class="line">                    float2 uv: TEXCOORD0;</span><br><span class="line">                    float3 lightDir: TEXCOORD1;</span><br><span class="line">                    float3 viewDir : TEXCOORD2;</span><br><span class="line">                    float2 normalUv : TEXCOORD3;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;<span class="comment">//从属于上一个变量   </span></span><br><span class="line"></span><br><span class="line">            sampler2D _Blutom;</span><br><span class="line">            float4 _Blutom_ST;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _NormalStrength;</span><br><span class="line"></span><br><span class="line">            float4 _Diffse;</span><br><span class="line">            float4 _Specular;</span><br><span class="line">            <span class="type">int</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata_tan v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//切线空间法线计算</span></span><br><span class="line">                <span class="comment">//副切线</span></span><br><span class="line">                <span class="comment">//float3 subTangent = cross(normalize(v.normal),normalize(v.tangent.xyz)) * v.tangent.w;//cross计算出来的是个标量，需要和副切线的方向相乘，就是切线的w方向</span></span><br><span class="line">                <span class="comment">//旋转矩阵</span></span><br><span class="line">                <span class="comment">//float3x3 rotation = float3(v.tangent.xyz,subTangent,v.normal);</span></span><br><span class="line"></span><br><span class="line">                TANGENT_SPACE_ROTATION;<span class="comment">//实际上就是封装了以上两步</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//Unity中对于向量的保存是列向量，因此使用右乘，</span></span><br><span class="line">                o.lightDir = mul(rotation,ObjSpaceLightDir(v.vertex)).xyz;<span class="comment">//objSpaceLightDir将世界坐标下的光照转换到模型空间</span></span><br><span class="line">                o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">                <span class="comment">//o.uv = v.texcoord.xy * _MainTex_ST.xy +s _MainTex_ST.zw;</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                o.normalUv =TRANSFORM_TEX(v.texcoord,_Blutom);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//切线空间的视线和光线方向获取</span></span><br><span class="line"></span><br><span class="line">                float3 environmentLightColor = UNITY_LIGHTMODEL_AMBIENT.xyz; </span><br><span class="line"></span><br><span class="line">                float3 viewDir = normalize(i.viewDir);</span><br><span class="line"></span><br><span class="line">                float3 lightDir = normalize(i.lightDir);</span><br><span class="line"></span><br><span class="line">                float4 packedNormal = tex2D(_Blutom,i.normalUv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解读存储的法线贴图</span></span><br><span class="line">                <span class="comment">//float3 tangentNormal;</span></span><br><span class="line">                <span class="comment">//tangentNormal.xy = (packedNormal.xy * 2 -1) * _NormalStrength;</span></span><br><span class="line">                <span class="comment">//tangentNormal.z = sqrt(1-dot(packedNormal.xy,packedNormal.xy));</span></span><br><span class="line">                </span><br><span class="line">                   <span class="comment">//使用Unity堆法线贴图的存储方式</span></span><br><span class="line">                float3 tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal *= NormalStrength;</span><br><span class="line">              </span><br><span class="line">                <span class="comment">//纹理采样</span></span><br><span class="line">                float3 albedo = tex2D(_MainTex,i.uv).rbg;</span><br><span class="line">                <span class="comment">//漫反射</span></span><br><span class="line">                float3 diffue = albedo *  _LightColor0.rgb * _Diffse.rgb  * (dot(tangentNormal,lightDir)* <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//高光反射</span></span><br><span class="line">                <span class="comment">//float3 halfView = normalize(_WorldSpaceCameraPos + _WorldSpaceLightPos0);</span></span><br><span class="line">                float3 halfView = normalize(viewDir + lightDir);</span><br><span class="line">                float3 phong = _LightColor0.rgb * _Specular * <span class="built_in">pow</span>(max(<span class="number">0</span>,dot(tangentNormal,halfView)),_Gloss);</span><br><span class="line">                float3 resColor = diffue + phong;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                float4 col = float4(resColor,<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="提取到世界空间"><a href="#提取到世界空间" class="headerlink" title="提取到世界空间"></a>提取到世界空间</h2><p>旋转矩阵的大致翻转过程和进入切线空间的一致</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/02&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Blutom(<span class="string">&quot;Blutom&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Diffse(<span class="string">&quot;Diff&quot;</span>,color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>,color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>,Range(<span class="number">1</span>,<span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">        _NormalStrength(<span class="string">&quot;NormalStrength&quot;</span>,<span class="type">float</span>) =<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">             <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc &quot;</span></span></span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">                <span class="keyword">struct</span> v2f</span><br><span class="line">                &#123;</span><br><span class="line">                    float4 vertex : SV_POSITION;</span><br><span class="line">                    float4 uv: TEXCOORD0;</span><br><span class="line">                    float4 Ttiw1 : TEXCOORD1;</span><br><span class="line">                    float4 Ttiw2 : TEXCOORD2;</span><br><span class="line">                    float4 Ttiw3 : TEXCOORD3;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;<span class="comment">//从属于上一个变量   </span></span><br><span class="line"></span><br><span class="line">            sampler2D _Blutom;</span><br><span class="line">            float4 _Blutom_ST;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _NormalStrength;</span><br><span class="line"></span><br><span class="line">            float4 _Diffse;</span><br><span class="line">            float4 _Specular;</span><br><span class="line">            <span class="type">int</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(appdata_tan v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//切线空间法线计算</span></span><br><span class="line">                <span class="comment">//副切线</span></span><br><span class="line">                <span class="comment">//float3 subTangent = cross(normalize(v.normal),normalize(v.tangent.xyz)) * v.tangent.w;//cross计算出来的是个标量，需要和副切线的方向相乘，就是切线的w方向</span></span><br><span class="line">                <span class="comment">//旋转矩阵</span></span><br><span class="line">                <span class="comment">//float3x3 rotation = float3(v.tangent.xyz,subTangent,v.normal);</span></span><br><span class="line"></span><br><span class="line">                TANGENT_SPACE_ROTATION;<span class="comment">//实际上就是封装了以上两步</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//Unity中对于向量的保存是列向量，因此使用右乘，</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//计算世界坐标下的顶点位置，法线，切线和副切线</span></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                float3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                float3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                float3 subTangent = cross(worldNormal,worldTangent)* v.tangent.w;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//按列摆放得到从切线空间到世界空间的变换矩阵</span></span><br><span class="line">                o.Ttiw1 = float4(worldTangent.x,subTangent.x,worldNormal.x,worldPos.x);</span><br><span class="line">                o.Ttiw2 = float4(worldTangent.y,subTangent.y,worldNormal.y,worldPos.y);</span><br><span class="line">                o.Ttiw3 = float4(worldTangent.z,subTangent.z,worldNormal.z,worldPos.z);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">                <span class="comment">//o.uv = v.texcoord.xy * _MainTex_ST.xy +s _MainTex_ST.zw;</span></span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                o.uv.wz =TRANSFORM_TEX(v.texcoord,_Blutom);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float3 environmentLightColor = UNITY_LIGHTMODEL_AMBIENT.xyz; </span><br><span class="line"></span><br><span class="line">                <span class="comment">//世界坐标下的顶点位置</span></span><br><span class="line">                float3 worldPos = float3(i.Ttiw1.w,i.Ttiw2.w,i.Ttiw3.w);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//世界空间下的视线和光线方向获取</span></span><br><span class="line"></span><br><span class="line">                float3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                float3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line"></span><br><span class="line">                float4 packedNormal = tex2D(_Blutom,i.uv.wz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//解读存储的法线贴图</span></span><br><span class="line">                <span class="comment">//float3 tangentNormal;</span></span><br><span class="line">                <span class="comment">//tangentNormal.xy = (packedNormal.xy * 2 -1) * _NormalStrength;</span></span><br><span class="line">                <span class="comment">//tangentNormal.z = sqrt(1-dot(packedNormal.xy,packedNormal.xy));</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用Unity堆法线贴图的存储方式</span></span><br><span class="line">                <span class="comment">//获得法线纹理</span></span><br><span class="line">                float3 tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal *= _NormalStrength;</span><br><span class="line">              </span><br><span class="line">                <span class="comment">//切线空间转换到世界坐标</span></span><br><span class="line">                float3 worldiNormal = normalize(float3(dot(i.Ttiw1.xyz,tangentNormal),</span><br><span class="line">                                          dot(i.Ttiw2.xyz,tangentNormal),</span><br><span class="line">                                          dot(i.Ttiw3.xyz,tangentNormal))</span><br><span class="line">                                          );</span><br><span class="line">                <span class="comment">//纹理采样</span></span><br><span class="line">                float3 albedo = tex2D(_MainTex,i.uv.xy).rbg;</span><br><span class="line">                <span class="comment">//漫反射</span></span><br><span class="line">                float3 diffue = albedo *  _LightColor0.rgb * _Diffse.rgb  * (dot(worldiNormal,lightDir)* <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//高光反射</span></span><br><span class="line">                <span class="comment">//float3 halfView = normalize(_WorldSpaceCameraPos + _WorldSpaceLightPos0);</span></span><br><span class="line">                float3 halfView = normalize(viewDir + lightDir);</span><br><span class="line">                float3 phong = _LightColor0.rgb * _Specular * <span class="built_in">pow</span>(max(<span class="number">0</span>,dot(worldiNormal,halfView)),_Gloss);</span><br><span class="line">                float3 resColor = diffue + phong;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                float4 col = float4(resColor,<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="法线贴图设置"><a href="#法线贴图设置" class="headerlink" title="法线贴图设置"></a>法线贴图设置</h1><p>Unity对于导入的图片素材可以进行一个分类，这里展示Unity中对于将图片自动转换为高度映射的法线贴图的选项框</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241101093020.png" alt="image-20241101093014850"></p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— Shader，常用函数</title>
      <link href="/posts/bbb76467.html"/>
      <url>/posts/bbb76467.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="函数-功能描述"><a href="#函数-功能描述" class="headerlink" title="函数 功能描述"></a>函数 功能描述</h2><ol><li>abs(x) 返回输入参数的绝对值</li><li>acos(x) 反余切函数，输入参数范围为[-1,1]， 返回[0,π]区间的角度值</li><li>all(x) 如果输入参数均不为0，则返回ture； 否则返回flase。&amp;&amp;运算</li><li>any(x) 输入参数只要有其中一个不为0，则返回true。</li><li>asin(x) 反正弦函数,输入参数取值区间为，返回角度值范围为, </li><li>atan(x) 反正切函数，返回角度值范围为</li><li>atan2(y,x) 计算y&#x2F;x的反正切值。实际上和atan(x)函数功能完全一样，至少输入参数不同。atan(x) &#x3D; atan2(x, float(1))。</li><li>ceil(x) 对输入参数向上取整。例如： ceil(float(1.3)) ，其返回值为2.0</li><li>clamp(x,a,b) 如果x值小于a，则返回a；</li><li>如果x值大于b，返回b；否则，返回x。</li><li>cos(x) 返回弧度x的余弦值。返回值范围为</li><li>cosh(x) 双曲余弦（hyperbolic cosine）函数，计算x的双曲余弦值。</li><li>cross(A,B) 返回两个三元向量的叉积(cross product)。注意，输入参数必须是三元向量！</li><li>degrees(x) 输入参数为弧度值(radians)，函数将其转换为角度值(degrees)</li><li>determinant(m) 计算矩阵的行列式因子。</li><li>dot(A,B) 返回A和B的点积(dot product)。参数A和B可以是标量，也可以是向量（输入参数方面，点积和叉积函数有很大不同）。</li><li>exp(x) 计算的值，e&#x3D;2.71828182845904523536</li><li>exp2(x) 计算的值</li><li>floor(x) 对输入参数向下取整。例如floor(float(1.3))返回的值为1.0；但是floor(float(-1.3))返回的值为-2.0。该函数与ceil(x)函数相对应。</li><li>fmod(x,y) 返回x&#x2F;y的余数。如果y为0，结果不可预料。</li><li>frac(x) 返回标量或矢量的小数</li><li>frexp(x, out i) 将浮点数x分解为尾数和指数，即， 返回m，并将指数存入i中；如果x为0，则尾数和指数都返回0</li><li>isfinite(x) 判断标量或者向量中的每个数据是否是有限数，如果是返回true；否则返回false;</li><li>isinf(x) 判断标量或者向量中的每个数据是否是无限，如果是返回true；否则返回false;</li><li>isnan(x) 判断标量或者向量中的每个数据是否是非数据(not-a-number NaN)，如果是返回true；否则返回false;</li><li>ldexp(x, n) 计算的值</li><li>lerp(a, b, f) 计算或者的值。即在下限a和上限b之间进行插值，f表示权值。注意，如果a和b是向量，则权值f必须是标量或者等长的向量。前者是开始值，后者是目标值</li><li>lit(NdotL, NdotH, m) N表示法向量；L表示入射光向量；H表示半角向量；m表示高光系数。 函数计算环境光、散射光、镜面光的贡献，返回的4元向量。 X位表示环境光的贡献，总是1.0; Y位代表散射光的贡献，如果 ，则为0；否则为 Z位代表镜面光的贡献，如果 或者，则位0；否则为;W位始终位1.0</li><li>log(x) 计算的值，x必须大于0</li><li>log2(x) 计算的值，x必须大于0</li><li>log10(x) 计算的值，x必须大于0</li><li>max(a, b) 比较两个标量或等长向量元素，返回最大值。</li><li>min(a,b) 比较两个标量或等长向量元素，返回最小值。</li><li>modf(x, out ip) 把x分解成整数和分数两部分，每部分都和x有着相同的符号，整数部分被保存在ip中，分数部分由函数返回</li><li>mul(M, N) 矩阵M和矩阵N的积</li><li>mul(M, v) 矩阵M和列向量v的积</li><li>mul(v, M) 行向量v和矩阵M的积</li><li>noise(x) 根据它的参数类型，这个函数可以是一元、二元或三元噪音函数。返回的值在0和1之间，并且通常与给定的输入值一样 </li><li>radians(x) 函数将角度值转换为弧度值</li><li>round(x) 返回四舍五入值。</li><li>rsqrt(x) x的平方根的倒数，x必须大于0</li><li>saturate(x) 把x限制到[0,1]之间</li><li>sign(x) 如果则返回1；否则返回0</li><li>sin(x) 输入参数为弧度，计算正弦值，返回值范围 为[-1,1]</li><li>sincos(float x, out s, out c) 该函数是同时计算x的sin值和cos值，其中s&#x3D;sin(x)，c&#x3D;cos(x)。该函数用于“同时需要计算sin值和cos值的情况”，比分别运算要快很多!</li><li>sinh(x) 计算x的双曲正弦</li><li>smoothstep(min, max, x) 值x位于min、max区间中。如果x&#x3D;min，返回0；如果x&#x3D;max，返回1；如果x在两者之间，按照下列公式返回数据：</li><li>step(a, x) 如果，返回0；否则，返回1</li><li>sqrt(x) 求x的平方根，，x必须大于0</li><li>tan(x) 计算x正切值</li><li>tanh(x) 计算x的双曲线切线</li><li>transpose(M) 矩阵M的转置矩阵</li></ol><h2 id="几何函数-功能描述"><a href="#几何函数-功能描述" class="headerlink" title="几何函数   功能描述"></a>几何函数   功能描述</h2><ol><li>distance(pt1, pt2) 两点之间的欧几里德距离（Euclidean distance）</li><li>faceforward(N,I,Ng) 如果，返回N；否则返回-N。</li><li>length(v) 返回一个向量的模，即sqrt(dot(v,v))</li><li>normalize(v) 返回v向量的单位向量</li><li>reflect(I, N) 根据入射光纤方向I和表面法向量N计算反射向量，仅对三元向量有效</li><li>refract(I,N,eta) 根据入射光线方向I，表面法向量N和折射相对系数eta,计算折射向量。如果对给定的eta,I和N之间的角度太大，返回(0,0,0)。只对三元向量有效</li></ol><h2 id="纹理映射函数函数-功能描述"><a href="#纹理映射函数函数-功能描述" class="headerlink" title="纹理映射函数函数   功能描述"></a>纹理映射函数函数   功能描述</h2><ol><li>tex1D(sampler1D tex, float s) 一维纹理查询</li><li>tex1D(sampler1D tex, float s, float dsdx, float dsdy) 使用导数值（derivatives）查询一维纹理</li><li>Tex1D(sampler1D tex, float2 sz) 一维纹理查询，并进行深度值比较</li><li>Tex1D(sampler1D tex, float2 sz, float dsdx,float dsdy) 使用导数值（derivatives）查询一维纹理， 并进行深度值比较</li><li>Tex1Dproj(sampler1D tex, float2 sq) 一维投影纹理查询</li><li>Tex1Dproj(sampler1D tex, float3 szq) 一维投影纹理查询，并比较深度值</li><li>Tex2D(sampler2D tex, float2 s) 二维纹理查询</li><li>Tex2D(sampler2D tex, float2 s, float2 dsdx, float2 dsdy) 使用导数值（derivatives）查询二维纹理</li><li>Tex2D(sampler2D tex, float3 sz) 二维纹理查询，并进行深度值比较</li><li>Tex2D(sampler2D tex, float3 sz, float2 dsdx,float2 dsdy) 使用导数值（derivatives）查询二维纹理，并进行深度值比较</li><li>Tex2Dproj(sampler2D tex, float3 sq) 二维投影纹理查询</li><li>Tex2Dproj(sampler2D tex, float4 szq) 二维投影纹理查询，并进行深度值比较</li><li>texRECT(samplerRECT tex, float2 s) 二维非投影矩形纹理查询（OpenGL独有）</li><li>texRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy) 二维非投影使用导数的矩形纹理查询（OpenGL独有）</li><li>texRECT (samplerRECT tex, float3 sz) 二维非投影深度比较矩形纹理查询（OpenGL独有）</li><li>texRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy) 二维非投影深度比较并使用导数的矩形纹理查询（OpenGL独有）</li><li>texRECT proj(samplerRECT tex, float3 sq) 二维投影矩形纹理查询（OpenGL独有）</li><li>texRECT proj(samplerRECT tex, float3 szq) 二维投影矩形纹理深度比较查询（OpenGL独有）</li><li>Tex3D(sampler3D tex, float s) 三维纹理查询</li><li>Tex3D(sampler3D tex, float3 s, float3 dsdx, float3 dsdy) 结合导数值（derivatives）查询三维纹理</li><li>Tex3Dproj(sampler3D tex, float4 szq) 查询三维投影纹理，并进行深度值比较</li><li>texCUBE(samplerCUBE tex, float3 s) 查询立方体纹理</li><li>texCUBE (samplerCUBE tex, float3 s, float3 dsdx, float3 dsdy) 结合导数值（derivatives）查询立方体纹理</li><li>texCUBEproj (samplerCUBE tex, float4 sq) 查询投影立方体纹理</li></ol>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— Shader入门，光照</title>
      <link href="/posts/233dac0e.html"/>
      <url>/posts/233dac0e.html</url>
      
        <content type="html"><![CDATA[<h1 id="UnityShader入门——光照"><a href="#UnityShader入门——光照" class="headerlink" title="UnityShader入门——光照"></a>UnityShader入门——光照</h1><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>所有的Shader效果图应该以Game窗口为准，Scene窗口很容易出现问题</p><h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030105807.png" alt="image-20241030105801988" style="zoom:67%;" /><p>技术点：BRDF光照模型：次时代渲染，SSS材质：和次表面相关</p><h2 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h2><p>自发光，高光反射，漫反射，环境光</p><h3 id="自发光"><a href="#自发光" class="headerlink" title="自发光"></a>自发光</h3><p>物体在摄像机里看起来更亮，在Unity的常规使用中，不对周五其他物体产生影响</p><h3 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h3><h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h4><p>blinn——phong的 实现效果比较好</p><h4 id="Phong模型"><a href="#Phong模型" class="headerlink" title="Phong模型"></a>Phong模型</h4><p>推导过程</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030143456.png" alt="image-20241030142434006" style="zoom:67%;" /><p>高光反射公式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高光反射颜色 = 入射颜色 * 高光颜色 * max（<span class="number">0</span>，（<span class="number">2</span>（n * l）n - l）v）^光泽度</span><br></pre></td></tr></table></figure><p>字母代表向量</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>知识：Unity的Reflect（）方法可以计算入射光线的反射角度，但是使用的是常规物理画图的表达方式，入射光线方向朝着镜面，而Unity的光源方向和这个相反，因此要取一个 负值</p><p>注意：在之前的计算中，错误的使用了，该方法实际上返回的是一个向量，而在phong的计算过程中，需要用到的是点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transforms direction from object to world space</span></span><br><span class="line"><span class="keyword">inline</span> float3 <span class="title function_">UnityObjectToWorldDir</span><span class="params">( in float3 dir )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> normalize(mul((float3x3)unity_ObjectToWorld, dir));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">    Shader <span class="string">&quot;Unlit/Phong&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Diffse(<span class="string">&quot;Diff&quot;</span>,color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>,color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>,Range(<span class="number">1</span>,<span class="number">256</span>)) = <span class="number">20</span> </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">             <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc &quot;</span></span></span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 wordNormal: TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _Diffse;</span><br><span class="line">            float4 _Specular;</span><br><span class="line">            <span class="type">int</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(appdata_base v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.wordNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float3 environmentLightColor = UNITY_LIGHTMODEL_AMBIENT.xyz; </span><br><span class="line">                float3 lightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                float3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                float3 reflectDir = normalize(reflect(- lightDir,i.wordNormal)); <span class="comment">//使用该方法求解出射光线注意 负值</span></span><br><span class="line">                float3 phong = _LightColor0.rgb * _Specular.rbg * <span class="built_in">pow</span>(max(<span class="number">0</span>,dot(viewDir,reflectDir)),_Gloss);</span><br><span class="line">                float3 resColor = environmentLightColor + phong;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                float4 col = float4(resColor,<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030193437.png" alt="image-20241030193432018" style="zoom:67%;" /><h4 id="Blinn—phong模型"><a href="#Blinn—phong模型" class="headerlink" title="Blinn—phong模型"></a>Blinn—phong模型</h4><p>推导过程</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030144448.png" alt="image-20241030144440831" style="zoom:67%;" /><p>在该光照模型中，引入 半角向量 这一概念，该向量是l 和v 的中间向量，（角度的一半或者 （l + v）&#x2F;2；</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>在实际中，使用的向量都进行了归一化操作，从而使得半角向量就是入射光线 + 视角</p><p>在片元着色器中操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 halfView = normalize(_WorldSpaceCameraPos + _WorldSpaceLightPos0);</span><br><span class="line">float3 phong = _LightColor0.rgb * _Specular * <span class="built_in">pow</span>(max(<span class="number">0</span>,dot(i.wordNormal,halfView)),_Gloss);</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241031084750.png" alt="image-20241031084739812" style="zoom:67%;" /><h4 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过给定的方法计算视线向量，返回后需要手动归一化</span></span><br><span class="line"><span class="keyword">inline</span> float3 <span class="title function_">UnityWorldSpaceViewDir</span><span class="params">( in float3 worldPos )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _WorldSpaceCameraPos.xyz - worldPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算世界坐标下的灯光向量</span></span><br><span class="line"><span class="comment">// Computes world space light direction, from world space position</span></span><br><span class="line"><span class="keyword">inline</span> float3 <span class="title function_">UnityWorldSpaceLightDir</span><span class="params">( in float3 worldPos )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> USING_LIGHT_MULTI_COMPILE</span></span><br><span class="line">        <span class="keyword">return</span> _WorldSpaceLightPos0.xyz - worldPos * _WorldSpaceLightPos0.w;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifndef</span> USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">        <span class="keyword">return</span> _WorldSpaceLightPos0.xyz - worldPos;</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> _WorldSpaceLightPos0.xyz;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>根据入射光线角度的不用，可以分为三种情况</p><p>条件准备 入射光线和入射点法线的夹角为a，a不是钝角</p><p>a是锐角的情况：漫反射光从入射点法线相对入射光线的那一层射出</p><p>a是直角：从入射点向四周发散</p><p>a是平角：没有漫反射光</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030143504.png" alt="image-20241030112349086" style="zoom:67%;" /><p>影响漫反射光的角度计算，向量点乘</p><p>相关链接</p><p><a href="https://mao1mao2mao3mao4.github.io/posts/b6499ec4.html">Unity——Shader实现边缘发光效果 | mao的博客 (mao1mao2mao3mao4.github.io)</a></p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>漫反射颜色计算</p><p>漫反射颜色 &#x3D; （入射光线颜色 * 反射面光滑度  ) * max(0，dot (n ,l));</p><p>最终颜色计算</p><p>Lambert 光照模型公式: 最终颜色 &#x3D; 直射光颜色 * 漫反射颜色 * max(0, dot(光源方向, 法线方向))</p><p>其中，直射光颜色，漫反射颜色，都是我们自定义的变量。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>知识：点乘需要放在同一个坐标系下才有效</p><h5 id="顶点漫反射"><a href="#顶点漫反射" class="headerlink" title="顶点漫反射"></a>顶点漫反射</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/Lambert&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Diffse(<span class="string">&quot;Color&quot;</span>,color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">             <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc &quot;</span></span></span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 color : color;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _Diffse;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata_base v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                float3 environmentLightColor = UNITY_LIGHTMODEL_AMBIENT.xyz; </span><br><span class="line">                float3 wordNormal = <span class="built_in">UnityObjectToWorldNormal</span>(v.normal);</span><br><span class="line">                float3 lightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos<span class="number">0.</span>xyz);</span><br><span class="line">                <span class="built_in">normalize</span>(lightDir);</span><br><span class="line">                </span><br><span class="line">                o.color = _LightColor<span class="number">0.</span>rgb * _Diffse.rgb  * <span class="built_in">saturate</span>(<span class="built_in">dot</span>(wordNormal,lightDir)) + environmentLightColor;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                float4 col = <span class="built_in">float4</span>(i.color,<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030170639.png" alt="image-20241030170631794" style="zoom:67%;" /><h5 id="片元漫反射"><a href="#片元漫反射" class="headerlink" title="片元漫反射"></a>片元漫反射</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/Lambert&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Diffse(<span class="string">&quot;Color&quot;</span>,color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"> </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">             <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityLightingCommon.cginc &quot;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">          </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 wordNormal: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _Diffse;</span><br><span class="line"> </span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata_base v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"> </span><br><span class="line">                o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">                o.wordNormal = <span class="built_in">UnityObjectToWorldNormal</span>(v.normal);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                float3 environmentLightColor = UNITY_LIGHTMODEL_AMBIENT.xyz; </span><br><span class="line">                float3 lightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos<span class="number">0.</span>xyz);</span><br><span class="line">                <span class="built_in">normalize</span>(lightDir);</span><br><span class="line">                float3 resColor = _LightColor<span class="number">0.</span>rgb * _Diffse.rgb  * <span class="built_in">saturate</span>(<span class="built_in">dot</span>(i.wordNormal,lightDir)) + environmentLightColor;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                float4 col = <span class="built_in">float4</span>(resColor,<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030171156.png" alt="image-20241030171143605" style="zoom:67%;" /><h6 id="半兰伯特漫反射"><a href="#半兰伯特漫反射" class="headerlink" title="半兰伯特漫反射"></a>半兰伯特漫反射</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 resColor = _LightColor0.rgb * _Diffse.rgb  * (dot(i.wordNormal,lightDir)*<span class="number">0.5</span> + <span class="number">0.5</span>)+ environmentLightColor;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将原来的值大小限制直接通过计算归纳到0到1的范围内</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030172353.png" alt="image-20241030172345288" style="zoom:67%;" /><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p>例子：红苹果放在一张白纸旁边，白纸有点微红，描述的是间接光照</p><h1 id="纹理采样"><a href="#纹理采样" class="headerlink" title="纹理采样"></a>纹理采样</h1><p>属性块中的属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241031144256.png" alt="image-20241031144245470" style="zoom:80%;" /><p>使用的时候需要设置这两个属性，第二个是第一个的从属，第一个有就默认有第二个，里面保存的是贴图的缩放和位移，分别可以用 xy 和 zw 来进行表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;<span class="comment">//从属于上一个变量</span></span><br></pre></td></tr></table></figure><p>实现后相较于常规的着色器添加的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v2f结构体中的加入元素</span></span><br><span class="line">float2 uv: TEXCOORD0;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器中的新内容</span></span><br><span class="line">o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"><span class="comment">//O.UV = TRANSFORM_TEX(v.texcoord,_MainTex);//Unity官方提供的转换方法，但是在使用的过程中还要定义两个属性</span></span><br><span class="line"><span class="comment">//片元着色器中的新内容</span></span><br><span class="line"> float3 albedo = tex2D(_MainTex,i.uv).rbg;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：如果在片元着色器中存在光照模型，需要将  albedo 乘到 漫反射中。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241031144956.png" alt="image-20241031144952134"></p><h1 id="图片设置"><a href="#图片设置" class="headerlink" title="图片设置"></a>图片设置</h1><p>知乎上有一篇写的很好的，这里给出链接</p><p><a href="https://zhuanlan.zhihu.com/p/349481721">纹理滤波，Mipmaps，Unity中图片的导入设置 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— UnityShader介绍</title>
      <link href="/posts/798e1f8c.html"/>
      <url>/posts/798e1f8c.html</url>
      
        <content type="html"><![CDATA[<h1 id="UnityShader介绍"><a href="#UnityShader介绍" class="headerlink" title="UnityShader介绍"></a>UnityShader介绍</h1><h2 id="UnityShader种类"><a href="#UnityShader种类" class="headerlink" title="UnityShader种类"></a>UnityShader种类</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212345.png" alt="image-20241029151254874"></p><p>Unity Surface Shader，Unity将顶点和片元Shader进行一个封装</p><p>Unlit Shader，标准的顶点和片元Shader</p><p>Image Effect Shader，图片特效Shader</p><p>Compute Shader，暂时用不到</p><p>Shader Variant Collection，Shader库文件</p><h2 id="UnityShader和传统Shader的不同"><a href="#UnityShader和传统Shader的不同" class="headerlink" title="UnityShader和传统Shader的不同"></a>UnityShader和传统Shader的不同</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212348.png" alt="image-20241029151926386"></p><h1 id="UnityShader属性块"><a href="#UnityShader属性块" class="headerlink" title="UnityShader属性块"></a>UnityShader属性块</h1><p>Properties：相当于编程语言中属性的定义，这里只是有一个比喻</p><p>SubShader</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>下图是Properties中可以使用的参数以及在Unity可视化操作的窗口样子</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212352.png" alt="image-20241029153854930"  /><p>下图是上图中的效果在Shader中的代码</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212354.png" alt="image-20241029153916870"></p><p>最后两个参数其实并不常用，cude是一个天空盒，3D是3D贴图</p><h2 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h2><p>Properties中的属性要在该属性块中使用，属性名需要相同，比如：_MainTex，其次也可以通过C#语言来获取到Shader后再去传递值</p><p>Unity会在Shader找到并运行第一个能在发布平台运行的SubShader，如果都不能运行，Unity自动调用fallBack</p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212356.png" alt="image-20241029162707045"></p><p>正常情况下不不建议使用多个Pass通道，但是要实现特别效果还是要的</p><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>常用Tag的介绍</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212358.png" alt="image-20241029164021295" style="zoom:80%;" /><p>RenderType标识Shader采用的渲染队列类型，方便程序化识别</p><p>提示，pass对于Tags的使用采取的是就原则，写在SubShader最上面，该Shader的Pass全部使用Tags，里外都有用外的</p><h3 id="Render设置"><a href="#Render设置" class="headerlink" title="Render设置"></a>Render设置</h3><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212400.png" alt="image-20241029164904767" style="zoom:80%;" /><h3 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h3><p>shader头文件的引入可以从Unity官网找到自己Unity对应的下载选项，选择bulid in shader</p><p>可以根据Pass通道的Name来指定使用特定通道，不过在use的时候 Pass的Name要全大写，命名的时候没限制</p><p>在Pass内写的Tags常用的属性</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212401.png" alt="image-20241029170531680"></p><p>第二参数是要使用该Pass通道要满足的条件，可以有多个选项，中间用空格隔开</p><h3 id="CGPROGRAM-ENDCG"><a href="#CGPROGRAM-ENDCG" class="headerlink" title="CGPROGRAM ENDCG"></a>CGPROGRAM ENDCG</h3><p>中间包裹起来的是顶点着色器和片元着色器</p><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212403.png" alt="image-20241029171201816"></p><h1 id="SurfaceShader"><a href="#SurfaceShader" class="headerlink" title="SurfaceShader"></a>SurfaceShader</h1><p>Unity封装了一层，功能复杂</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Unity Shader实际上指的就是一个ShaderLab文件。以.shader作为后缀的一种文件。在Unity shader里面，我们可以做的事情远多于一个传统意义上的Shader。</p><p>​    在传统的shader中，我们仅可以编写特定类型的Shader，例如顶点着色器，片元着色器等。在Unity Shader中，我们可以在同一个文件里面同时包含需要的顶点着色器和片元着色器代码。</p><p>​    在传统shader中，我们无法设置一些渲染设置，例如是否开启混合，深度测试等，这些是开发者在另外的代码中自行设置的。而Unity shader中，我们通过一行特定的指令就可以完成这些设置。</p><p>​    在传统shader中，我们需要编写冗长的代码设置着色器的输入和输出，要小心的处理这些输入输出的位置对应关系等。而在Unity shader中，我们只需要在特定语句块中声明一些属性，就可以依靠材质来方便的改变这些属性。而对于模型自带的数据（如顶点，纹理坐标，法线等），Unity Shader也提供了直接访问的方法，不需要开发者自行编码来传给着色器。</p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— Shader基础</title>
      <link href="/posts/6df7cc6d.html"/>
      <url>/posts/6df7cc6d.html</url>
      
        <content type="html"><![CDATA[<h1 id="UnityShader基础"><a href="#UnityShader基础" class="headerlink" title="UnityShader基础"></a>UnityShader基础</h1><h2 id="最简单的Shader"><a href="#最简单的Shader" class="headerlink" title="最简单的Shader"></a>最简单的Shader</h2><p>设置模型的颜色为白色</p><p>​<img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212453.png" alt="image-20241029180920202" style="zoom:80%;" /></p><h2 id="输入结构体"><a href="#输入结构体" class="headerlink" title="输入结构体"></a>输入结构体</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212458.png" alt="image-20241029182310609" style="zoom:80%;" /><p>按照给定的名字进行使用，Unity会自动为结构体填充内容，texcoord使用 0 ，是大家公认的第一套UV；</p><p>对结构体名字的解释</p><p>a：application，即从渲染流中通过Unity自动添加的</p><p>2：即 to 的谐音，</p><p>v：vertex，代表顶点着色器</p><p>最后意思是从程序中输入到顶点着色器中的结构体</p><h2 id="输出结构体"><a href="#输出结构体" class="headerlink" title="输出结构体"></a>输出结构体</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212500.png" alt="image-20241029183838169"></p><h2 id="属性控制"><a href="#属性控制" class="headerlink" title="属性控制"></a>属性控制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_Color(<span class="string">&quot;Color&quot;</span>,Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//在属性块中的属性</span></span><br><span class="line">       </span><br><span class="line">fixed4 _Color;<span class="comment">//要想在SubShader中使用以上属性就需要在CGPROGRAM按照当前格式定义，名字必须相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于 _Color在着色器中的访问，可以使用xyzw或者rgba，来抽取当中的色彩块</span></span><br></pre></td></tr></table></figure><h2 id="库自带输入输出结构体"><a href="#库自带输入输出结构体" class="headerlink" title="库自带输入输出结构体"></a>库自带输入输出结构体</h2><p>在UnityCG.cginc库文件中，有官方已经实现的输入结构和部分输出结构，使用的时候使用C++的头文件导入形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;UnityCg.cginc&quot;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">appdata</span> full&#123;</span><br><span class="line">float4 vertex:POSITION;<span class="comment">//顶点</span></span><br><span class="line">float4tangknt :TANGENT;<span class="comment">//切线</span></span><br><span class="line">float3 normal:NORMAL;<span class="comment">//法线</span></span><br><span class="line">float4 texcoord :TEXCOORD0;</span><br><span class="line">float4 texcoord1 :TEXCOORD1;</span><br><span class="line">float4 texcoord2 :TEXCOORD2;</span><br><span class="line">float4 texcoord3 :TEXCOORD3;</span><br><span class="line">fixed4 color :COLOR;</span><br><span class="line">UNITY_VERTEX_INPUT_INSTANCE </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="着色器语意"><a href="#着色器语意" class="headerlink" title="着色器语意"></a>着色器语意</h2><p>顶点着色器输入结构中的常见语义</p><table><thead><tr><th><strong>语义</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>POSITION</td><td>模型空间中的顶点位置，通常是float4类型</td></tr><tr><td>NORMAL</td><td>顶点法线，通常是float3类型</td></tr><tr><td>TANGENT</td><td>顶点切线，通常是float4类型</td></tr><tr><td>TEXCOORDn,如TEXCOORD0,TEXCOORD1</td><td>该顶点的纹理坐标，TEXCOORD0表示第一组坐标纹理，依次类推，通常是float2,float4类型</td></tr><tr><td>COLOR</td><td>顶点颜色，通常是fixed4或float4类型</td></tr></tbody></table><p>简单介绍各个版本Shader中对于TEXCOORD的支持数量</p><table><thead><tr><th>Shader  Model版本</th><th>TEXCOORDn中N的支持个数</th></tr></thead><tbody><tr><td>Shader  Model2</td><td>8</td></tr><tr><td>Shader  Model3</td><td>8</td></tr><tr><td>Shader  Model4</td><td>16</td></tr><tr><td>Shader  Model5</td><td>16</td></tr></tbody></table><p>顶点着色器输出结构体中常用语义</p><table><thead><tr><th><strong>语义</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>SV_POSITION</td><td>裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。等同于DX9中的POSITION。</td></tr><tr><td>COLOR0</td><td>通常用于输出第一组顶点颜色，不是必须</td></tr><tr><td>COLOR1</td><td>通常用于输出第二组顶点颜色，不是必须</td></tr><tr><td>TEXCOORD0-TEXCOORD7</td><td>通常用于输出纹理坐标，不是必须</td></tr></tbody></table><p>片元着色器输出时的常见语义</p><table><thead><tr><th><strong>语义</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>SV_Target</td><td>输出值将会储存到渲染目标（render  target）中。等同于DX9中COLOR语义。</td></tr></tbody></table><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>颜色测试输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v2f o;</span><br><span class="line">o.pos = <span class="built_in">UnityObjectToclipPos</span>(v.vertex);</span><br><span class="line"><span class="comment">//法线</span></span><br><span class="line"><span class="comment">//法线的范围在（-1,1）之间，需要规范到颜色的（0,1） 的区间内</span></span><br><span class="line">o.color =v.normal*<span class="number">0.5</span> +<span class="built_in">fixed3</span>(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line"><span class="comment">//切线</span></span><br><span class="line">o.color =v.tangent.xyz*<span class="number">0.5</span> + <span class="built_in">fixed3</span>(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line"><span class="comment">//UV</span></span><br><span class="line">o.color =<span class="built_in">fixed4</span>( v.texcoord.xy,<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>FrameDebug</p><p>在Unity的windows工具类中，在性能分析那一栏，选中可以使用Frame Debug对Shader的每个阶段进行排查测试</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030095919.png" alt="image-20241030095855290"></p><p>第三方工具：Inter Gpa , Snapdragon Profiler等</p><h2 id="平台差异"><a href="#平台差异" class="headerlink" title="平台差异"></a>平台差异</h2><h3 id="抗锯齿下的手动翻转"><a href="#抗锯齿下的手动翻转" class="headerlink" title="抗锯齿下的手动翻转"></a>抗锯齿下的手动翻转</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030100744.png" alt="image-20241030100740037"></p><p>开启Anti Aliasing，并且同时处理多张渲染图像是，DX平台需要翻转</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030100800.png" alt="image-20241030100757192"></p><p>UNITY_UV_STARTS_AT_TOP判断当前平台是否是DX平台，使用_MainTex_TexelSize.y&lt;0来判断是否开启了抗锯齿。</p><p>知识补充：开启Anti Aliasing 抗锯齿可以通过项目设置的质量进入</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241030102508.png" alt="image-20241030102501291" style="zoom:67%;" /><h3 id="不同图形接口的数据初始化"><a href="#不同图形接口的数据初始化" class="headerlink" title="不同图形接口的数据初始化"></a>不同图形接口的数据初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 v= <span class="built_in">float4</span>(<span class="number">0</span>);<span class="comment">//OpenGL</span></span><br><span class="line">float4 v=<span class="built_in">float4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//DX，DX的初始化更严格</span></span><br></pre></td></tr></table></figure><h3 id="表面着色器中初始化"><a href="#表面着色器中初始化" class="headerlink" title="表面着色器中初始化"></a>表面着色器中初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNITY_INITIALIZE_OUTPUT</span>(Input,o);</span><br></pre></td></tr></table></figure><h2 id="Cg数据类型"><a href="#Cg数据类型" class="headerlink" title="Cg数据类型"></a>Cg数据类型</h2><h3 id="1，基本数据类型：Cg支持7种基本的数据类型，分别是："><a href="#1，基本数据类型：Cg支持7种基本的数据类型，分别是：" class="headerlink" title="1，基本数据类型：Cg支持7种基本的数据类型，分别是："></a>1，基本数据类型：Cg支持7种基本的数据类型，分别是：</h3><p>float， 32 位浮点数据，一个符号位。浮点数据类型被所有的 profile 支持</p><p>half，16 为浮点数据</p><p>int，32 位整形数据，有些 profile 会将 int 类型作为 float 类型使用</p><p>fixed，12 位定点数，被所有的 fragment profiles 所支持</p><p>bool，布尔数据，通常用于 if 和条件操作符（ ?: ） ，布尔数据类型被所有的profiles 支持</p><p>simpler*， 纹理对象的句柄（ the handle to a texture object ） ，分为 6 类：</p><p>sampler, sampler1D, sampler2D, sampler3D, samplerCUBE, 和 samplerRECT 。DirectX profiles 不支持 samplerRECT 类型， 除此之外这些类型被所有的 pixelprofiles 和 NV40 vertex program profile 所支持（ CgUsersManual 30 页） 。由此可见，在不远的未来，顶点程序也将广泛支持纹理操作</p><p>string，字符类型，该类型不被当前存在的 profile 所支持，实际上也没有必要在 Cg 程序中用到字符类型，但是你可以通过 Cg runtime API 声明该类型变量，并赋值；因此，该类型变量可以保存 Cg 文件的信息。</p><p>​    前6种类型为常用类型，string类型几乎不使用。此外，Cg还提供了内置的向量数据类型 (built-in vector data types) ，内置的向量数据类型基于基础数据类型。 例如： float4， 表示 float 类型的 4 元向量； bool4， 表示 bool类型 4 元向量。</p><p>不同类型的浮点数在pc上最终被改变为float进行计算，而移动端上的fix又是一个古老的东西，现在基本不使用，因此在编写的时候时候围绕 half 和 float 进行曹组就可以了</p><h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h3><p>数组数据类型在Cg中的作用：作为函数的形参，用于大量数据的传递，例如：顶点参数数组、光照参数数据等。</p><p>   一维数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a[<span class="number">10</span>];<span class="comment">//声明了一个数组，包含 10 个 float 类型数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a[<span class="number">4</span>] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;; <span class="comment">//初始化一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> length = a.length;<span class="comment">//获取数组长度</span></span><br></pre></td></tr></table></figure><p>  多维数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> b[<span class="number">2</span>] [<span class="number">3</span>] = &#123;&#123;<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>&#125;,&#123;<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> length1 = b.length; <span class="comment">// length1 值为 2</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> length2 = b[<span class="number">0</span>].length; <span class="comment">// length2 值为 3</span></span><br></pre></td></tr></table></figure><h3 id="3-结构体"><a href="#3-结构体" class="headerlink" title="3,结构体"></a>3,结构体</h3><p>结构体的声明以关键字 struct 开始，然后紧跟结构体的名字，接下来是一个大括号，并以分号结尾（不要忘了分号） 。大括号中是结构体的定义，分为两大类：成员变量和成员函数。</p><h2 id="Unity支持的Shader-Target"><a href="#Unity支持的Shader-Target" class="headerlink" title="Unity支持的Shader Target"></a>Unity支持的Shader Target</h2><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>#pragma  target 2.0</td><td>相当于D3D9上的Shader  Model2.0,不支持顶点纹理采样，不支持显示的LOD纹理采样</td></tr><tr><td>#pragma  target 3.0</td><td>相当于D3D9上的Shader  Model3.0 支持顶点纹理采样</td></tr><tr><td>#pragma  target 4.0</td><td>相当于 D3D10上的Shader  Model4.0支持几何着色器</td></tr><tr><td>#pragma  target 5.0</td><td>相当于D3D11上的Shader  Model5.0</td></tr></tbody></table><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>尽量少用if else，分支中指令尽量少</p><p>GPU并行运行的特性，ifelse中的每个分支都会运行一次，但是最终有些没用上，浪费资源</p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— 渲染知识入门</title>
      <link href="/posts/2744d240.html"/>
      <url>/posts/2744d240.html</url>
      
        <content type="html"><![CDATA[<h1 id="图形接口"><a href="#图形接口" class="headerlink" title="图形接口"></a>图形接口</h1><p>Opengl和DirectX</p><p>UnityShader所使用的是CG语言，CG语言在OpenGl和DirectX之上</p><h1 id="渲染流水"><a href="#渲染流水" class="headerlink" title="渲染流水"></a>渲染流水</h1><p>普遍的渲染管线的流程：</p><p>下图是基本描述</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212116.png" alt="image-20241029143955055" style="zoom:67%;" /><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212118.png" alt="image-20241029161109518"></p><h2 id="应用阶段："><a href="#应用阶段：" class="headerlink" title="应用阶段："></a>应用阶段：</h2><p>1.把数据加载到显存中<br>2，设置渲染状态<br>3，调用DrawCall</p><h3 id="把数据加载到内存中做的事情"><a href="#把数据加载到内存中做的事情" class="headerlink" title="把数据加载到内存中做的事情"></a>把数据加载到内存中做的事情</h3><p>数据会从硬盘到内存再到显存，一般加载到显存中的数据都会被从内存中移除</p><h3 id="设置渲染状态做的事情"><a href="#设置渲染状态做的事情" class="headerlink" title="设置渲染状态做的事情"></a>设置渲染状态做的事情</h3><p>这些状态定义了场景中的网格是如何被渲染的，例如，使用哪个定点着色器，片元着色器，光照，材质等</p><h3 id="调用DrawCall"><a href="#调用DrawCall" class="headerlink" title="调用DrawCall"></a>调用DrawCall</h3><p>Drawcall是一个命令，CPU发起，GPU接收，不包含任何材质信息，仅仅指向需要被渲染的图源列表<br>（Unity中存在的DrawCall优化，GPUInstance，这里仅仅是发音比较像，剩余的需要自己去查找）</p><h2 id="几何阶段和光栅化阶段"><a href="#几何阶段和光栅化阶段" class="headerlink" title="几何阶段和光栅化阶段"></a>几何阶段和光栅化阶段</h2><p>两个阶段能被开发者使用代码控制的不多，具体可见ppt中对应的内容</p><h3 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h3><p>定点着色器，曲面细分着色器，几何着色器，裁剪，屏幕映射</p><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>处理单位是定点，每个定点都会调用一次定点着色器</p><h4 id="空间转换"><a href="#空间转换" class="headerlink" title="空间转换"></a>空间转换</h4><p>模型空间-》齐次裁剪空间-》计算顶点颜色<br>o.vertex &#x3D; mul(UNITY_MVP，v.vertex); &#x2F;&#x2F;Unity5.x<br>o.vertex &#x3D; UnityObjectToClipPos(v.vertex); &#x2F;&#x2F;Unity2017 及其以上</p><h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><p>一个图元与摄像机的关系有三种，内，外，部分内</p><p>屏幕映射<br>任务是将裁剪后的齐次坐标（HDC）转化到屏幕坐标系，屏幕坐标系是一个二维坐标系<br>（OpenGl左下角是零点，DX左上角是零点）</p><h3 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h3><h4 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h4><p>三角形设置，三角形遍历，片元着色器，逐片元操作 </p><h4 id="三角形设置"><a href="#三角形设置" class="headerlink" title="三角形设置"></a>三角形设置</h4><p>这个阶段会计算光栅化一个三角网格所需要的信息。上一个阶段输出的都是三角网格的顶点，即我们得到的是三角网格每条边的两个端点。如果要得到正规三角网格对像素的覆盖情况，就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，就需要得到三角形边界的表示方式。</p><h4 id="三角形遍历"><a href="#三角形遍历" class="headerlink" title="三角形遍历"></a>三角形遍历</h4><p>​    <strong>三角形遍历</strong> 阶段将会检查每个像素是否被一个三角网格所覆盖。如果被覆盖的情况下，就会产生一个<strong>片元</strong>。而这样一个找到那些像素被三角网格覆盖的过程就叫做三角形遍历，也被称作<strong>扫描变换</strong>。</p><p>​    三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行插值。</p><h4 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h4><p><strong>片元着色器</strong>的输入是上一个阶段对顶点信息插值得到的结果，具体来说是根据那些从顶点着色器中输出的数据插值得到的。而其输出是一个或者多个颜色值。</p><p>​    这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是纹理采样。为了在片元着色器中进行纹理采样，我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理坐标进行插值后，就可以得到起覆盖的片元的纹理坐标</p><h4 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h4><p><strong>逐片元操作</strong>是OpenGL中的说法，在DX中这个阶段被称作<strong>输出合并阶段</strong>。</p><p>（1）决定每个片元的可见性，涉及很多测试工作，例如深度测试，模板测试。</p><p> （2）如果一个片元通过了所有测试后，就需要把这个片元的颜色值和已经储存在颜色缓冲区的色彩进行合并，或者说混合</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212123.png" alt="image-20241029144526686"></p><p>​     测试的过程实际上是个比较复杂的过程，而且不同的图形接口（OpenGL和DX）的实现细节也不尽相同。</p><h5 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h5><p>与之相关的是模板缓冲（Stencil Buffer）。模板缓冲和颜色缓冲，深度缓冲几乎是一类东西。如果开启了模板测试，Gpu首先读取（使用读取掩码）模板缓冲区中该片元位置的模板值，然后将该值和读取（使用读取掩码）到的参考值进行比较，这个比较函数可以由开发者指定的，例如小于等于舍弃该片元，或者大于等于舍弃该片元。如果这个片元没有通过测试，该片元就会被舍弃。不管一个片元有没有通过模板测试，我们都可以根据模板测试和之后的深度测试结果来修改模板缓冲区，这个操作也是由开发者指定的。模板测试通常用于限制渲染区域，或者渲染阴影，轮廓渲染等</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212124.png" alt="image-20241029144347791" style="zoom: 80%;" /><h5 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h5><p>如果开启了<strong>深度测试</strong>，Gpu会把该片元的深度值和已经存在于深度缓冲中的深度值进行比较。这个比较函数也是可由开发者设置的，例如小于时舍弃该片元，或者大于时舍弃该片元。通常这个比较函数是小于等于，即如果这个片元的深度大于等于当前深度缓冲区中的值，那么就舍弃它。这是因为我们总想只显示出离摄像机最近的物体，而那些被其他物体遮挡的就不需要出现在屏幕上。和模板测试不同的是，如果一个片元没有通过深度测试，它就没有权利更改深度缓冲区的值。如果一个片元通过了测试，那么开发者可以指定是否要用这个片元的深度值覆盖所有的深度值</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212126.png" alt="image-20241029144429455" style="zoom:80%;" /><h5 id="合并混合"><a href="#合并混合" class="headerlink" title="合并混合"></a>合并混合</h5><p><strong>合并</strong> ，渲染过程是一个物体接着一个物体画到屏幕上，而每个像素的颜色信息被储存在一个名为颜色缓冲的地方。因此，当我们执行这次渲染时，颜色缓冲中往往已经有了上次渲染之后的颜色结果，那么，我们使用这次渲染得到的颜色完全覆盖掉之前的结果还是进行其他处理，就是合并需要解决的。</p><p>对于不透明物体，开发者可以关闭混合（Blend）操作。这样片元着色器计算得到的颜色值就会之间覆盖掉颜色缓冲区中的像素值。但对于半透明物体，就需要混合操作来让这个物体看起来是透明的。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212129.png" alt="image-20241029145045268"></p><h5 id="测试总结"><a href="#测试总结" class="headerlink" title="测试总结"></a>测试总结</h5><p><strong>各种测试</strong>的顺序并不是唯一的，虽然从逻辑上来说这些测试是在片元着色器之后进行的，但对于大多数GPU来说，会尽可能在执行片元着色器之前进行这些测试。因为当你在片元着色器进行了大量的计算及设置，最后测试没通过，可以说是计算成本全都浪费了。作为一个想充分提高速度的GPU，肯定是希望尽可能早的指定哪些片元会被舍弃，对这些片元就不再需要在使用片元着色器来计算他们的颜色。Unity的渲染流水中，深度测试就是在片元着色器之前。</p><p>   但是，如果将这些测试提前的话，其检验结果可能会与片元着色器中的一些操作冲突。例如片元着色器在进行透明度测试，而这个片元没有通过透明度测试，我们会在着色器中调用API(clip)函数来手动将其舍弃。这就导致GPU无法提前执行各种测试。因此，如果片元着色器中的操作和提前测试发生冲突就会禁用提前测试。这样性能上就会下降，也是透明度测试导致性能下降的原因。</p><p>​    当模型图元经过层层计算及测试后，就会显示到屏幕上。我们的屏幕显示的就是颜色缓冲区中的颜色值。但是，为了避免我们看到正在光栅化的图元，GPU会使用<strong>双重缓冲</strong>策略。对场景的渲染是发生在幕后的，即在<strong>后置缓冲</strong>中，一旦场景已经被渲染到后置缓冲中，GPU就会交换后置缓冲区和<strong>前置缓冲</strong>的内容，前置缓冲区就是显示在屏幕上的图像。由此，保证我们看到的图像是连续的。</p><h1 id="附加知识"><a href="#附加知识" class="headerlink" title="附加知识"></a>附加知识</h1><h2 id="1，CPU与GPU如何并行工作？"><a href="#1，CPU与GPU如何并行工作？" class="headerlink" title="1，CPU与GPU如何并行工作？"></a>1，CPU与GPU如何并行工作？</h2><p>​    我们之前看到的是一个流水线式的模式，如果需要CPU和GPU并行工作，就需要使用<strong>命令缓冲区（<strong><strong>Command Buffer</strong></strong>）。</strong></p><p>​    命令缓冲区包含了一个缓冲队列，由Cpu向其中添加命令，而由Gpu从中读取命令，添加和读取过程是相互独立的。命令缓冲区使得Cpu和Gpu可以相互独立工作。当Gpu需要渲染一些对象时，它就可以从命令队列中取出一个命令并执行。</p><p>​    命令缓冲区有很多种类，Draw Call就是一种。其他命令还有改变渲染状态等。</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241029212131.png" alt="image-20241029150329421" style="zoom: 80%;" /><h2 id="2，什么是固定管线渲染？"><a href="#2，什么是固定管线渲染？" class="headerlink" title="2，什么是固定管线渲染？"></a>2，什么是固定管线渲染？</h2><p>  固定函数的流水线（Fixed-Function Pipeline），简称固定管线，通常是指在较旧的Gpu上实现的渲染流水线。这种流水线只给开发者提供一些配置操作，但开发者没有对流水线阶段的完全控制权。</p><p>​    在Unity中目前的固定管线shader都会自动编译顶点片元shader。</p><h2 id="3，什么是Shader"><a href="#3，什么是Shader" class="headerlink" title="3，什么是Shader?"></a>3，什么是Shader?</h2><p> Gpu流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码是会在Gpu上运行的；</p><p> 有一些特定类型的着色器，如顶点着色器，片元着色器等。</p><p> 依靠着色器我们可以控制流水线中的渲染细节，例如用顶点着色器来进行顶点变换及传递数据，用片元着色器来进行逐像素渲染。</p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity——Shader实现边缘发光效果</title>
      <link href="/posts/b6499ec4.html"/>
      <url>/posts/b6499ec4.html</url>
      
        <content type="html"><![CDATA[<h1 id="边缘发光效果"><a href="#边缘发光效果" class="headerlink" title="边缘发光效果"></a>边缘发光效果</h1><h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><p>引入模型后需要将模型从自身坐标系先转换到世界坐标系下，然后再转化到摄像机坐标，</p><p>UnityObjectToClipPos，将模型的点从自身的坐标系变换到摄像机坐标系的裁剪空间下</p><p>渲染管线传递给shader的参数提示，</p><p>normal是法线 </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="边缘发光效果，"><a href="#边缘发光效果，" class="headerlink" title="边缘发光效果，"></a>边缘发光效果，</h3><p>前面—》篮球 —》背面黄色:<br>(1)我们的边缘的黄色怎么来的，是把这个球绘制了2次; —&gt;pass 绘制黄色<br>(2)我就面对摄像机的这些面，有重新涂成了黄色;<br>(3)配置我们的渲染队列，修改我们的alpha;<br>(4)发光效果，是不是中间强，边缘弱;找个数学方式，能够做到中间强边缘弱?<br>(5)shader 常用技巧(解题技巧5)</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241028213750.png" alt="image-20241028213739714" style="zoom: 80%;" /><p>工作原理，在将模型的面投影到2D平面之前，会经历一步裁剪操作，默认将背朝摄像机的面裁剪掉，可以使用Cul Fron关键字将背面的模型也给渲染出来，同时适当增大vertex</p><p>具体原理解释</p><p><a href="https://blog.csdn.net/qq_45879862/article/details/129620379">Unity用Shader实现边缘光效果_unity3d shader 边缘光-CSDN博客</a></p><p>对于一些规则的模型，当然可以使用数学计算来获取边缘，但是对于人形就不适用了，为了通用就用这个</p><p>在边缘光的设置上，通过使用 blend SrcAlpha One 可以实现透明的效果</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241028215202.png" alt="image-20241028215156748" style="zoom:67%;" /><p>如果存在透明的要求，需要在Unity的配置界面中，将自定义Shader的渲染队列调整到 Transparent中，仍然使用默认渲染队列会出现透明物体最后是黑色的效果</p><h3 id="边缘强度获取"><a href="#边缘强度获取" class="headerlink" title="边缘强度获取"></a>边缘强度获取</h3><p>点乘：数学概念</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241028220450.png" alt="image-20241028220445402"></p><p>被用来求两个向量之间的夹角</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241028221244.png" alt="image-20241028221240429"></p><p>使用一个点在观察空间下的的坐标和点的法线进行点乘操作，求得两条法线之间的夹角，</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241028221912.png" alt="image-20241028221908793"></p><p>单位化后对应向量的 模 就是 1 ，最后计算夹角的cos值的时候只需要求点乘的结果，因为 1 * 1 &#x3D;1 </p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241028223125.png" alt="image-20241028222653683"></p><p>mul是矩阵乘法，当中的第一个参数是矩阵变换方程</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241028223124.png" alt="image-20241028223120000"></p><p>view_dir变量的计算方程的 的被减速 是Unity提供的 在世界中的相机坐标</p><p><img src="/Unity%E2%80%94%E2%80%94-Shader.assets/image-20241028223355749.png" alt="image-20241028223355749"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241028223608.png" alt="image-20241028223604459"></p><p>但是在实际模型中，一个三角形并不会严格分布在裁剪面的正面或反面，会有跨过线的情况，也就导致了在裁剪面正面的角度 alpha 会小于 0，表现在视觉上边缘黑色，使用三元运算符号就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line">float4 new_vert =v.vertex + <span class="built_in">float4</span>(v,normal, <span class="number">1</span>)* <span class="built_in">float4</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">1</span>).o.vertex = <span class="built_in">UnityObjectToClipPos</span>(<span class="keyword">new</span> vert):O.UV = TRANSFORM <span class="built_in">TEX</span>(v.uv,MainTex);</span><br><span class="line">o.w normal = <span class="built_in">UnityObjectToWorldNormal</span>(v.normal);o.w_vertex=<span class="built_in">mul</span>(unity ObjectToWorld, v.vertex);<span class="comment">//20%</span></span><br><span class="line"><span class="keyword">return</span> o:</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//着色shader 入口;</span></span><br><span class="line">fixed4 <span class="built_in">frag</span>(v2f i):SV Target</span><br><span class="line">&#123;</span><br><span class="line">float3 view dir=i.w vertexWorldSpaceCameraPos;</span><br><span class="line">float3 wnormal=i.w_normal;</span><br><span class="line">view dir=<span class="built_in">normalize</span>(view dir);</span><br><span class="line">w_normal=<span class="built_in">normalize</span>(wnormal);</span><br><span class="line"><span class="type">float</span> value=<span class="built_in">dot</span>(view_dir,wnormal);<span class="comment">//cos(a)[-1,1]</span></span><br><span class="line">value=(value&lt;<span class="number">0</span>)?<span class="number">0</span>:value;</span><br><span class="line">value =<span class="built_in">pow</span>(value,<span class="number">6</span>) * <span class="number">20</span>;<span class="comment">//使用指数效果来让渐变的效果明显,指数太大背面消失，乘上一个数就行了</span></span><br><span class="line">fixed4 col=<span class="built_in">fixed4</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,value);<span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG <span class="comment">// end Cg;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity —— AI</title>
      <link href="/posts/1388458c.html"/>
      <url>/posts/1388458c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Unity学习路线图"><a href="#Unity学习路线图" class="headerlink" title="Unity学习路线图"></a>Unity学习路线图</h1><h2 id="AI-系统"><a href="#AI-系统" class="headerlink" title="AI 系统"></a>AI 系统</h2><p>导航 AI navigation </p><p>有限状态机 FSM</p><p>AI行为树</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity—— HybridCLR，热更新</title>
      <link href="/posts/3f28e95a.html"/>
      <url>/posts/3f28e95a.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/485311523">https://zhuanlan.zhihu.com/p/485311523</a> 入门介绍 ，知乎</p><p><a href="https://hybridclr.doc.code-philosophy.com/docs/other/businesscase">https://hybridclr.doc.code-philosophy.com/docs/other/businesscase</a> 使用文档</p><p><a href="https://code-philosophy.com/">https://code-philosophy.com/</a> 开发商官网</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 1870 准时到达的列车最小时速</title>
      <link href="/posts/364ecb7f.html"/>
      <url>/posts/364ecb7f.html</url>
      
        <content type="html"><![CDATA[<h1 id="1870-准时到达的列车最小时速"><a href="#1870-准时到达的列车最小时速" class="headerlink" title="1870. 准时到达的列车最小时速"></a><a href="https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/">1870. 准时到达的列车最小时速</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241002164437.png" alt="image-20241002162306525" style="zoom:67%;" /><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路来自leetcode的题解</p><p><a href="https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/solutions/791209/bi-mian-fu-dian-yun-suan-de-xie-fa-by-en-9fc6/">1870. 准时到达的列车最小时速 - 力扣（LeetCode）</a></p><p>最直接的收获是浮点数运算的时候会出现误差，下面同样是摘自题解中的解释，</p><p>由于双精度浮点数无法准确表示诸如 2.01 这样的小数，我们在计算 2.01×100 时，算出的结果不是 201，而是 200.99999999999997 这样的数。</p><p>所以代码不能直接转成整数，而是要 round 一下。</p><p>round（）的作用简单来讲就是四舍五入</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSpeedOnTime</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dist, <span class="type">double</span> hour)</span> </span>&#123;</span><br><span class="line"><span class="comment">//准时到达的列车时速</span></span><br><span class="line"><span class="type">int</span> n = dist.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> h100 = <span class="built_in">round</span>(hour * <span class="number">100</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> delta = h100 - (n - <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (delta &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//无法到达终点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max_dist = ranges::<span class="built_in">max</span>(dist);</span><br><span class="line"><span class="keyword">if</span> (h100 &lt;= n * <span class="number">100</span>) <span class="comment">//特别判断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(max_dist, (<span class="type">int</span>)((dist.<span class="built_in">back</span>() * <span class="number">100</span> - <span class="number">1</span>) / delta + <span class="number">1</span>));</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> v) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">t += (dist[i] - <span class="number">1</span>) / v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (t * v + dist.<span class="built_in">back</span>()) * <span class="number">100</span> &lt;= h100 * v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h = h100 / (n * <span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = (max_dist - <span class="number">1</span>) / h + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">(<span class="built_in">check</span>(mid) ? right : left) = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity性能优化——资源优化</title>
      <link href="/posts/d909f64.html"/>
      <url>/posts/d909f64.html</url>
      
        <content type="html"><![CDATA[<h1 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h1><h2 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h2><p>动态模型:面片数&lt;3000<br>材质数&lt;3<br>骨骼数&lt;50<br>静态模型:顶点数&lt;500</p><p>上述是在手游中模型优化的参考标准，</p><h2 id="Audio："><a href="#Audio：" class="headerlink" title="Audio："></a>Audio：</h2><p>长时间音乐（背景音乐）：使用mp3的压缩格式，主要是减少了安装包的大小</p><p>短时间音乐（音效）：使用wav的格式 ，经常性的播放，不需要频繁加载，使用mp3则是会频繁的解压缩操作</p><p>推荐博客：<a href="https://blog.csdn.net/u012565990/article/details/51794486">unity优化—资源优化_unity发布exe时很慢-CSDN博客</a></p><p>有对Unity中音频资源导入的详细讲解</p><h2 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h2><p>贴图长宽&lt;1024，Unity最高支持2048</p><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><p>尽量减少复杂的数学运算</p><p>减少discard操作</p><h2 id="资源冗余"><a href="#资源冗余" class="headerlink" title="资源冗余"></a>资源冗余</h2><p>Resources目录下的所有文件最后都会被打包到安装包中</p><p>同样的资源建议存在唯一路径</p><h2 id="资源检测与分析"><a href="#资源检测与分析" class="headerlink" title="资源检测与分析"></a>资源检测与分析</h2><p>AB包上的分析</p><p>Unity官方自带的UPR分析工具，第三方工具UWA</p><p><a href="https://www.uwa4d.com/#assetbundle">UWA | 致力于游戏VR和AR应用提供项目研发解决方案 | 简单优化、优化简单 | 侑虎科技 (uwa4d.com)</a></p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240926154130.png" alt="image-20240926154122602" style="zoom:67%;" /><p>模型贴图精度调整，原糊近清，直接的参照是图中的组件，在assets文件夹中将对应的模型拖拽到该组件不同颜色的色框内就可以使用</p><p>需要和美术配合使用</p><h2 id="静态选项"><a href="#静态选项" class="headerlink" title="静态选项"></a>静态选项</h2><p>在Unity的检视窗口中的可勾选项，static下，存在以下选项，是接下来遮挡剔除和光照贴图应用的前提</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240926155022.png" alt="image-20240926155018707"></p><p><a href="https://blog.csdn.net/qq_40513792/article/details/115078009">unity 性能优化之遮挡剔除_unity occludee-CSDN博客</a></p><table><thead><tr><th><strong>Nothing</strong></th><th>对于任何系统，都不将游戏对象包含在预计算中。</th></tr></thead><tbody><tr><td><strong>Everything</strong></td><td>对于下方的任何系统，都将游戏对象包含在预计算中。</td></tr><tr><td><strong>Contribute GI</strong></td><td>When you enable this property, Unity includes the target <a href="https://docs.unity.cn/cn/2023.2/Manual/class-MeshRenderer.html">Mesh Renderer</a> in global illumination calculations. These calculations take place while precomputing lighting data at bake time. The ContributeGI property exposes the <a href="https://docs.unity.cn/cn/2023.2/ScriptReference/ReceiveGI.html">ReceiveGI</a> property. The ContributeGI property only takes effect if you enable a global illumination setting such as <a href="https://docs.unity.cn/cn/2023.2/Manual/class-LightingSettings.html#MixedLighting">Baked Global Illumination</a> or <a href="https://docs.unity.cn/cn/2023.2/Manual/class-LightingSettings.html#RealtimeLighting">Enlighten Realtime Global Illumination</a> for the target Scene. A <a href="https://blogs.unity3d.com/2019/08/28/static-lighting-with-light-probes/">Unity Blog post about static lighting with Light Probes</a> provides guidance for using this flag. For additional context, see <a href="https://docs.unity.cn/cn/2023.2/Manual/BestPracticeLightingPipelines.html">this tutorial for setting up the Built-in Render Pipeline and lighting</a> in Unity.。启用该选项就是支持全局光照的光照贴图</td></tr><tr><td><strong>Occluder Static</strong></td><td>在遮挡剔除系统中，将游戏对象标记为静态遮挡物。有关更多信息，请参阅有关<a href="https://docs.unity.cn/cn/2023.2/Manual/OcclusionCulling.html">遮挡剔除系统</a>的文档。</td></tr><tr><td><strong>Occludee Static</strong></td><td>在遮挡剔除系统中，将游戏对象标记为静态被遮挡物。有关更多信息，请参阅有关<a href="https://docs.unity.cn/cn/2023.2/Manual/OcclusionCulling.html">遮挡剔除系统</a>的文档。</td></tr><tr><td><strong>Batching Static</strong></td><td>将游戏对象的网格与其他符合条件的网格组合起来，有可能降低运行时渲染成本。有关更多信息，请参阅有关<a href="https://docs.unity.cn/cn/2023.2/Manual/DrawCallBatching.html">静态批处理</a>的文档。</td></tr><tr><td><strong>Navigation Static</strong></td><td>在预计算导航数据时包含游戏对象。有关更多信息，请参阅有关<a href="https://docs.unity.cn/cn/2023.2/Manual/nav-NavigationSystem.html">导航系统</a>的文档。</td></tr><tr><td><strong>Off Mesh Link Generation</strong></td><td>Attempt to generate an OffMesh Link that starts from this GameObject when precomputing navigation data. For more information, see the documentation on <a href="https://docs.unity.cn/cn/2023.2/Manual/nav-BuildingOffMeshLinksAutomatically.html">automatically building OffMesh Links</a>.</td></tr><tr><td><strong>Reflection Probe</strong></td><td>为 <strong>Type</strong> 属性设置为 <strong>Baked</strong> 的<strong>反射探针</strong>预计算数据时，包含此游戏对象。有关更多信息，请参阅有关<a href="https://docs.unity.cn/cn/2023.2/Manual/ReflectionProbes.html">反射探针</a>的文档。</td></tr></tbody></table><p>Contribute GI：光照贴图应用选项</p><p>Navigation static的选项似乎已经被</p><h2 id="遮挡剔除"><a href="#遮挡剔除" class="headerlink" title="遮挡剔除"></a>遮挡剔除</h2><p>只渲染在视野内的游戏对象</p><p>在Unity 2017 版本中，将要使用这项技术的游戏对象在静态层级选中为 Occluder Static，随后需要指定一个接收 Occlusion Culling 功能的摄像机</p><p>不过在2023附近的版本中，这项功能被相机中的一个选项所取代，如下图所示，并且新增两个遮挡剔除的组件，同时在windows窗口中的位置也被放入到Rendering框体中</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240926163940.png" alt="image-20240926160740641" style="zoom:67%;" /><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240926161001.png" alt="image-20240926160956027"></p><h2 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h2><p>在Unity2017版本中，该功能的使用是将要使用光照贴图的游戏对象在静态层级上选择为 lighting static ，将要烘焙的光源在mode选为 bake，然后去windows窗口选择lighting 窗口，进行光照贴图的烘焙，bake</p><h2 id="模型合并"><a href="#模型合并" class="headerlink" title="模型合并"></a>模型合并</h2><p>多个模型合并为一个模型</p><p>提前调整好父子关系</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240926154426.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity——Dots</title>
      <link href="/posts/83ed1f81.html"/>
      <url>/posts/83ed1f81.html</url>
      
        <content type="html"><![CDATA[<h1 id="Unity学习目标"><a href="#Unity学习目标" class="headerlink" title="Unity学习目标"></a>Unity学习目标</h1><ul><li><input disabled="" type="checkbox"> <h2 id="Dots"><a href="#Dots" class="headerlink" title="Dots"></a>Dots</h2></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity性能优化</title>
      <link href="/posts/132b0908.html"/>
      <url>/posts/132b0908.html</url>
      
        <content type="html"><![CDATA[<h1 id="主界面操作窗口"><a href="#主界面操作窗口" class="headerlink" title="主界面操作窗口"></a>主界面操作窗口</h1><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240920160753.png" alt="image-20240920160742085" style="zoom: 200%;" /><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>第一个带ms的数据是完成主线程一帧的时间，第二个是渲染一帧图片的时间，值小点好，</p><h3 id="Batches"><a href="#Batches" class="headerlink" title="Batches"></a>Batches</h3><p>批次，表示调用（Draw Call，也可以简称为DC）的总次数，详见Unityshader的学习笔记，值小点好，在屏幕上输出一个画面</p><h3 id="Save-by-barching"><a href="#Save-by-barching" class="headerlink" title="Save by barching"></a>Save by barching</h3><p>有多少DC被合并到了一个批次，将可能然让这个数据大</p><p>以下二者的数量统计都是相对于摄像机的视椎体来讲的</p><h3 id="Tris"><a href="#Tris" class="headerlink" title="Tris"></a>Tris</h3><p>屏幕中剩余三角形数量，就算是一个cube在屏幕部分看不见，依然是要计入</p><h3 id="verts"><a href="#verts" class="headerlink" title="verts"></a>verts</h3><p>屏幕中剩余顶点数量，Unity中对于顶点的判断是一个面由两个三角形组成，这两个三角形存在共用顶点，一个cube是有由六个面组成，因为一个cube的顶点数量为 4 * 6 &#x3D;24</p><p>（在3D建模软件中创建的模型导入到Unity后，该模型在Unity中显示的三角面和网格顶点的数量和在3D建模软件中的可能不同。因为3D建模软件和Unity对模型的三角面和网格顶点的计算方式可能是不一样的。）</p><h3 id="Screen："><a href="#Screen：" class="headerlink" title="Screen："></a>Screen：</h3><p>屏幕分辨率以及在内存中占据的大小</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240920172932.png" alt="image-20240920172925133" style="zoom: 80%;" /><p>红框内的数据代表启动 垂直同步</p><h4 id="垂直同步解释"><a href="#垂直同步解释" class="headerlink" title="垂直同步解释"></a>垂直同步解释</h4><p>垂直同步用于将游戏的帧率限制为显示器的刷新率，可以防之游戏画面在告诉移动时的画面撕裂现象，使游戏画面更加平滑和连贯。<br>如果不启用垂直同步，当游戏的帧率高于显示器的刷新率时，图像的一部分可能会在显示器刷新之前更新，导致画面上出现明显的断裂线。而启用垂直同步后，图形处理器会等待显示器完成一次完整的刷新，然后再发送下一帧图像，确保每个图像帧都在刷新之前完全绘制，从而消除了撕裂现象。<br>但是启用垂直同步会消耗一些性能，也可能会出现卡顿的现象，要根据自己的实际情况来决定是否启用</p><h4 id="保持纵横比"><a href="#保持纵横比" class="headerlink" title="保持纵横比"></a>保持纵横比</h4><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240920173259.png" alt="image-20240920173253146" style="zoom:67%;" /><p>勾选第一个 aspect radio，在屏幕变小的情况下会保持纵横比进行缩放</p><h4 id="默认分辨率设置"><a href="#默认分辨率设置" class="headerlink" title="默认分辨率设置"></a>默认分辨率设置</h4><p>设置游戏启动时的默认屏幕分辨率:<br>所需的屏幕宽度和屏幕高度<br>Edit–Project Settings–Player–展开Resolution and Presentation下拉菜单–取消勾选Defaultls NativeResolution-写上</p><h3 id="SetPass-calls"><a href="#SetPass-calls" class="headerlink" title="SetPass calls"></a>SetPass calls</h3><p>表示在当前摄像机的渲染过程中，Unity切换着色器通道(Shader Pass)来渲染游戏对象的次数。一个着色器(Shader)可以包含多个着色器通道，每个着色器通道可以通过不同的方式来渲染游戏对象。但每次切换着色器通道都会消耗一定的性能。应尽量避免这项数据过大</p><h3 id="Shadow-casters"><a href="#Shadow-casters" class="headerlink" title="Shadow casters"></a>Shadow casters</h3><p>表示摄像机画面中有多少个物体产生了阴影。应尽量避免这项数据过大。</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240920174434.png" alt="image-20240920174429081" style="zoom:67%;" /><h3 id="Visible-skinned-meshes"><a href="#Visible-skinned-meshes" class="headerlink" title="Visible skinned meshes"></a>Visible skinned meshes</h3><p>网格用来定义一个模型的形状、大小和表面细节等信息。<br>模型的所有顶点、<br>线<br>面共同构成了这个模型的网格。</p><p>表示当前摄像机中有多少个可见的蒙皮网格。网格用来定义一个模型的形状、大小和表面细节等信息，模型的所有顶点、线、面共同构成了这个模型的网格。蒙皮网格是一个与骨骼绑定的网格，这个网格可以发生形变和做出各种动作。一个网格在没有蒙支之前是不能发生形变的，也不能做出各种动作的。但是在成功蒙皮之后，这个网格就可以发生形变和做出各种动作。应尽量避免这项数据过大。</p><p>蒙皮网路在Unity中实际上是组件形式管理的</p><h3 id="Animator-components-playing"><a href="#Animator-components-playing" class="headerlink" title="Animator components playing"></a>Animator components playing</h3><p>表示当前场景中有多少个 Animaor正在播放动画</p><h3 id="Animation-components-playing"><a href="#Animation-components-playing" class="headerlink" title="Animation components playing"></a>Animation components playing</h3><p> 表示当前尝尽中有多少个animation正在播放</p><h1 id="性能分析窗口"><a href="#性能分析窗口" class="headerlink" title="性能分析窗口"></a>性能分析窗口</h1><p>&#x2F;&#x2F;TODO：后序添加打开的方式</p><h2 id="模式选择"><a href="#模式选择" class="headerlink" title="模式选择"></a>模式选择</h2><img src="Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20240920180152373.png" alt="image-20240920180152373" style="zoom:80%;" /><p>在图片中的Edit模式下，不运行游戏可以收集数据，点击右侧的同心圆 按钮启动就行，同理还有需要在游戏运行时才能用的Play Mode</p><h1 id="Deep-Profile"><a href="#Deep-Profile" class="headerlink" title="Deep Profile"></a>Deep Profile</h1><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240920201417.png" alt="image-20240920201412807"></p><p>对自己编写的C#脚本中的各个方法进行功耗分析，适合单独去解决问题</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240924155459.png" alt="image-20240924155449737"></p><h1 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h1><p>调用栈(Call Stack)是计算机程序在执行过程中记录函数调用的一种数据结构。<br>调用栈是一个栈结构，即先进后出。它用于记录程序执行过程中，每个函数被调用的情况。<br>当一个函数被调用时，它的相关信息，如函数名、参数、返回地址等，会被添加进调用栈中。当该函数执行完成后，相应的信息会从调用栈中移除。通过不断添加和移除函数调用的信息，调用栈就记录了程序执行的顺序。<br>调用栈对于程序调试和分析非常有用。当程序出现错误或异常时，可以通过査看调用栈来确定错误发生的位置和函数调用的顺序。调试器通常会显示当前调用栈的信息，以帮助开发人员查看函数的执行过程并找出发生异常的原因。</p><p>选中Deep Profile右侧的Call Stacks按钮，这样在收集性能数据的时候，每一帧都会记录该方法的的调用栈信息。GC.AIloc，JnsafeUtility.Malloc、JobHandle.complete是Unity的方法，启用Call stacks且勾选它们后，如果Unity有调用它们，则可以在Hierarchy或Raw Hierarchy右侧的搜索框中搜索到它们，这样就可以查看它们的性能了。GC.Alloc表示GC的内存分配情况。<br>UnsafeUtility,Malloc(Persistent)表示非托管内存的分配情况。JobHandle,Commplete表示Job的完成情况。这里的Job是指Unity的Job Svstem的一组特定的任务</p><p>GC.Alloc表示GC的内存分配情况。<br>UnsafeUtility.Malloc(Persistent)用于在内存中分配指定大小的未初始化内存块。这个方法会直接在堆上分配内存，并可以绕过自动内存管理功能，需要手动管理内存的生命周期和释放。一般情况下，只有在处理非托管内存的特定场景下才会使用UnsafeUtility.Maloc方法<br>JobHandle.Complete表示Job的完成情况。</p><p>这里的Job是指Unity的Job Systemm的一组特定的任务。</p><p>托管内存是由垃圾回收器自动管理的内存，当达到一定量时，会由垃圾回收器自动释放它们。<br>千管内存存放在扦管堆中。扦管堆是一种用干存储和管理扦管对象的内存区域。每当创建一个新的扦管对象时，托管堆就会分配内存空间给这个对象，并记录这个对象的信息。当托管对象不再被引用或不可达时，垃圾回收器会自动将其标记为垃圾，并在适当的时候回收其占用的内存空间。<br>非托管内存不会自动被回收，它们需要我们程序员写代码去管理和释放它们。<br>非托管内存并不固定存储在一个地方，它们往往分散存储在不同的地方，例操作系统的内存、临时缓冲区等。</p><p>下面是Job涉及到的知识点</p><p>DOTS(Data-Oriented Technology Stack)是Unity引擎中的一个新的编程模型和工具集。它旨在提供更高性能、更可扩展和更并行化的游戏开发体验。<br>DOTS中包含了三个主要部分:<br>ECS框架:ECS是一种用于组织和管理游戏对象的方式。它将游戏对象分解为实体(Entity)、组件(Ccomponent)和系统(Syster)这种模式更加适合于并行处理和优化，可以提高游戏性能。<br>2、JobSystem(作业系统):Jobsystem允许开发者将任务并行化，利用多核处理器的能力。它通过将任务划分为小的作业(iobs)并在多个线程上并发执行来提高性能。JobSvstem还可以与ECS结合使用，使得开发者可以更好地控制游戏的行为。<br>3、Burst Compiler(突发编译器):Burst compiler是一种高性能的C#编译器，可以将C#代码转换为高效的本机代码，以进一步提高游对的性能。<br>DOTS的目标是为游戏开发者提供更好的性能和可扩展性，并更好地利用现代硬件的并行能力。它适用于需要处理大量实体和需要高性能的游戏项目。</p><p>点击选择框中给出的方法，如果在程序运行过程中使用到了，Unity会在下方程序窗口中展示出来</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240924160317.png" alt="image-20240924160313907"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity知识</title>
      <link href="/posts/a47dbcc3.html"/>
      <url>/posts/a47dbcc3.html</url>
      
        <content type="html"><![CDATA[<h1 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h1><p>在几秒内连续生成随机数的情况</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Random.InitState((<span class="built_in">int</span>)Time.time); <span class="comment">//使用时间作为每次生成的种子，</span></span><br><span class="line"> <span class="built_in">float</span> randomKey = Random.Range(<span class="number">-5f</span>, <span class="number">5f</span>); <span class="comment">//会生成随机的数字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> randomKey = Random.Range(<span class="number">-5f</span>, <span class="number">5f</span>); <span class="comment">//只会返回一个固定的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> randomKey = Random.<span class="keyword">value</span> * <span class="number">10f</span> - <span class="number">5f</span>; <span class="comment">//只会返回一固定的值</span></span><br></pre></td></tr></table></figure><h1 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h1><p>对于实现了IDisposable的类来讲，其实例对象都可以通过 using var 来进行对象的获取，这样在超出该对象的作用域后，会默认调用实现的Dispose方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> evt = PlayerRegisterEvent.Get(); <span class="comment">//使用using在超出作用域后自动调用Dispose（）方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">         </span><br><span class="line">         GameEventPool&lt;T&gt;.Push((T)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h1><p>如果在项目中使用了自制的事件系统，记得任何被注册event都应该有取消注册的步骤。</p><p>具体使用场景，使用场景加载这功能，在异步加载的情况下，会在场景中加载两个场景后删除一个，没有显示的的场景也会运行场景中游戏对象的Awake函数，如果在这里存在事件的注册，之后的运行中，虽然该场景被销毁，但是注册的事件仍然存在，会报错。</p><p>该游戏对象被销毁但是仍然试图访问。</p><p>进一步延伸，有 回调 方法参与的都要有注册有取消。</p><h1 id="、–和get-set函数"><a href="#、–和get-set函数" class="headerlink" title="++、–和get set函数"></a>++、–和get set函数</h1><p>应当使用以下操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">int</span> temp = CurrentIndex;</span><br><span class="line"> --CurrentIndex;</span><br><span class="line"> SwitchGridPage(temp, CurrentIndex); <span class="comment">// 使用局部变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> CurrentIndex &#123; </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.currentIndex; </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> </span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt;= <span class="number">0</span>) currentIndex = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">value</span>&gt; maxPage) currentIndex = maxPage;</span><br><span class="line">            <span class="keyword">else</span> currentIndex = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//刷新文字</span></span><br><span class="line">            RefreshTextContent(currentIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面这种用作函数参数的处理方式，第二个参数的样式只能触发set ，不能触发get</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SwitchGridPage(CurrentIndex,--CurrentIndex); <span class="comment">// 使用局部变量的值</span></span><br></pre></td></tr></table></figure><h1 id="英文路径"><a href="#英文路径" class="headerlink" title="英文路径"></a>英文路径</h1><p>Unity项目的路径不建议使用中文，在2023.3.20版本中，根目录的上级目录为中文的情况下，导入Cinemachine会在控制台疯狂报错、</p><h1 id="复合碰撞体Composite-Collider-2D"><a href="#复合碰撞体Composite-Collider-2D" class="headerlink" title="复合碰撞体Composite Collider 2D"></a>复合碰撞体Composite Collider 2D</h1><p>使用的时候需要有一个父游戏对象，并且将需要进行碰撞体合并的游戏对象作为游戏对象的子对象。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241126205319.png" alt="image-20241126205315233"></p><p>使用的时候会自动在相同游戏对象上生一个RigidBody2D，不过需要手动将rig的类型改为 Static</p><p>子游戏对象身上需要有碰撞体组件，在2023的版本中，将 use by Composite改成了红框中的内容</p><p>选择为merge就可以实现基本的内容</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20241126205440.png" alt="image-20241126205436786"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 6 Z字形变换</title>
      <link href="/posts/d2878ee5.html"/>
      <url>/posts/d2878ee5.html</url>
      
        <content type="html"><![CDATA[<h1 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode.cn/problems/zigzag-conversion/">6. Z 字形变换</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240915213518.png" alt="image-20240915213511577" style="zoom:67%;" /><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>在进入思考状态后，这个对应的公式转换是可以被求出来的，只是因为代码实践上的差异，自己第一次写的时候没能得出正确答案。</p><p>常规的解法还是很简单的使用相应的举着进行模拟即可，只是没有什么挑战可言，并且在时间和空间复杂度上也不是很让人满意。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span> || numRows &gt;= s.<span class="built_in">length</span>()) &#123;  </span><br><span class="line">            <span class="comment">// 如果numRows为1或者大于字符串长度，则无需转换  </span></span><br><span class="line">            <span class="keyword">return</span> s;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        <span class="type">int</span> cycleLen = <span class="number">2</span> * numRows - <span class="number">2</span>; <span class="comment">// 一个完整Z字形周期的长度  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 处理第一行和最后一行  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;  </span><br><span class="line">            <span class="comment">// 第一个字符的索引  </span></span><br><span class="line">            <span class="type">int</span> index = i;  </span><br><span class="line">            <span class="comment">// 当index小于字符串长度时，继续添加字符  </span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; s.<span class="built_in">length</span>()) &#123;  </span><br><span class="line">                result += s[index];  </span><br><span class="line">                <span class="comment">// 对于非第一行和最后一行，需要添加下降过程中的字符  </span></span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span> &amp;&amp; index + cycleLen - <span class="number">2</span> * i &lt; s.<span class="built_in">length</span>()) &#123;  </span><br><span class="line">                    result += s[index + cycleLen - <span class="number">2</span> * i];   <span class="comment">//要减去 2* i的操作是因为index有相应的i进位，这个时候加上完整Z字形周期长度就超过了本Z字形长度周期</span></span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 移到下一个周期  </span></span><br><span class="line">                index += cycleLen;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>可以看出，下面的代码是已经得出的转化公式，只是在跑while循环的时候对循环终止条件把握不好。</p><p>在最开始还过多考虑了给定s可以组成的特定结果的个数，不够组成的部分还有多少这样的问题</p><p>在正确的代码中，使用 index &lt; s.length()，成功消除了这部分的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">StringTopic::convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Z字变换</span></span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>(), num = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> count = n / num; <span class="comment">//主要是看能完成的组成多少个给定结构</span></span><br><span class="line"><span class="type">int</span> left = count % num;<span class="comment">//如果有剩下的，就单独组一个</span></span><br><span class="line"></span><br><span class="line">string res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐级添加给定内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= numRows; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//准备对补充一行的字符串</span></span><br><span class="line"><span class="type">int</span> idx = i;</span><br><span class="line"><span class="keyword">while</span> (idx &lt;= num * i +i || idx &lt; num * (i<span class="number">+1</span>) - i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val1 = num * i + <span class="number">1</span>, val2 = num * (i + <span class="number">1</span>) - i;</span><br><span class="line">res += s[val1];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//循环条件把握不好</span></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span> || i != numRows)</span><br><span class="line">&#123;</span><br><span class="line">res += s[val2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idx += num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 151 反转字符串中的单词</title>
      <link href="/posts/371e9371.html"/>
      <url>/posts/371e9371.html</url>
      
        <content type="html"><![CDATA[<h1 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240914163407.png" alt="image-20240914163403002" style="zoom:67%;" /><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最先想到是自己去拆解，这里介绍一种新的方法，stringstream，同时，虽然可以通过对原来的空格进行erase操作来实现，但是频繁的改变这东西会导致stirng频繁重新分配内存，建议少用，看看下面的 拆解 的标准答案。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">ranges::<span class="built_in">reverse</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>) <span class="comment">//跳过空格</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(idx != <span class="number">0</span>) s[idx++] = <span class="string">&#x27; &#x27;</span>;  <span class="comment">//除去第一个单词外，剩下的单词都要在首部添加一个空格</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> end = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(end &lt; n &amp;&amp; s[end] != <span class="string">&#x27; &#x27;</span>) s[idx++] = s[end++]; <span class="comment">//将原有的单词位移</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + idx - (end - i),s.<span class="built_in">begin</span>() + idx); <span class="comment">//正确翻转</span></span><br><span class="line"></span><br><span class="line">            i = end; <span class="comment">//跟踪新的尾部</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + idx,s.<span class="built_in">end</span>()); <span class="comment">//删除string后多余的部分</span></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>; <span class="comment">//可以自动根据空格来拆分字符串</span></span><br><span class="line">        string word;</span><br><span class="line">        vector&lt;string&gt; words;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用stringstream将单词提取并存入vector</span></span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">            words.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转所有单词</span></span><br><span class="line">        <span class="built_in">reverse</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 join 操作将单词拼接回结果字符串</span></span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result += <span class="string">&quot; &quot;</span>; <span class="comment">// 在单词之间添加空格</span></span><br><span class="line">            &#125;</span><br><span class="line">            result += words[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时提醒在C++对字符串采用stringstream的方式进行分解的话可以指定分隔符号。具体使用说明可以看下面的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">splitString</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">char</span> delimiter)</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;std::string&gt; result;  </span><br><span class="line">    <span class="function">std::stringstream <span class="title">ss</span><span class="params">(str)</span></span>;  </span><br><span class="line">    std::string token;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用 getline 以特定字符为分隔符来读取子字符串  </span></span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, token, delimiter)) &#123;  </span><br><span class="line">        result.<span class="built_in">push_back</span>(token);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 43 字符串相乘</title>
      <link href="/posts/eb08b51e.html"/>
      <url>/posts/eb08b51e.html</url>
      
        <content type="html"><![CDATA[<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode.cn/problems/multiply-strings/">43. 字符串相乘</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240914150801.png" alt="image-20240914150750515" style="zoom:67%;" /><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>和字符串模拟加法一样，属于必背题型</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = num<span class="number">1.</span><span class="built_in">size</span>(), n = num<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 结果最多为 m + n 位数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(m + n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从个位数开始逐位相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mul = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//重点在下面这个几行，是将乘法的进位信息和ij这两个位置信息结合起来，最后填入数组中适当的位置</span></span><br><span class="line">                <span class="comment">// 乘积在 res 对应的索引位置</span></span><br><span class="line">                <span class="type">int</span> p1 = i + j, p2 = i + j + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 叠加到 res 上</span></span><br><span class="line">                <span class="type">int</span> sum = mul + res[p2];</span><br><span class="line">                res[p2] = sum % <span class="number">10</span>;</span><br><span class="line">                res[p1] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 结果前缀可能存的 0（未使用的位）</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; res.<span class="built_in">size</span>() &amp;&amp; res[i] == <span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">// 将计算结果转化成字符串</span></span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">            str.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span> + res[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.<span class="built_in">size</span>() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后提醒一下C++中将string转换为int的自带方法 stoll ，位于 string 头文件下</p>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 12 整数转罗马数字</title>
      <link href="/posts/48953d57.html"/>
      <url>/posts/48953d57.html</url>
      
        <content type="html"><![CDATA[<h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><a href="https://leetcode.cn/problems/integer-to-roman/">12. 整数转罗马数字</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97.assets/image-20240914135318729.png" alt="image-20240914135318729" style="zoom:67%;" /><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题目难点在堆三个条件的理解上，其余的就是常规的将一个int数按照位数拆开后对照</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//罗马数对照表</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> string R[<span class="number">4</span>][<span class="number">10</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;, <span class="comment">// 个位</span></span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;, <span class="comment">// 十位</span></span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;, <span class="comment">// 百位</span></span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;, <span class="comment">// 千位</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//常规按位拆分再对比</span></span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R[<span class="number">3</span>][num / <span class="number">1000</span>] + R[<span class="number">2</span>][num / <span class="number">100</span> % <span class="number">10</span>] + R[<span class="number">1</span>][num / <span class="number">10</span> % <span class="number">10</span>] + R[<span class="number">0</span>][num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="constexpr对比const"><a href="#constexpr对比const" class="headerlink" title="constexpr对比const"></a>constexpr对比const</h2><p><code>constexpr</code> 和 <code>const</code> 在 C++ 中都用于定义不可变的变量，但它们之间有几个关键的区别：</p><ol><li><p>编译时常量与运行时常量</p><p>：</p><ul><li><code>constexpr</code>：指定的变量或函数在编译时就必须确定其值。这意味着，编译器可以在编译阶段就使用这个值进行优化和替换。<code>constexpr</code> 变量可以用于需要编译时常量的场合，比如模板参数或数组大小。</li><li><code>const</code>：指定的变量在程序运行期间不可改变，但其值可以在运行时确定。<code>const</code> 变量通常用于确保数据在程序的生命周期内不被意外修改。</li></ul></li><li><p>使用场景</p><p>：</p><ul><li><code>constexpr</code>：更适用于那些可以在编译时计算出结果的表达式，以及需要编译时常量的场合。</li><li><code>const</code>：更通用，可以用于任何不希望被修改的变量，无论其值是在编译时还是运行时确定的。</li></ul></li><li><p>类型要求</p><p>：</p><ul><li><code>constexpr</code>：只能用于字面量类型（如整型、浮点型、枚举等）或者具有<code>constexpr</code>构造函数的用户定义类型。</li><li><code>const</code>：可以用于任何类型。</li></ul></li><li><p>函数支持</p><p>：</p><ul><li><code>constexpr</code>：可以用于修饰函数，表示该函数在给定常量表达式作为参数时，会返回一个常量表达式。这使得函数可以在编译时被求值。</li><li><code>const</code>：不能用于修饰函数，但可以用于函数参数和返回类型，表示参数或返回值在函数内部不可修改。</li></ul></li><li><p>内存分配</p><p>：</p><ul><li>对于全局或静态存储持续时间的变量，<code>const</code> 和 <code>constexpr</code> 都可能导致编译器在程序的只读存储区分配内存。然而，对于局部变量，<code>constexpr</code> 变量可能根本不需要分配内存，因为编译器可以直接在其出现的地方使用它的值。</li></ul></li><li><p>动态初始化</p><p>：</p><ul><li><code>const</code> 变量可以在运行时进行动态初始化。</li><li><code>constexpr</code> 变量必须在编译时初始化，且其初始化表达式必须是常量表达式。</li></ul></li><li><p>线程安全</p><p>：</p><ul><li>由于 <code>constexpr</code> 变量在编译时就已经确定其值，并且在多个线程之间共享时不需要同步，因此它们是线程安全的（假设编译器和链接器正确地处理了它们）。</li><li><code>const</code> 变量如果是全局或静态的，并且在运行时初始化，那么在多线程环境中可能需要同步来确保线程安全。</li></ul></li></ol><p>综上所述，<code>constexpr</code> 和 <code>const</code> 虽然都用于定义不可变的变量，但它们在编译时与运行时的行为、使用场景以及类型要求等方面存在显著差异。在可能的情况下，优先使用 <code>constexpr</code> 可以带来更好的编译时优化和运行时性能。</p>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 5 最长回文子串</title>
      <link href="/posts/f8e140e8.html"/>
      <url>/posts/f8e140e8.html</url>
      
        <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240913213018.png" alt="image-20240913213014483" style="zoom:67%;" /><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="暴力解决"><a href="#暴力解决" class="headerlink" title="暴力解决"></a>暴力解决</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[left++] != s[right--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">StringTopic::longestPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="comment">//长度不够的时候，默认是回文串</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//求解最长回文子串</span></span><br><span class="line"><span class="comment">//滑动窗口</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, maxLen = <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line"><span class="function">string <span class="title">res</span><span class="params">(<span class="number">1</span>, s[<span class="number">0</span>])</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (; left &lt; n - <span class="number">1</span>; ++left)</span><br><span class="line">&#123;</span><br><span class="line">right = left + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//穷举所有的可能性</span></span><br><span class="line"><span class="keyword">while</span> (right &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, left, right))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = maxLen;</span><br><span class="line">maxLen = <span class="built_in">max</span>(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (temp != maxLen) res = s.<span class="built_in">substr</span>(left, right - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">++right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>这个解法的重点在于对之前计算结果的重新使用，并且使用两个参数来确定一个回文串的范围，我在尝试用暴力方法解决的时候没有考虑到这点，往动态规划优化的时候只拿一个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">StringTopic::longestPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line"> </span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//所有长度为1 的都是回文串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">memo[i][i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//从小到大堆各个长度进行遍历操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; L++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= n) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//对已经计算出来的回文串的再利用</span></span><br><span class="line"><span class="keyword">if</span> (s[i] != s[j]) memo[i][j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) memo[i][j] = <span class="literal">true</span>; <span class="comment">//在长度小于等于3 的时候，只要最两侧的值相等，就可以验证是回文串</span></span><br><span class="line"><span class="keyword">else</span> memo[i][j] = memo[i + <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">//长度大于3的时候就需要看之前的结果了</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (memo[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)</span><br><span class="line">&#123;</span><br><span class="line">maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">left = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">substr</span>(left, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中心扩张"><a href="#中心扩张" class="headerlink" title="中心扩张"></a>中心扩张</h3><p>在最开始是函数位置对以 i 为中心，i i 为中心这两种情况进行扩张，分别对应回文串的的奇数长度和偶数长度，核心的公式就完全和动态规划中判断的方式一致，前提是回文串，最两侧的相等，是回文串，时间复杂度是On2，空间复杂度是O1，实际运行起来比冬天规划快</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Extend</span><span class="params">(string&amp; s,<span class="type">int</span> i ,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &gt;=<span class="number">0</span> &amp;&amp; j &lt;s.<span class="built_in">length</span>() &amp;&amp; s[i] == s[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; maxLen)</span><br><span class="line">&#123;</span><br><span class="line">left = i;</span><br><span class="line">maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">--i;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">StringTopic::longestPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Extend</span>(s,i,i);</span><br><span class="line"><span class="built_in">Extend</span>(s,i,i<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">substr</span>(left,maxLen);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><p><a href="https://mao1mao2mao3mao4.github.io/2024/07/29/%E7%AE%97%E6%B3%95/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/">左神算法——并查集，KMP，Manacher | mao的博客 (mao1mao2mao3mao4.github.io)</a></p><p>左神的内容还是要复习</p>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 304 二维区域和检索-举着不可变</title>
      <link href="/posts/aa0b8379.html"/>
      <url>/posts/aa0b8379.html</url>
      
        <content type="html"><![CDATA[<h1 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240913170851.png" alt="image-20240913170846585" style="zoom:67%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>很容易就能看出来这道题是二维的前缀和，但是之前缺少类似的经验，再加上情况比较特殊，直接看的标准答案。</p><p>主要核心是使用+1来表示当前点位上从0 0 到i j位置区间内的和</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240913171511.png" alt="image-20240913171504894" style="zoom:67%;" /><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(),n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        sum.<span class="built_in">resize</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;m ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这段最后是加上在sum没有被统计进去的小点。</span></span><br><span class="line">                sum[i<span class="number">+1</span>][j<span class="number">+1</span>] = sum[i<span class="number">+1</span>][j] + sum[i][j<span class="number">+1</span>] - sum[i][j] + matrix[i][j]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[row2<span class="number">+1</span>][col2<span class="number">+1</span>] - sum[row2<span class="number">+1</span>][col1] - sum[row1][col2<span class="number">+1</span>] + sum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 73 矩阵置零</title>
      <link href="/posts/a0af7eb0.html"/>
      <url>/posts/a0af7eb0.html</url>
      
        <content type="html"><![CDATA[<h1 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240913160214.png" alt="image-20240913160209125" style="zoom:67%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240913160332.png" alt="image-20240913160326372" style="zoom:67%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>常规的解法常见，在不考虑空间复杂度的情况下，可以重新开一个同等大小的矩阵保存数据集，之后替换即可，也可以在遍历的过程中使用两个数组预先保存本来就是0 的位置，在本地置零操作完成后再去处理数组中的内容，空间复杂度得到一定优化。</p><p>如果矩阵中的元素没有包括一个int所能表示的所有范围的话，还是可以用标志变量去标记原本的0和新变的0。时间和空间复杂度分别是Om*n，O1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这个方法是将全局的0都映射到数组上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(m)</span>, <span class="title">col</span><span class="params">(n)</span></span>;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//全局的0映射</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">                    row[i] = col[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据映射的0改变值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果想要实现题目中给出的原地算法，考虑最优空间复杂度的情况下，就需要使用以下代码，主要步骤是先记录第一行和第一列是否存在0，使用两个int存储true和false进行控制，然后将整个矩阵中非第一行和第一列的位置上所有为0的映射到第一行和第一列上，本来这些位置都是要置零的，所以没有错误。</p><p>之后再去遍历非第一行和第一列的数据，行和列对应的第一行和第一列数据但凡是有0 的，该位置上的值统统变为0。</p><p>最后再根据之前设计的两个int记录的第一行和第一列是否有0 的情况，对第一行和第一列进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> flag_col0 = <span class="literal">false</span>, flag_row0 = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录第一列是否存在0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!matrix[i][<span class="number">0</span>]) &#123;</span><br><span class="line">flag_col0 = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录第一行是否存在0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">flag_row0 = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将矩阵中除第一行和第一列的0映射到第一行和第一例</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据映射的0改变对应的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!matrix[i][<span class="number">0</span>] || !matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对第一行和第一列最后进行操作</span></span><br><span class="line"><span class="keyword">if</span> (flag_col0) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag_row0) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 289 生命游戏</title>
      <link href="/posts/4e378f58.html"/>
      <url>/posts/4e378f58.html</url>
      
        <content type="html"><![CDATA[<h1 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a><a href="https://leetcode.cn/problems/game-of-life/">289. 生命游戏</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240913145916.png" alt="image-20240913145909533" style="zoom:67%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>很简单的一道题目，很容易想到重新开辟一个相同大小的二维数组进行结果替换，但是这样就存在一个相对较大的额外空间复杂度，</p><p>建议使用新的变量来替代表示同时又不干扰别的内容运行。例如之前是1，下一个状态是0，就可以用4来表示，同理，0变成1 可以用3表示，最后再遍历一次将所有的变成 0 就可以了。因为简单，这里不给出代码</p><p>这段代码主要演示的是在一个二维数组中该如何对给定点位周围的点进行探查，使用数组预先处理好要变化的距离，判断越界情况后正常处理即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; arr[<span class="number">8</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindOneNum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = i, y = j;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用数组来代替原本繁琐的if else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : arr)</span><br><span class="line">&#123;</span><br><span class="line">x = i + it.first;</span><br><span class="line">y = j + it.second;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断是否在范围内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; nums.<span class="built_in">size</span>() &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; nums[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; nums[x][y] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">++res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = i;</span><br><span class="line">y = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要返回一个值给res进行接受</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ChangLife</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> countOfOne = <span class="built_in">FindOneNum</span>(i,j,nums);</span><br><span class="line"><span class="keyword">if</span> (nums[i][j] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (countOfOne &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (countOfOne &gt;= <span class="number">2</span> &amp;&amp; countOfOne &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (countOfOne &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//死亡状态细胞</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (countOfOne == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Array::gameOfLife</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">res[i][j] = <span class="built_in">ChangLife</span>(i,j,board);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">board = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 306 累加数</title>
      <link href="/posts/cf656f64.html"/>
      <url>/posts/cf656f64.html</url>
      
        <content type="html"><![CDATA[<h1 id="306-累加数"><a href="#306-累加数" class="headerlink" title="306. 累加数"></a><a href="https://leetcode.cn/problems/additive-number/">306. 累加数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240911220443.png" alt="image-20240911220437947" style="zoom:67%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这道题目其实不难，纯粹的步骤多点，一开始自己写的时候没有好好审题，做了一些无用功从而导致解题的精力被浪费掉一部分。</p><p>解题的关键就在1 和 2 的数据上，穷尽前两个的排序才能继续进行下去</p><p>都是常用的代码，字符串模拟运算，斐波那契数列的检验</p><p>提醒一下，不要被 回溯 给干扰自己对穷举的判断</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StringTopic::isAdditiveNumber</span><span class="params">(string num)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//穷举1和2 位置上的所有组合</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n = num.<span class="built_in">length</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//穷举second的所有可能性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> secondStart = <span class="number">1</span>; secondStart &lt; n<span class="number">-1</span>; ++secondStart)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; secondStart != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> secondEnd = secondStart; secondEnd &lt; n - <span class="number">1</span>; ++secondEnd) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num[secondStart] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; secondStart != secondEnd) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Valid</span>(secondStart, secondEnd, num)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 斐波那契数列检验</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;secondStart&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;secondEnd&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Valid</span><span class="params">(<span class="type">int</span> secondStart, <span class="type">int</span> secondEnd, string num)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> firstStart = <span class="number">0</span>, firstEnd = secondStart - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (secondEnd &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">string third = <span class="built_in">StringAdd</span>(num, firstStart, firstEnd, secondStart, secondEnd);</span><br><span class="line"><span class="type">int</span> thirdStart = secondEnd + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> thirdEnd = secondEnd + third.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (thirdEnd &gt;= n || !(num.<span class="built_in">substr</span>(thirdStart, thirdEnd - thirdStart + <span class="number">1</span>) == third)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (thirdEnd == n - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">firstStart = secondStart;</span><br><span class="line">firstEnd = secondEnd;</span><br><span class="line">secondStart = thirdStart;</span><br><span class="line">secondEnd = thirdEnd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 字符窜模拟运算</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;firstStart&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;firstEnd&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;secondStart&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;secondEnd&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;&lt;/returns&gt;</span></span><br><span class="line"><span class="function">string <span class="title">StringAdd</span><span class="params">(string s, <span class="type">int</span> firstStart, <span class="type">int</span> firstEnd, <span class="type">int</span> secondStart, <span class="type">int</span> secondEnd)</span> </span>&#123;</span><br><span class="line">string third;</span><br><span class="line"><span class="type">int</span> carry = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (firstEnd &gt;= firstStart || secondEnd &gt;= secondStart || carry != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur = carry;</span><br><span class="line"><span class="keyword">if</span> (firstEnd &gt;= firstStart)</span><br><span class="line">&#123;</span><br><span class="line">cur += s[firstEnd] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">--firstEnd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (secondEnd &gt;= secondStart)</span><br><span class="line">&#123;</span><br><span class="line">cur += s[secondEnd] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">--secondEnd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">carry = cur / <span class="number">10</span>;</span><br><span class="line">cur %= <span class="number">10</span>;</span><br><span class="line">third.<span class="built_in">push_back</span>(cur + <span class="string">&#x27;0&#x27;</span>); <span class="comment">//一个int类型和char相加，结果是对应的 ASCII编码，这里是还原为对应的char</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ranges::<span class="built_in">reverse</span>(third);</span><br><span class="line"><span class="keyword">return</span> third;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 54 螺旋矩阵</title>
      <link href="/posts/78505a6d.html"/>
      <url>/posts/78505a6d.html</url>
      
        <content type="html"><![CDATA[<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240911161948.png" alt="image-20240911161943594" style="zoom:67%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这道题目的解法其实并不是很难，自己最开始写的时候是想着一个循环中只是处理数据，对于下个要添加进去的数据则是需要有很多辅助if去判断，问题就出在这里，正确的、容易理解发解法就是下面这个</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Array::spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, buttom = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= buttom)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//在一次循环中将一次顺时针的四个方向遍历完成</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向右遍历的部分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> column = left; column &lt;= right; column++)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(matrix[top][column]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向下遍历的部分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = top + <span class="number">1</span>; row &lt;= buttom; row++)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(matrix[row][right]);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向左和向上遍历的部分</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right&amp;&amp; top &lt; buttom)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> column = right - <span class="number">1</span>; column &gt; left; column--)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(matrix[buttom][column]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = buttom; row &gt; top; row--)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(matrix[row][left]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缩圈</span></span><br><span class="line">++left;</span><br><span class="line">++top;</span><br><span class="line">--right;</span><br><span class="line">--buttom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 2555 两个线段获得的最多奖品</title>
      <link href="/posts/c6668dd6.html"/>
      <url>/posts/c6668dd6.html</url>
      
        <content type="html"><![CDATA[<h1 id="2555-两个线段获得的最多奖品"><a href="#2555-两个线段获得的最多奖品" class="headerlink" title="2555. 两个线段获得的最多奖品"></a><a href="https://leetcode.cn/problems/maximize-win-from-two-segments/">2555. 两个线段获得的最多奖品</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240911152828.png" alt="image-20240911152823095" style="zoom:67%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>实际这道题目是动态规划的思想，最开始自己写的思路是找出一个线段的最大值再去在剩下的不重合区间内寻找下一个线段的最大值，但是这种情况下二者的 和 （最终的结果）不一定是最大的，前期的思路准备很重要</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Array::maximizeWin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prizePositions, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> n = prizePositions.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对解雇是整个数组长度的情况提前进行解决</span></span><br><span class="line">   <span class="comment">//使用 k *2 + 1 是考虑到数组长度是偶数的时候，,同时&gt; 的使用也把原本的奇数包括进去</span></span><br><span class="line"><span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">1</span> &gt;= prizePositions[n - <span class="number">1</span>] - prizePositions[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, mx = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//并同时在这下边提出对于线段的遍历要从右侧的线段开始，不然会则 mx+right−mid 可能会把 mid 处的奖品计入两次。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> mid = <span class="number">0</span>; mid &lt; n; mid++) &#123;</span><br><span class="line"><span class="comment">// 把 prizePositions[mid] 视作第二条线段的左端点，计算第二条线段可以覆盖的最大奖品下标</span></span><br><span class="line"><span class="keyword">while</span> (right &lt; n &amp;&amp; prizePositions[right] - prizePositions[mid] &lt;= k) &#123;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环结束后，right-1 是第二条线段可以覆盖的最大奖品下标</span></span><br><span class="line">ans = <span class="built_in">max</span>(ans, mx + right - mid);</span><br><span class="line"><span class="comment">// 把 prizePositions[mid] 视作第一条线段的右端点，计算第一条线段可以覆盖的最小奖品下标</span></span><br><span class="line"><span class="keyword">while</span> (prizePositions[mid] - prizePositions[left] &gt; k) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环结束后，left 是第一条线段可以覆盖的最小奖品下标</span></span><br><span class="line">mx = <span class="built_in">max</span>(mx, mid - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Array::maximizeWin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prizePositions, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//两条线段可能会重合，找出最大值，线段B就需要严格在线段A外求解一个最长长度</span></span><br><span class="line"><span class="type">int</span> n = prizePositions.<span class="built_in">size</span>();</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> left1 = <span class="number">0</span>, right1 = <span class="number">0</span>; <span class="comment">//线段A</span></span><br><span class="line"><span class="type">int</span> max1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> indexl = <span class="number">0</span>, indexr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right1 != prizePositions.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prizePositions[right1] - prizePositions[left1] &lt;= k)</span><br><span class="line">&#123;</span><br><span class="line">++right1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++left1;</span><br><span class="line"><span class="comment">//这个条件下已经是大于k，因为本身就需要在最后合适的结果上+1，就直接引用</span></span><br><span class="line"><span class="type">int</span> temp = <span class="built_in">max</span>(max1, right1 - left1 + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (temp != max1)</span><br><span class="line">&#123;</span><br><span class="line">indexl = left1 - <span class="number">1</span>;</span><br><span class="line">indexr = right1 - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">max1 = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (max1 == <span class="number">0</span> &amp;&amp; right1 - left1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">max1 = right1 - left1;</span><br><span class="line">indexl = left1;</span><br><span class="line">indexr = right1 - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> max2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (indexl &gt; <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">left1 = <span class="number">0</span>, right1 = <span class="number">0</span>;</span><br><span class="line">max2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (right1 &lt;= indexl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prizePositions[right1] - prizePositions[left1] &lt;= k)</span><br><span class="line">&#123;</span><br><span class="line">++right1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++left1;</span><br><span class="line">max2 = <span class="built_in">max</span>(max2, right1 - left1 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (max2 == <span class="number">0</span> &amp;&amp; right1 - left1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">max2 = right1 - left1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> max3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (indexr &lt; n - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">left1 = indexr + <span class="number">1</span>, right1 = indexr + <span class="number">1</span>;</span><br><span class="line">max3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (right1 &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prizePositions[right1] - prizePositions[left1] &lt;= k)</span><br><span class="line">&#123;</span><br><span class="line">++right1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++left1;</span><br><span class="line">max3 = <span class="built_in">max</span>(max3, right1 - left1 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (max3 == <span class="number">0</span> &amp;&amp; right1 - left1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">max3 = right1 - left1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> max1 + <span class="built_in">max</span>(max2, max3);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 448 找到数组中消失的数字</title>
      <link href="/posts/107bac.html"/>
      <url>/posts/107bac.html</url>
      
        <content type="html"><![CDATA[<h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240909141252.png" alt="image-20240909141247181" style="zoom:67%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>根据题目给出的要求，正确数组应该是所有数字各不相同，即意味着所有所有数据都可以看做是该数组的有效索引+1，</p><p>在第一个for循环中处理的就这这个内容，将数据转换为索引并在对应的位置上+n， %n的操作是防止该位置上的值已经被+n过从而导致索引越界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Array::findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//索引处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>&amp; x : nums)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = (x - <span class="number">1</span>) % n;</span><br><span class="line">nums[i] += n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//最后的结果是根据索引来处理，那个值没有变动，就代表这个位置的索引+1的数没有出现</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 414 第三大的数</title>
      <link href="/posts/2433362e.html"/>
      <url>/posts/2433362e.html</url>
      
        <content type="html"><![CDATA[<h1 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><a href="https://leetcode.cn/problems/third-maximum-number/">414. 第三大的数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240909134002.png" alt="image-20240909133957009" style="zoom:67%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>三种解法</p><ol><li>排序</li><li>有序集合</li><li>一次遍历</li></ol><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>非常常规且容易想到的解法，只不过在时间复杂度上不是很友好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), greater&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, diff = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>] &amp;&amp; ++diff == <span class="number">3</span>) &#123; <span class="comment">// 此时 nums[i] 就是第三大的数</span></span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>长时间没有使用Set，甚至忘记了有这东西，第一时间先到的是双端队列这种东西，set会对插入的内容进行一个排序处理，begin位置的在默认情况下是最小值</p><p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。由于有序集合的大小至多为 3，插入和删除的时间复杂度可以视作是 O(1) 的，因此时间复杂度为 O(n)。</p><p>空间复杂度：O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : nums)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">3</span> ? *s.<span class="built_in">begin</span>() : *s.<span class="built_in">rbegin</span>();</span><br></pre></td></tr></table></figure><h3 id="一次排序"><a href="#一次排序" class="headerlink" title="一次排序"></a>一次排序</h3><p>这种实际需要重点学习的方法</p><p>这方法实际是对有序集合排序过程的模仿，最开始没有想到这种解决办法是因为max和min这俩函数用多了</p><ul><li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是数组 <em>nums</em> 的长度。</li><li>空间复杂度：<em>O</em>(1)。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">       <span class="type">long</span> a = LONG_MIN, b = LONG_MIN, c = LONG_MIN;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">long</span> num : nums) &#123;</span><br><span class="line">           <span class="keyword">if</span> (num &gt; a) &#123;</span><br><span class="line">               c = b;</span><br><span class="line">               b = a;</span><br><span class="line">               a = num;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; num &amp;&amp; num &gt; b) &#123;</span><br><span class="line">               c = b;</span><br><span class="line">               b = num;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt; num &amp;&amp; num &gt; c) &#123;</span><br><span class="line">               c = num;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> c == LONG_MIN ? a : c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 119 杨辉三角</title>
      <link href="/posts/88a496f3.html"/>
      <url>/posts/88a496f3.html</url>
      
        <content type="html"><![CDATA[<h1 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a href="https://leetcode.cn/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240907173432.png" alt="image-20240907173426702" style="zoom:67%;" /><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//杨辉三角核心代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">resize</span>(i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">res[j] += res[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>记忆双重for循环中的杨辉三角核心代码</p>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 520 检测大写字母</title>
      <link href="/posts/15a02ee.html"/>
      <url>/posts/15a02ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520. 检测大写字母"></a><a href="https://leetcode.cn/problems/detect-capital/">520. 检测大写字母</a></h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240907163816.png" alt="image-20240907163809808" style="zoom:67%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>两种解法</p><ol><li>自己第一次写的</li><li>03XF的</li></ol><h3 id="自己的"><a href="#自己的" class="headerlink" title="自己的"></a>自己的</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word.<span class="built_in">length</span>() == <span class="number">0</span> || word.<span class="built_in">length</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> flag1 = <span class="literal">false</span>; <span class="comment">//检查首位是不是大写的</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">toupper</span>(word[<span class="number">0</span>]) == word[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//从第二个开始，后面都需要相同</span></span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> flag2 = <span class="literal">false</span>, flag3 = <span class="literal">false</span>; <span class="comment">//flag2是判断大写的，flag3是判断小写的</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; word.<span class="built_in">length</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">flag2 = flag2 || <span class="built_in">toupper</span>(word[i]) == word[i] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">flag3 = flag3 || <span class="built_in">tolower</span>(word[i]) == word[i] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (flag1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> flag2 ^ flag3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (flag2 ^ flag3)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> flag3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="03XF"><a href="#03XF" class="headerlink" title="03XF"></a>03XF</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> cnt = ranges::<span class="built_in">count_if</span>(word, ::isupper); <span class="comment">//获取所有大写字母数量</span></span><br><span class="line">       <span class="keyword">return</span> cnt == <span class="number">0</span> || cnt == word.<span class="built_in">length</span>() || cnt == <span class="number">1</span> &amp;&amp; <span class="built_in">isupper</span>(word[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//分类讨论，0就行，全是就行，是第一个就行</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>githug首次ssh访问注意</title>
      <link href="/posts/ed8e9161.html"/>
      <url>/posts/ed8e9161.html</url>
      
        <content type="html"><![CDATA[<h1 id="github首次ssh访问注意"><a href="#github首次ssh访问注意" class="headerlink" title="github首次ssh访问注意"></a>github首次ssh访问注意</h1><h2 id="CA证书问题"><a href="#CA证书问题" class="headerlink" title="CA证书问题"></a>CA证书问题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config http.sslVerify <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>暂时关闭CA证书检查</p><p>同样可以安装 TortoiseGit ，</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240906162132.png" alt="image-20240906162124197" style="zoom: 67%;" /><p>进入到设置中按照以上步骤设置，在右侧文本编辑器中添加红框中的内容</p><p>或者也可以先禁止CA证书检查，然后再启用，最后在执行以上操作</p><h2 id="github端口问题"><a href="#github端口问题" class="headerlink" title="github端口问题"></a>github端口问题</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240906162455.png" alt="image-20240906162443200" style="zoom:67%;" /><p>第一次上传大概率会有端口问题，因此在C盘的用户目录下的.ssh文件夹内，新建一个config文件，并添加红框中的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 459 重复的字符串</title>
      <link href="/posts/21a2bf89.html"/>
      <url>/posts/21a2bf89.html</url>
      
        <content type="html"><![CDATA[<h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h1><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240906154122.png" alt="image-20240906154112337" style="zoom: 67%;" /><p>该问题有有三种解法，第一种就是常见的枚举，双重for循环，时间复杂度通常不如人意，On2</p><p>第二种则是巧妙利用这种结构的特性进行处理</p><p>第三种是经典的KMP算法</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[j] != s[j - i]) &#123;</span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>如果给定的string符合要求，则从索引1开始对合并后的string进行查找操作后，不会在第二个拼接string那里获取到结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认的find进行查找，参数的第二个是从索引为1的位置进行查找</span></span><br><span class="line"><span class="keyword">return</span> (s + s).<span class="built_in">find</span>(s, <span class="number">1</span>) != s.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>过于经典和麻烦，不做赘述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; query, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = query.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kmp</span>(s + s, s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 389 找不同</title>
      <link href="/posts/803051f2.html"/>
      <url>/posts/803051f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a><a href="https://leetcode.cn/problems/find-the-difference/">389. 找不同</a></h1><h2 id="四种解法"><a href="#四种解法" class="headerlink" title="四种解法"></a>四种解法</h2><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>reduce是在numeric头文件下的对容器进行累计操作的方法，默认是求和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>  (<span class="type">char</span>)<span class="built_in">reduce</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>()) - <span class="built_in">reduce</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>时间复杂度On，空间复杂度O1</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ranges::<span class="built_in">sort</span>(s);</span><br><span class="line">ranges::<span class="built_in">sort</span>(t);</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] != t[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> t.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure><p>时间复杂度OnlogN，空间复杂度O1</p><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            cnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">            cnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度On，空间复杂度Oe，e &#x3D; 26</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">          ret ^= ch;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">          ret ^= ch;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度On，空间复杂度O1</p>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 67 二进制求和</title>
      <link href="/posts/78394597.html"/>
      <url>/posts/78394597.html</url>
      
        <content type="html"><![CDATA[<h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a href="https://leetcode.cn/problems/add-binary/">67. 二进制求和</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">StringTopic::addBinary</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//模拟运算</span></span><br><span class="line">string res;</span><br><span class="line">ranges::<span class="built_in">reverse</span>(a);</span><br><span class="line">ranges::<span class="built_in">reverse</span>(b);</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">length</span>(), b.<span class="built_in">length</span>()), carry = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">carry += i &lt; a.<span class="built_in">length</span>() ? (a[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">carry += i &lt; b.<span class="built_in">length</span>() ? (b[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">res.<span class="built_in">push_back</span>(carry % <span class="number">2</span> ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">carry /= <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (carry)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ranges::<span class="built_in">reverse</span>(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity组件——AI navigation</title>
      <link href="/posts/8ad6b0cb.html"/>
      <url>/posts/8ad6b0cb.html</url>
      
        <content type="html"><![CDATA[<h1 id="AI-navigation"><a href="#AI-navigation" class="headerlink" title="AI navigation"></a>AI navigation</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905151945.png" alt="image-20240905151937886" style="zoom:67%;" /><h3 id="属性讲解"><a href="#属性讲解" class="headerlink" title="属性讲解"></a>属性讲解</h3><p>Agent Radius：代理半径，决定了烘焙路面距离墙面的距离，当出现两堵墙距离过近导致没有路径出现的情况，可以适当调小该属性</p><p>Height：代理高度，限制代理对象的高度，调整数值可以让代理角色通过桥洞或者隧道等有高度限制的场景</p><p>Step Height：台阶高度，在这个高度范围内的 台阶 会生成烘焙路径</p><p>Max Slope：可以生成烘焙路径的斜坡最大倾斜角度</p><h4 id="Generated-Links"><a href="#Generated-Links" class="headerlink" title="Generated Links"></a>Generated Links</h4><p>自动生成外链</p><p>Drop Distance：下落高度</p><p>Jump Distance：跳跃距离</p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905153227.png" alt="image-20240905153222293" style="zoom:67%;" /><h3 id="属性讲解-1"><a href="#属性讲解-1" class="headerlink" title="属性讲解"></a>属性讲解</h3><p>Nav Mesh Agent：自动寻路代理对象，需要自动寻路的添加该组件</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905153439.png" alt="image-20240905153434727" style="zoom:67%;" /><p>Nav Mesh Obstacle：被其余系统驱动的移动物体，需要Agent主动避开</p><img src="Unity%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94A%E6%98%9F%E5%AF%BB%E8%B7%AF%E6%8F%92%E4%BB%B6.assets/image-20240905153614516.png" alt="image-20240905153614516" style="zoom:67%;" /><p>Nav Links</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905153716.png" alt="image-20240905153711292" style="zoom:67%;" /><p>NavMeshdifler</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905153909.png" alt="image-20240905153859128" style="zoom:67%;" /><p>NavMeshSurface</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905154009.png" alt="image-20240905154004547" style="zoom:67%;" /><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905154009.png" alt="image-20240905154004547" style="zoom:67%;" /><p>在需要烘焙的游戏对象上添加以上组件，保持默认设置，点击有右下角的bake按钮就可以在该游戏对象上生成烘焙路径，Agent可以在该对象表面进行寻路操作</p><p>每次子对象的变动，都需要重新点击Bake按钮进行烘焙</p><h3 id="自动生成外链"><a href="#自动生成外链" class="headerlink" title="自动生成外链"></a>自动生成外链</h3><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905155342.png" alt="image-20240905155334872" style="zoom:67%;" /><h3 id="手动生成外链"><a href="#手动生成外链" class="headerlink" title="手动生成外链"></a>手动生成外链</h3><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905155521.png" alt="image-20240905155516486" style="zoom:67%;" /><h3 id="特殊区域"><a href="#特殊区域" class="headerlink" title="特殊区域"></a>特殊区域</h3><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905155658.png" alt="image-20240905155640683" style="zoom:67%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905155751.png" alt="image-20240905155743066" style="zoom:67%;" /><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240905153439.png" alt="image-20240905153434727" style="zoom:67%;" /><p>寻路代理，需要进行寻路操作的游戏对象附加该组件</p><h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h4><p>让Agent可以自动寻路到指定position</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.AI;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveTo</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> NavMeshAgent agent;</span><br><span class="line"> </span><br><span class="line">    [<span class="meta">SerializeField</span>] Transform target; <span class="comment">//要追踪的目标</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        agent = GetComponent&lt;NavMeshAgent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        agent.destination = target.position;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A星寻路"><a href="#A星寻路" class="headerlink" title="A星寻路"></a>A星寻路</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>相较于Unity自带的寻路系统，这个插件可以将网格保存下来。不需要每次都动态的去搜索一下。</p><h2 id="下载路径"><a href="#下载路径" class="headerlink" title="下载路径"></a>下载路径</h2><p><a href="http://arongranberg.com/astar/download">http://arongranberg.com/astar/download</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 3174 清除数字</title>
      <link href="/posts/245fff39.html"/>
      <url>/posts/245fff39.html</url>
      
        <content type="html"><![CDATA[<h1 id="3174-清除数字"><a href="#3174-清除数字" class="headerlink" title="3174. 清除数字"></a><a href="https://leetcode.cn/problems/clear-digits/">3174. 清除数字</a></h1><p>这时一道简单的栈处理题目，</p><p>下面是一开始和直接使用栈的解决方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Array::clearDigits</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>())</span><br><span class="line">&#123;</span><br><span class="line">sta.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sta.<span class="built_in">push</span>(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (!sta.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">s += sta.<span class="built_in">top</span>();</span><br><span class="line">sta.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ranges::<span class="built_in">reverse</span>(s);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法虽然能解决问题，但是最后还需要对新建的栈进行处理，回顾栈的定义，可以使用以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string st;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123; <span class="comment">//判断一个char是不是数字</span></span><br><span class="line">        st.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        st += c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> st;</span><br></pre></td></tr></table></figure><p>对于一个string类型来说，可以从尾部插入，从尾部弹出，这就满足栈的特性，又因为最后的结果需要返回一个string，所以选取string</p><p>同样，对于一个vector来说，也可以看做是一个栈，只需要在自己使用的时候注意，就可以满足栈的特性</p>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity组件——DotWeen</title>
      <link href="/posts/a00f43ae.html"/>
      <url>/posts/a00f43ae.html</url>
      
        <content type="html"><![CDATA[<h1 id="DotWeen"><a href="#DotWeen" class="headerlink" title="DotWeen"></a>DotWeen</h1><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><ol><li>打击感</li><li>打字机</li><li>移动</li><li>缩放</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>引用命名空间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> DG.Tweening;</span><br></pre></td></tr></table></figure><h3 id="打击感"><a href="#打击感" class="headerlink" title="打击感"></a>打击感</h3><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240904203439.png" alt="image-20240904203426719" style="zoom:67%;" /><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Camera.main.transform.DOShakePosition(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//将摄像机按照指定的参数进行晃动 </span></span><br><span class="line"><span class="comment">//前者是持续时间，单位是秒，后者是强度</span></span><br></pre></td></tr></table></figure><h3 id="打字机"><a href="#打字机" class="headerlink" title="打字机"></a>打字机</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Text text;</span><br><span class="line">text.DOText(<span class="string">&quot;要进行打字机变换文本内容&quot;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//对应的需要两个参数，第一个如内容所示，第二个参数代表的是第一个的内容需要在几秒内完成，单位是秒</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240904205624.png" alt="image-20240904205619841" style="zoom: 67%;" /><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text text;</span><br><span class="line">text.transform.DOMove(<span class="keyword">new</span> Vector2(<span class="number">1</span>,<span class="number">1</span>),<span class="number">3</span>); <span class="comment">//在3秒内从当前位置移动到指定位置</span></span><br><span class="line">text.transform.DOMove(<span class="keyword">new</span> Vector2(<span class="number">1</span>,<span class="number">1</span>),<span class="number">3</span>).From(); <span class="comment">//在3秒内从指定位置回到当前位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text.transform.DOScale(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//在2秒内将缩放至从当前值变为1</span></span><br><span class="line"></span><br><span class="line">text.transform.DOScale(<span class="number">1</span>,<span class="number">2</span>).From(); <span class="comment">//在2秒内将缩放值从1变为当前值</span></span><br><span class="line"></span><br><span class="line">text.DOFade(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//在2秒内将透明度从当前值变化为1</span></span><br><span class="line"></span><br><span class="line">text.DOFade(<span class="number">1</span>,<span class="number">2</span>).From(); <span class="comment">//在2秒内将透明度从当年值变为1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity组件——TimeLine</title>
      <link href="/posts/ea675e82.html"/>
      <url>/posts/ea675e82.html</url>
      
        <content type="html"><![CDATA[<h1 id="TimeLine"><a href="#TimeLine" class="headerlink" title="TimeLine"></a>TimeLine</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240904172927.png" alt="image-20240904172918392" style="zoom:67%;" /><p>TimeLine是控制的本体，Singal是动画中某个指定对象的传递</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240904173136.png" alt="image-20240904173131225" style="zoom:67%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240904173222.png" alt="image-20240904173216855" style="zoom:67%;" /><p>如果需要将事件传递出去，场景中需要有加载有下图红框内组件的游戏对象，使用方式和Unity常规的事件系统触发一致，</p><p>1.选择游戏对象</p><p>2.选择方法</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240904173311.png" alt="image-20240904173302260" style="zoom:67%;" /><p>使用前需要在场景中准备Add有下图所以组件的游戏对象，具体操作可以是直接从assets中将一个创建好的Timeline直接拖拽到场景中准备好的空对象上去</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240904201739.png" alt="image-20240904201733577" style="zoom:67%;" /><h2 id="常用轨道"><a href="#常用轨道" class="headerlink" title="常用轨道"></a>常用轨道</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240904201408.png" alt="image-20240904201404615" style="zoom:67%;" /><p>如上图所示：</p><ol><li>activation Track是控制活跃性的，在轨道的指定片段内是有效的，具体使用案例是在播放CG的时候需要将屏幕从人物中移动开，这个时候可以将原本的Playercamera拖拽到Timeline的该轨道上，在指定的片段内才是活跃的</li><li>Animation Track是常规的Animation，需要追踪一个animator，</li><li>audio Track是音效轨道</li><li>Control Track </li><li>playable Track</li><li>signal Track 事件轨道</li></ol><h2 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Playables; <span class="comment">//命名空间</span></span><br><span class="line"></span><br><span class="line">Playable playAble; <span class="comment">//控制对象</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> 给Timeline进行信号传递测试用的</span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SingalTEST</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            playAble.Play(); <span class="comment">//播放Timeline</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以使用其他元素现有的动画对一段集中的CG进行可视化调整，在指定的时间段内，播放指定音效这点还是很讨人喜欢的。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 2860 让所有学生保持开心的分组方法数</title>
      <link href="/posts/3fd8de2c.html"/>
      <url>/posts/3fd8de2c.html</url>
      
        <content type="html"><![CDATA[<h1 id="2860-让所有学生保持开心的分组方法数"><a href="#2860-让所有学生保持开心的分组方法数" class="headerlink" title="2860. 让所有学生保持开心的分组方法数"></a><a href="https://leetcode.cn/problems/happy-students/">2860. 让所有学生保持开心的分组方法数</a></h1><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">int</span> <span class="title">DpTopic::countWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//排序，枚举</span></span><br><span class="line">      <span class="comment">// 将原有的内容降序排列</span></span><br><span class="line">ranges::<span class="built_in">sort</span>(nums, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">     </span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//默认选择所有的元素</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; n &amp;&amp; nums[i - <span class="number">1</span>] &gt; n)</span><br><span class="line">&#123;</span><br><span class="line">++res;</span><br><span class="line">&#125;</span><br><span class="line">--n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//最小的元素不是0的情况下，才能所有元素全都不选取还符合条件</span></span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">back</span>() != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">++res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 2708. 一个小组的最大实力值</title>
      <link href="/posts/43d99797.html"/>
      <url>/posts/43d99797.html</url>
      
        <content type="html"><![CDATA[<h1 id="2708-一个小组的最大实力值"><a href="#2708-一个小组的最大实力值" class="headerlink" title="2708. 一个小组的最大实力值"></a><a href="https://leetcode.cn/problems/maximum-strength-of-a-group/">2708. 一个小组的最大实力值</a></h1><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很多地方都很常规，就是需要额外注意一下跟自身大小的比较</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">DpTopic::maxStrength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> minVal = nums[<span class="number">0</span>], maxVal = nums[<span class="number">0</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val1 = <span class="number">0</span>, val2 = <span class="number">0</span>;</span><br><span class="line">nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> x : nums)</span><br><span class="line">&#123;</span><br><span class="line">val1 = minVal * x;</span><br><span class="line">val2 = maxVal * x;</span><br><span class="line"></span><br><span class="line">minVal = <span class="built_in">min</span>(&#123; minVal, val1,val2,x &#125;);</span><br><span class="line">maxVal = <span class="built_in">max</span>(&#123; maxVal,val1,val2,x &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 2024 考试的最大困扰度</title>
      <link href="/posts/f7358caa.html"/>
      <url>/posts/f7358caa.html</url>
      
        <content type="html"><![CDATA[<h1 id="2024-考试的最大困扰度"><a href="#2024-考试的最大困扰度" class="headerlink" title="2024. 考试的最大困扰度"></a><a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/">2024. 考试的最大困扰度</a></h1><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>滑动窗口，滑动窗口的重点是左右指针变动的时机，这道题目存在两种解法，一种是将T和F的筛选分开，在代码段中使用两个while循环体进行操作</p><h2 id="双while循环体"><a href="#双while循环体" class="headerlink" title="双while循环体"></a>双while循环体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Topic::maxConsecutiveAnswers</span><span class="params">(std::string answerKey, <span class="type">int</span> k)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> maxT = <span class="number">0</span>, maxF = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 处理 &#x27;T&#x27; 的最长连续序列  </span></span><br><span class="line"><span class="type">int</span> leftT = <span class="number">0</span>, rightT = <span class="number">0</span>;  </span><br><span class="line"><span class="type">int</span> flipsT = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">while</span> (rightT &lt; answerKey.<span class="built_in">length</span>()) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (answerKey[rightT] == <span class="string">&#x27;F&#x27;</span>) &#123;  </span><br><span class="line">        ++flipsT;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (flipsT &gt; k) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (answerKey[leftT] == <span class="string">&#x27;F&#x27;</span>) &#123;  </span><br><span class="line">            --flipsT;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ++leftT;  </span><br><span class="line">    &#125;  </span><br><span class="line">    maxT = std::<span class="built_in">max</span>(maxT, rightT - leftT + <span class="number">1</span>);  </span><br><span class="line">    ++rightT;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 重置变量以处理 &#x27;F&#x27; 的最长连续序列  </span></span><br><span class="line"><span class="type">int</span> leftF = <span class="number">0</span>, rightF = <span class="number">0</span>;  </span><br><span class="line"><span class="type">int</span> flipsF = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">while</span> (rightF &lt; answerKey.<span class="built_in">length</span>()) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (answerKey[rightF] == <span class="string">&#x27;T&#x27;</span>) &#123;  </span><br><span class="line">        ++flipsF;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (flipsF &gt; k) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (answerKey[leftF] == <span class="string">&#x27;T&#x27;</span>) &#123;  </span><br><span class="line">            --flipsF;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ++leftF;  </span><br><span class="line">    &#125;  </span><br><span class="line">    maxF = std::<span class="built_in">max</span>(maxF, rightF - leftF + <span class="number">1</span>);  </span><br><span class="line">    ++rightF;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">max</span>(maxT, maxF);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单循环体"><a href="#单循环体" class="headerlink" title="单循环体"></a>单循环体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">//使用 位运算符 &gt;&gt; 是因为 TF/2后的</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>, cnt[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; answerKey.<span class="built_in">length</span>(); ++right)</span><br><span class="line">&#123;</span><br><span class="line">cnt[answerKey[right] &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">while</span> (cnt[<span class="number">0</span>]&gt;k &amp;&amp; cnt[<span class="number">1</span>] &gt; k)</span><br><span class="line">&#123;</span><br><span class="line">cnt[answerKey[left++] &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">max</span>(res,right - left <span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关于使用以上单体循环需要补充的知识点</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240902152246.png" alt="image-20240902152055512" style="zoom:67%;" /><p>下面是错误的单体循环使用方式，使用双体循环的判断去处理，逻辑复杂，不容易实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Topic::maxConsecutiveAnswers</span><span class="params">(string answerKey, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> maxT = <span class="number">0</span>, maxF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//和最大连续内容一样，到达一定长度后就舍弃</span></span><br><span class="line"><span class="type">int</span> leftT = <span class="number">0</span>, rightT = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> leftF = <span class="number">0</span>, rightF = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> curKT = <span class="number">0</span>, curKF = <span class="number">0</span>;<span class="comment">//用来记录执行了多少次操作</span></span><br><span class="line"><span class="keyword">while</span> (rightT &lt; answerKey.<span class="built_in">length</span>() &amp;&amp; rightF &lt; answerKey.<span class="built_in">length</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对T进行处理</span></span><br><span class="line"><span class="keyword">if</span> (answerKey[rightT] == <span class="string">&#x27;T&#x27;</span> &amp;&amp; rightT &lt; answerKey.<span class="built_in">length</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (curKF &gt; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//准备收缩</span></span><br><span class="line"><span class="keyword">while</span> (curKF &gt; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (answerKey[leftF] == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">--curKF;</span><br><span class="line">&#125;</span><br><span class="line">++leftF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++rightF;</span><br><span class="line">++curKF;</span><br><span class="line">&#125;</span><br><span class="line">++rightT;</span><br><span class="line">maxT = <span class="built_in">max</span>(maxT, rightT - leftT + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (answerKey[rightF] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; rightF &lt; answerKey.<span class="built_in">length</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (curKT &gt; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (curKT &gt; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (answerKey[leftT] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">--curKT;</span><br><span class="line">&#125;</span><br><span class="line">++leftT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++rightT;</span><br><span class="line">++curKT;</span><br><span class="line">&#125;</span><br><span class="line">++rightF;</span><br><span class="line">maxF = <span class="built_in">max</span>(maxF, rightF - leftF + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(maxT, maxF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-数组和指针的关系"><a href="#C-数组和指针的关系" class="headerlink" title="C++数组和指针的关系"></a>C++数组和指针的关系</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p;</span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">char</span> (*q)[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> memo[<span class="number">1</span>][<span class="number">10</span>];</span><br><span class="line">q = memo;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Opengl1——比较乱的笔记，稍后整理</title>
      <link href="/posts/c2034444.html"/>
      <url>/posts/c2034444.html</url>
      
        <content type="html"><![CDATA[<p>Opengl：<br> glDrawArrays(GL_TRIANGLES,0,3);</p><p>OpenGL中通过缓冲区来绘制一个三角形的命令，在这之前要先定义好 </p><p>如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  float positions[<span class="number">6</span>] =</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="number">-0.5</span>f,<span class="number">-0.5</span>f,</span><br><span class="line"></span><br><span class="line">​    <span class="number">0.0</span>f, <span class="number">0.5</span>f,</span><br><span class="line"></span><br><span class="line">​    <span class="number">0.5</span>f, <span class="number">-0.5</span>f,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  unsigned int buffer;</span><br><span class="line"></span><br><span class="line">  glGenBuffers(<span class="number">1</span>,&amp;buffer);</span><br><span class="line"></span><br><span class="line">  glBindBuffer(GL_ARRAY_BUFFER,buffer);</span><br><span class="line"></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER,<span class="number">6</span>*sizeof(float),positions,GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>positions数组是用来存储顶点位置的</p><p>1， 创建一个unsigned int</p><p>2， 创建缓冲区</p><p>3， 绑定缓冲区</p><p>4， 传递数据</p><p>顶点的概念：</p><p>​    顶点不只是一个单纯的由xy坐标位置组成的数据，它包含的是图像在这个位置的所有信息</p><p>Shader ：<br> static unsigned int CompileShader(unsigned int type,const string &amp;scoure)</p><p>{</p><p>  unsigned int id &#x3D; glCreateShader(type);</p><p>  const char* src &#x3D; scoure.c_str();</p><p>  glShaderSource(id,1,&amp;src,NULL);</p><p>  glCompileShader(id);</p><p>  int result;</p><p>  glGetShaderiv(id,GL_COMPILE_STATUS,&amp;result);</p><p>  if (result &#x3D;&#x3D; GL_FALSE)</p><p>  {</p><p>​    int length;</p><p>​    glGetShaderiv(id,GL_INFO_LOG_LENGTH,&amp;length);</p><p>​    char* message &#x3D; (char*)alloca(length * sizeof(char));</p><p>​    glGetShaderInfoLog(id,length,&amp;length,message);</p><p>​    cout &lt;&lt; “Failed to conpile” &lt;&lt; “\t” &lt;&lt; (type &#x3D;&#x3D; GL_VERTEX_SHADER ? “vertext” : “fragment”) &lt;&lt; endl;</p><p>​    cout &lt;&lt; message &lt;&lt; endl;</p><p>​    glDeleteShader(0);</p><p>​    return 0;</p><p>  }</p><p>  return id;</p><p>}</p><p>static unsigned int createShader(const string&amp; vertexShader, const string&amp; fragmentShader)</p><p>{</p><p>  unsigned int program &#x3D; glCreateProgram();</p><p>  unsigned int vs &#x3D; CompileShader(GL_VERTEX_SHADER, vertexShader);</p><p>  unsigned int fs &#x3D; CompileShader(GL_FRAGMENT_SHADER, fragmentShader);</p><p>  glAttachShader(program, vs);</p><p>  glAttachShader(program, fs);</p><p>  glLinkProgram(program);</p><p>  glValidateProgram(program);</p><p>  glDeleteShader(vs);</p><p>  glDeleteShader(fs);</p><p>  return program;</p><p>}</p><p>string vertexShader &#x3D;</p><p>​    “#version 330 core\n”</p><p>​    “\n”</p><p>​    “layout(location &#x3D; 0) in vec4 positions;\n”</p><p>​    “\n”</p><p>​    “void main()\n”</p><p>​    “\n”</p><p>​    “{\n”</p><p>​    “   gl_Position &#x3D; positions;\n”</p><p>​    “}\n”;</p><p>  string fragmentShader &#x3D;</p><p>​    “#version 330 core\n”</p><p>​    “\n”</p><p>​    “layout(location &#x3D; 0) out vec4 color;\n”</p><p>​    “\n”</p><p>​    “void main()\n”</p><p>​    “\n”</p><p>​    “{\n”</p><p>​    “  color &#x3D; vec4(1.0,0.0,0.0,1.0);\n”</p><p>​    “}\n”;</p><p>画一个红色的三角形</p><p>Shader写进一个文件外挂处理</p><p>String::find()在找不到内容的情况下，会返回一个string::npos</p><p>整个缓冲区必须是由无符号整型构成</p><p>错误处理：<br> 1，</p><p>  断言，注意：<br>   以前的版本可能需要在定义宏的x行的反斜杠后加上一个空格，但是现在已经不需要了</p><p>  而且需要在本地计算机进行调试，反复几次才会出来结果</p><p>GlCall(glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr));</p><p>#define ASSERT(x) if(!(x)) __debugbreak();</p><p>#define GlCall(x) GLClearShader();\</p><p>​    x;\</p><p>​    ASSERT(GLLogCall())&#x2F;&#x2F;声明</p><p>enum class ShaderType { NONE &#x3D;-1, VERTEX &#x3D;0, FRAGMENT&#x3D; 1 };</p><p>static void GLClearShader()</p><p>{</p><p>  while (glGetError()!&#x3D;GLEW_NO_ERROR);</p><p>}</p><p>static bool GLLogCall()</p><p>{</p><p>  while (GLenum error &#x3D; glGetError())</p><p>  {</p><p>​    cout &lt;&lt; “[opengl error] “ &lt;&lt; error &lt;&lt; endl;</p><p>​    return false;</p><p>  }</p><p>  return true;</p><p>}</p><p>2，</p><h1 id="统一变量"><a href="#统一变量" class="headerlink" title="统一变量"></a>统一变量</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">\#version <span class="number">330</span> core </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> layout(location = <span class="number">0</span>) out vec4 color; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">uniform vec4 u_color;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> void main() </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> &#123; </span><br><span class="line"></span><br><span class="line">   color = u_color;</span><br><span class="line"></span><br><span class="line"> &#125; ;</span><br><span class="line"></span><br><span class="line">下面的代</span><br></pre></td></tr></table></figure><p>码需要定义在使用shader后</p><p>  int location &#x3D; glGetUniformLocation(shader, “u_color”);</p><p>  ASSERT(location !&#x3D; -1);</p><p>  glUniform4f(location, 0.0, 1.0, 0.0, 1.0);</p><h1 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h1><p>  GlCall(glEnable(GL_BLEND));</p><p>  &#x2F;&#x2F;混合函数:glDisable是禁用混合，上面的是启用混合，默认清空下禁用</p><p>  GlCall(glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA));</p><p>  &#x2F;&#x2F;设置混合方法，该方法默认启用的是相加，里面的两个参数在计算过后相加</p><p>&#x2F;&#x2F;案例： </p><p>如图所示是第二个方法的使用原理，默认情况下指定src不变，具体的计算方法如下所示</p><p>​                          <img src="C:/Users/LENOVO/AppData/Roaming/Typora/typora-user-images/image-20240823201139791.png" alt="image-20240823201139791">     </p><p>​    <img src="C:/Users/LENOVO/AppData/Roaming/Typora/typora-user-images/image-20240823201146281.png" alt="image-20240823201146281"></p><p>常用的透视投影：</p><p>​    正交投影和透视投影，</p><p>正交投影通常用于2D渲染，记住是通常</p><p>透视投影通常用于3D渲染，但是也只是通常，该情况只根据实际需求而定</p><p>简而言之，正交矩阵中设置的是需要内容对照的新坐标系，二者相乘就会把内容的不规则坐标系转换为标准设备坐标系。</p><p>只是需要注意的是正交坐标系需要在前面，根据矩阵相乘的特性来看，交换位置，结果不一样</p><p>Mvp：保证的是模型的移动，在OpenGL中，三个矩阵的相乘顺序是反着来的，这是由OpenGL的规范决定的，OpenGL的矩阵是由列开始排序的。</p><p>P,v,m</p><h1 id="批渲染"><a href="#批渲染" class="headerlink" title="批渲染"></a>批渲染</h1><p>批渲染的两种实现方法：</p><p>​    第一种是利用统一变量，调用两次drawcall，这样的方法由一定的好处，虽然顶点缓冲区中的数据量没有增加，但是调用了两次drawcall，其中还有glcall的断言，当图像数量增加到一定程度时候，渲染就会变得很慢，图像出现掉帧</p><p>​    第二种是把顶点所有的顶点数据塞进一个顶点缓冲区内，一个drawcall就可以直接解决所有问题。</p><h2 id="纹理："><a href="#纹理：" class="headerlink" title="纹理："></a>纹理：</h2><p>这里有一个问题，把统一变量变成一个数组然后批渲染纹理的时候出现了问题。</p> <img src="C:/Users/LENOVO/AppData/Roaming/Typora/typora-user-images/image-20240823201050698.png" alt="image-20240823201050698" style="zoom: 150%;" /><p>layout(location &#x3D; 0) out vec4 mycolor;</p><p>in vec2 v_TexCoord;</p><p>in float v_Index;</p><p>uniform sampler2D u_Texture[2];</p><p>void main()</p><p>{</p><p>  int index &#x3D; (int)v_Index;</p><p>  vec4 texColor &#x3D; texture(u_Texture[index], v_TexCoord);</p><p>  mycolor &#x3D; texColor;;</p><p>};</p><p>解法</p><p>但是由于前面跟着视频，把texture封装到类中并且在texturetext中还加入了只能指针来测试，所所以出现了问题，错误是如图最后一句。</p><p>前提是我用了断言</p>]]></content>
      
      
      <categories>
          
          <category> 图形接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++知识点</title>
      <link href="/posts/44bbaae6.html"/>
      <url>/posts/44bbaae6.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-右值引用"><a href="#1-右值引用" class="headerlink" title="1.右值引用"></a>1.右值引用</h1><p>C++11后对拷贝构造函数的优化，允许窃取一个类中的所有内容，通俗来讲是讲整个类对象的内容搬空，  代码示例：</p><p>​                                                         <img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240823142810.png" alt="img" style="zoom:67%;" />  </p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240823142825.png" alt="img" style="zoom:67%;" /><h1 id="2．类的构造函数执行顺序"><a href="#2．类的构造函数执行顺序" class="headerlink" title="2．类的构造函数执行顺序"></a>2．类的构造函数执行顺序</h1><p>虚基类，父类，成员对象，自己，父类的是按照继承的顺序进行进行调用，跟在构造器中的构造顺序无关，虚基类的构造是依照该类继承的父类中最深的虚基类进行构造，深是相对于最终的派生类来讲的，最终的派生类是浅。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240823142813.png" alt="img"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240823142816.png" alt="img"></p><h1 id="3，类大小"><a href="#3，类大小" class="headerlink" title="3，类大小"></a>3，类大小</h1><p>一个空的类对象大小是1B</p><p>一个类相当于一个数据结构，有内存对齐的效果，有小于4四节的里面的所有内容朝着4字节对齐，大于4字节则是自动补齐的8字节</p><p>一个string的大小是40B</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言知识 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小地图制作——Unity篇</title>
      <link href="/posts/a9d23a86.html"/>
      <url>/posts/a9d23a86.html</url>
      
        <content type="html"><![CDATA[<h1 id="相机投影"><a href="#相机投影" class="headerlink" title="相机投影"></a>相机投影</h1><h2 id="内容准备"><a href="#内容准备" class="headerlink" title="内容准备"></a>内容准备</h2><h3 id="RenderTexture"><a href="#RenderTexture" class="headerlink" title="RenderTexture"></a>RenderTexture</h3><p>在Assets问价目录下一个合适的位置创建该内容</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240820164231.png" alt="image-20240820164227129" style="zoom:67%;" /><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p>这一步需要注意，选用的image必须是Raw Image，这样才会有对应的Texture选项</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240820164358.png" alt="image-20240820164352886" style="zoom:67%;" /><h3 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h3><p>场景中需要存在两个相机，一个相机使用该会导致画面只会渲染到之前的给定UI上，窗口主要内容丢失，对于需要使用虚拟相机的场景，建议按照原来的方法创建完成后直接复制原有的Camera（注意不是虚拟相机），在新创建的相机进行下图操作即可。</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240820164521.png" alt="image-20240820164518550" style="zoom:67%;" /><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240820164841.png" alt="image-20240820164829825" style="zoom: 67%;" /><h1 id="Transform追踪"><a href="#Transform追踪" class="headerlink" title="Transform追踪"></a>Transform追踪</h1><p>如该方法的名字所示，最终的效果实现就是在update函数中对指定的Transform改变值进行一个追踪，视频的方法暂且不论，使用FindTag方法在拥有大量对象的场景中会导致地图加载慢，在个人demo中，存在对应的GameEvent系统，可以通过该系统将需要被追踪的对象的数据发送过去</p><h2 id="实际代码"><a href="#实际代码" class="headerlink" title="实际代码"></a>实际代码</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240820183125.png" alt="image-20240820174912687"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240820183123.png" alt="image-20240820180447245"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240820183122.png" alt="image-20240820180559210"></p><p>这里的disX之前计算的x，disY同理</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240820183121.png" alt="image-20240820183105219"></p><p>最为关键的是这个转换操作</p><p>注意以下操作，是在UI中移动的关键</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.rectlransform.anchoredPosition</span><br></pre></td></tr></table></figure><p>下面是在个人项目Light中可以有效使用的MinMap控制代码</p><p>依托于自己实现的事件系统，在需要显示在地图上的实体初始化的时候选择合适的事件类型发送即可，不需要去全局查找对应的tag，</p><p>建议在事件的发送自start（）函数中进行，注册则是在awake（）函数，资源加载同样，目前这样使用是可以的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Cysharp.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Light.Assets.Scripts.EventManager;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Light</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MInMapController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Vector2 sizeData = <span class="keyword">new</span> Vector2(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//比例计算的公共vector2</span></span><br><span class="line">        <span class="keyword">private</span> Vector2 originVector2 = Vector2.zero;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> Vector2 targetVector2 = Vector2.one; <span class="comment">//公共v</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//准备实例化的数据</span></span><br><span class="line">        <span class="keyword">private</span> Sprite playerPointSprite;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> Sprite enemyPointSprite;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> Transform player;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> GameObject mapUi;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> GameObject playerPointUI;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//需要跟踪的PlayerTransform</span></span><br><span class="line">        <span class="keyword">private</span> Transform playerTrasform;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//需要保持的敌人</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;(Transform, RectTransform)&gt; enemyTransformToObjectDic = <span class="keyword">new</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            mapUi = transform.Find(<span class="string">&quot;Map&quot;</span>).gameObject;</span><br><span class="line"> </span><br><span class="line">            playerPointUI = transform.Find(<span class="string">&quot;PlayerPoint&quot;</span>).gameObject;</span><br><span class="line"> </span><br><span class="line">            EventManager.Register&lt;PlayerRegisterEvent&gt;(OnPlayerRegisterEventHandle);</span><br><span class="line">            EventManager.Register&lt;EnemyRegisterEvnet&gt;(OnEnemyRegisterEventHandle);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//加载图标</span></span><br><span class="line">            ResManager.Instance.LoadAsync&lt;Sprite&gt;(<span class="string">&quot;RedPoint&quot;</span>, (s) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                enemyPointSprite = s;</span><br><span class="line">            &#125;);</span><br><span class="line">            ResManager.Instance.LoadAsync&lt;Sprite&gt;(<span class="string">&quot;BluePoint&quot;</span>, (s) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                playerPointSprite = s;</span><br><span class="line">            &#125;,LoadType.AddressAbles);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">await</span> UniTask.WaitUntil(() =&gt; playerPointSprite != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">await</span> UniTask.WaitUntil(() =&gt; enemyPointSprite != <span class="literal">null</span>);</span><br><span class="line"> </span><br><span class="line">            playerPointUI.GetComponent&lt;Image&gt;().sprite = playerPointSprite;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;           </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPointMove();</span><br><span class="line"> </span><br><span class="line">            EnemyPointsMove();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 按照视频中那点讲解移动就行</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnemyPointsMove</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> enemyTransformToObjectDic)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">float</span> dis = Vector3.Distance(playerTrasform.position, item.Item1.position);</span><br><span class="line">                <span class="keyword">if</span> (dis &gt; <span class="number">50</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    item.Item2.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    item.Item2.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                originVector2.x = item.Item1.position.x - playerTrasform.position.x;</span><br><span class="line">                originVector2.y = item.Item1.position.y - playerTrasform.position.y;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">                RatioCalculation();</span><br><span class="line"></span><br><span class="line">                item.Item2.anchoredPosition = targetVector2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 移动map图层</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PlayerPointMove</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(playerTrasform == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            originVector2 = playerTrasform.position;</span><br><span class="line">            originVector2.y = playerTrasform.position.z;</span><br><span class="line"> </span><br><span class="line">            RatioCalculation();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//mapUi.transform.anchoredPosition = Vector2.zero - targetVector2;</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 比例换算，地图UI的尺寸设计是200*200，摄像机的范围是50*30，视野半径范围是25，小地图的目的是给玩家提前发现敌人做准备，因此采用比例1 ： 2，将地图显示范围拉到50，扩大一倍</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RatioCalculation</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            targetVector2 = originVector2 * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 对每一个成功注册的敌人进行区分和保存</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;event&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">OnEnemyRegisterEventHandle</span>(<span class="params">EnemyRegisterEvnet @<span class="keyword">event</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;cur--Map记录enemy&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            Image image = Instantiate(playerPointUI, mapUi.transform).GetComponent&lt;Image&gt;();</span><br><span class="line"> </span><br><span class="line">            image.sprite = enemyPointSprite;</span><br><span class="line">            image.rectTransform.sizeDelta = <span class="keyword">this</span>.sizeData;</span><br><span class="line">            image.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">this</span>.enemyTransformToObjectDic.Add((@event.transform, image.rectTransform));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnPlayerRegisterEventHandle</span>(<span class="params">PlayerRegisterEvent @<span class="keyword">event</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">             Debug.Log(<span class="string">&quot;cur--Map记录Player&quot;</span>);</span><br><span class="line">            playerTrasform = @event.transform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240821162116.png" alt="image-20240821162111294"></p>]]></content>
      
      
      <categories>
          
          <category> UI技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity——UI拖拽</title>
      <link href="/posts/90cfb828.html"/>
      <url>/posts/90cfb828.html</url>
      
        <content type="html"><![CDATA[<h1 id="UI拖拽"><a href="#UI拖拽" class="headerlink" title="UI拖拽"></a>UI拖拽</h1><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IBeginDragHandler, IEndDragHandler,IDragHandler</span><br></pre></td></tr></table></figure><p>该方法是BeginDrag接口的实现方法，在指定游戏对象被拖拽的时候启用，对于鼠标的位置追踪则可以直接使用 eventData.position 来进行移动，不需要进行一些列转换</p><p>一般被拖动的UI会受到自身所在层级影响，因此在一开始就需要重新设置一下被拖动UI的父对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            originParent = transform.parent;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">this</span>.transform.SetParent(transform.parent.parent.parent);</span><br><span class="line">            <span class="keyword">this</span>.transform.position = eventData.position;</span><br><span class="line">            canvasGroup.blocksRaycasts = <span class="literal">false</span>;<span class="comment">//射线可以穿透</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法是EndDrag接口的实现方法，在停止拖拽的时候启用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (eventData.pointerCurrentRaycast.gameObject.name.EndsWith(<span class="string">&quot;Slot&quot;</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              Debug.Log(<span class="string">&quot;----找到合适的位置，准备交换&quot;</span>);</span><br><span class="line">              <span class="comment">//this.parentPanel.SwitchItemIndex(this.gameObject,eventData.currentInputModule.gameObject); //数据层面的交换</span></span><br><span class="line">              Transform trans = eventData.pointerCurrentRaycast.gameObject.transform;</span><br><span class="line">              <span class="keyword">this</span>.transform.SetParent(trans.parent);</span><br><span class="line">              <span class="keyword">this</span>.transform.position = trans.position;</span><br><span class="line">              trans.SetParent(originParent);</span><br><span class="line">              trans.position = originParent.position;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (eventData.pointerCurrentRaycast.gameObject.name.StartsWith(<span class="string">&quot;Slot&quot;</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              Transform trans = eventData.pointerCurrentRaycast.gameObject.transform;</span><br><span class="line">              <span class="keyword">this</span>.transform.SetParent(trans);</span><br><span class="line">              <span class="keyword">this</span>.transform.position = trans.position;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              Debug.Log(<span class="string">&quot;----没有移动到合适的位置，回归原位&quot;</span>);</span><br><span class="line">              <span class="keyword">this</span>.transform.SetParent(originParent);</span><br><span class="line">              <span class="keyword">this</span>.transform.position = originParent.position;</span><br><span class="line">              RectTransform rect = transform <span class="keyword">as</span> RectTransform;</span><br><span class="line">              rect.sizeDelta = <span class="keyword">this</span>.sizeData;</span><br><span class="line">          &#125;</span><br><span class="line">          canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>可以使用该方法对射线检测到的物体进行判断</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventData.pointerCurrentRaycast.gameObject</span><br></pre></td></tr></table></figure><p>拖拽过程中如果不是新生成一个游戏对象作为拖拽副本的话，采用重新设置parent，一来二去会对最后的大小造成影响，因此建议在操作完成后对各自的position进行一设置，position可以是目标地点本来存在的同类游戏对象的position，也可以是目标地的父对象的position</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Transform trans = eventData.pointerCurrentRaycast.gameObject.transform; </span><br><span class="line">          <span class="keyword">this</span>.transform.SetParent(trans);</span><br><span class="line">          <span class="keyword">this</span>.transform.position = trans.position;</span><br></pre></td></tr></table></figure><h2 id="配合组件"><a href="#配合组件" class="headerlink" title="配合组件"></a>配合组件</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240822115526.png" alt="image-20240822115517698" style="zoom:67%;" /><p>要注意名字名为 Blocks Raycasts 参数的使用，当为true时，发出的射线不可穿透拖动的物体，fasle反之</p><h2 id="射线判断"><a href="#射线判断" class="headerlink" title="射线判断"></a>射线判断</h2><h3 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h3><h4 id="区域计算"><a href="#区域计算" class="headerlink" title="区域计算"></a>区域计算</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算UI大小，进行鼠标拖拽检查</span></span><br><span class="line">RectTransform rectransfrom = itemEquipUI.transform <span class="keyword">as</span> RectTransform;</span><br><span class="line"><span class="built_in">float</span> w = rectransfrom.rect.width;</span><br><span class="line"><span class="built_in">float</span> h = rectransfrom.rect.height;</span><br><span class="line"><span class="built_in">float</span> x = rectransfrom.position.x;</span><br><span class="line"><span class="built_in">float</span> y = rectransfrom.position.y;</span><br><span class="line"><span class="built_in">float</span> xL = x - w / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">float</span> xR = x + w / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">float</span> yL = y - h / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">float</span> yR = y + h / <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">itemEuqipUIArea.Item1 = <span class="keyword">new</span> Vector2(xL, xR);</span><br><span class="line">itemEuqipUIArea.Item2 = <span class="keyword">new</span> Vector2(yL, yR);</span><br></pre></td></tr></table></figure><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eventData.position.x.InRange(parentPanel.itemEuqipUIArea.Item1.x, parentPanel.itemEuqipUIArea.Item1.y)</span><br><span class="line">            &amp;&amp; eventData.position.y.InRange(parentPanel.itemEuqipUIArea.Item2.x, parentPanel.itemEuqipUIArea.Item2.y))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;可以装备Item&quot;</span>);</span><br><span class="line">            EquipItem();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="游戏对象"><a href="#游戏对象" class="headerlink" title="游戏对象"></a>游戏对象</h3><p>可以获取拖动UI下方，鼠标正下方的游戏对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventData.pointerCurrentRaycast.gameObject</span><br></pre></td></tr></table></figure><p>注意，该操作的使用前提是</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvasGroup.blocksRaycasts = <span class="literal">false</span>;<span class="comment">//射线可以穿透</span></span><br></pre></td></tr></table></figure><p>一般会在拖动开始就将该属性设置为false，但是为了下一次拖拽的稳定可靠，一般会在结束拖动的时候重新设置为true，需要注意要把顺序放置的方法最后，提前设置可能无法获取穿透下方的游戏对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     。。。。。。</span><br><span class="line">     canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="layout参数配置"><a href="#layout参数配置" class="headerlink" title="layout参数配置"></a>layout参数配置</h3><p>使用下图右侧栏目 参数进行配置，可以得到左边的效果。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240819112951.png" alt="image-20240819112946234"></p><p>下图的是在外部大框架没有使用content size filter的情况下使用的，建议使用第一行的第二个参数，会让子元素在空间内均匀排布</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240819112727.png" alt="image-20240819112723044"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="生成拖动副本"><a href="#生成拖动副本" class="headerlink" title="生成拖动副本"></a>生成拖动副本</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 开始拖拽</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;System.NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    itemOnDrag = Instantiate(<span class="keyword">this</span>.gameObject, <span class="keyword">this</span>.parentPanel.transform);</span><br><span class="line">    itemOnDrag.transform.position = eventData.position;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 拖拽中</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;System.NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> IDragHandler.OnDrag(PointerEventData eventData)</span><br><span class="line">&#123;</span><br><span class="line">    itemOnDrag.transform.position = eventData.position;</span><br><span class="line"> </span><br><span class="line">    Debug.Log(eventData.position);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 结束拖拽</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;System.NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> IEndDragHandler.OnEndDrag(PointerEventData eventData)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (eventData.position.x.InRange(parentPanel.itemEuqipUIArea.Item1.x, parentPanel.itemEuqipUIArea.Item1.y)</span><br><span class="line">        &amp;&amp; eventData.position.y.InRange(parentPanel.itemEuqipUIArea.Item2.x, parentPanel.itemEuqipUIArea.Item2.y))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;可以装备Item&quot;</span>);</span><br><span class="line">        EquipItem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (eventData.position.x.InRange(parentPanel.itemContentUIArea.Item1.x, parentPanel.itemContentUIArea.Item1.y)</span><br><span class="line">        &amp;&amp; eventData.position.y.InRange(parentPanel.itemContentUIArea.Item2.x, parentPanel.itemContentUIArea.Item2.y))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;可以卸下Item&quot;</span>);</span><br><span class="line">        RelieveItem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;可以丢弃Item&quot;</span>);</span><br><span class="line">        DestoryItem();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Destroy(itemOnDrag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本体移动"><a href="#本体移动" class="headerlink" title="本体移动"></a>本体移动</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 开始拖拽</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;System.NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span>   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        originParent = transform.parent;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.transform.SetParent(transform.parent.parent.parent);</span><br><span class="line">        <span class="keyword">this</span>.transform.position = eventData.position;</span><br><span class="line">        canvasGroup.blocksRaycasts = <span class="literal">false</span>;<span class="comment">//射线可以穿透</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 拖拽中</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;System.NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.position = eventData.position;</span><br><span class="line">        Debug.Log(<span class="string">&quot;-----射线当前检测到的对象&quot;</span>+eventData.pointerCurrentRaycast.gameObject.name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 结束拖拽</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;System.NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventData.pointerCurrentRaycast.gameObject.name.EndsWith(<span class="string">&quot;Slot&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;----找到合适的位置，准备交换&quot;</span>);</span><br><span class="line">            <span class="comment">//this.parentPanel.SwitchItemIndex(this.gameObject,eventData.currentInputModule.gameObject); //数据层面的交换</span></span><br><span class="line">            Transform trans = eventData.pointerCurrentRaycast.gameObject.transform;</span><br><span class="line">            <span class="keyword">this</span>.transform.SetParent(trans.parent);</span><br><span class="line">            <span class="keyword">this</span>.transform.position = trans.position;</span><br><span class="line">            trans.SetParent(originParent);</span><br><span class="line">            trans.position = originParent.position;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eventData.pointerCurrentRaycast.gameObject.name.StartsWith(<span class="string">&quot;Slot&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Transform trans = eventData.pointerCurrentRaycast.gameObject.transform;</span><br><span class="line">            <span class="keyword">this</span>.transform.SetParent(trans);</span><br><span class="line">            <span class="keyword">this</span>.transform.position = trans.position;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;----没有移动到合适的位置，回归原位&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.transform.SetParent(originParent);</span><br><span class="line">            <span class="keyword">this</span>.transform.position = originParent.position;</span><br><span class="line">            RectTransform rect = transform <span class="keyword">as</span> RectTransform;</span><br><span class="line">            rect.sizeDelta = <span class="keyword">this</span>.sizeData;</span><br><span class="line">        &#125;</span><br><span class="line">        canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结——leetcode 1493 删除一个元素后全为1的最长子数组</title>
      <link href="/posts/ccbb3712.html"/>
      <url>/posts/ccbb3712.html</url>
      
        <content type="html"><![CDATA[<h1 id="1493-删掉一个元素以后全为-1-的最长子数组"><a href="#1493-删掉一个元素以后全为-1-的最长子数组" class="headerlink" title="1493. 删掉一个元素以后全为 1 的最长子数组"></a><a href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/">1493. 删掉一个元素以后全为 1 的最长子数组</a></h1><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="comment">//核心是 每一次都已遇见0都会默认删除，记录遇见的0的数量， 当滑动窗口内的0数量超过一个，，就会去缩减左边界，抛弃掉上一次删除的0就可以对新加入的0进行 删除操作，非常巧妙 000111011110111111，</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// cnt数组记录区间[j, i]中0和1的数量</span></span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cnt[nums[i]]++;</span><br><span class="line">            <span class="comment">// 缩小左端点j</span></span><br><span class="line">            <span class="keyword">while</span>(cnt[<span class="number">0</span>] &gt; <span class="number">1</span>) cnt[nums[j++]]--;</span><br><span class="line">            <span class="comment">// 必须删除一个元素，所以最终长度是i - j 而不是 i - j + 1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">     <span class="comment">//下面的是我本来的解法，和之前的区别在于只有一个 删除0 的标记，第二次遇见就会忽略，这可以在一定程序上解决连续0的问题，但是对于0111101111110111，这种问题就无能为力了</span></span><br><span class="line">     <span class="comment">//滑动窗口运行</span></span><br><span class="line"><span class="type">bool</span> isDel = <span class="literal">false</span>; <span class="comment">//确定是否删除内容，表现在结果上就是最后的结果-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!isDel)</span><br><span class="line">&#123;</span><br><span class="line">++right;</span><br><span class="line">isDel = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">max</span>(right - left, res);</span><br><span class="line">left = right;</span><br><span class="line">isDel = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0</span>) res = right - left;</span><br><span class="line"><span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="递推写法"><a href="#递推写法" class="headerlink" title="递推写法"></a>递推写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//递推写法</span></span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n)</span>, <span class="title">suf</span><span class="params">(n)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//采用枚举一个点位的方式，动态规划的思想无非就是 选或者不选、枚举 这两种，这种都是要求对子问题的要一致，使用 选或不选 子问题就不一致了，多了一个可以删除一个点的 条件，一个子问题使用后，另一个子问题就需要考虑，不合适。</span></span><br><span class="line"><span class="comment">//这个解法是使用枚举，枚举到的点就是要被删除的点，周围的是能计入结果的长度。</span></span><br><span class="line">pre[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">pre[i] = nums[i] ? pre[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//枚举到的点要被删除，因此除这以外遇见0都需要将和标记为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suf[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">suf[i] = nums[i] ? suf[i + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> preVal = i == <span class="number">0</span> ? <span class="number">0</span> : pre[i - <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> sufVal = i == n - <span class="number">1</span> ? <span class="number">0</span> : suf[i + <span class="number">1</span>];</span><br><span class="line">res = <span class="built_in">max</span>(res,preVal + sufVal);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递推优化</span></span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p0 = <span class="number">0</span>, p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                p1 = p0;</span><br><span class="line">                p0 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++p0;</span><br><span class="line">                ++p1;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            --ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递推优化的推导过程"><a href="#递推优化的推导过程" class="headerlink" title="递推优化的推导过程"></a>递推优化的推导过程</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240815181504.png" alt="image-20240815181457099"></p>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#技术————对象池和约束类型</title>
      <link href="/posts/c6094ab0.html"/>
      <url>/posts/c6094ab0.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><p>代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">RefreshDataPool</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">RefreshData</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> List&lt;T&gt; pool = <span class="keyword">new</span> List&lt;T&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (pool) <span class="comment">// 使用锁来确保线程安全（如果这是多线程环境的话）  </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool.Count &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 假设我们总是返回列表中的最后一个对象，并移除它以供重用  </span></span><br><span class="line">                    <span class="comment">// 注意：这可能会导致对象重用顺序的问题，您可能需要根据实际情况调整  </span></span><br><span class="line">                    T obj = pool[pool.Count - <span class="number">1</span>];</span><br><span class="line">                    pool.RemoveAt(pool.Count - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> obj;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 如果没有可用的对象，则创建一个新的对象  </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> T();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params">T obj</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            pool.Add(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="泛型方法参数"><a href="#泛型方法参数" class="headerlink" title="泛型方法参数"></a>泛型方法参数</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRefresh</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 页面数据刷新</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Refresh</span>&lt;<span class="title">T</span>&gt;(<span class="params">T data</span>) <span class="keyword">where</span> T : RefreshData&lt;T&gt;, <span class="keyword">new</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">RefreshDataBase</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RefreshData</span>&lt;<span class="title">T</span>&gt; : <span class="title">RefreshDataBase</span>, <span class="title">IDisposable</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">RefreshData</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 使用完成后记得释放</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            RefreshDataPool&lt;T&gt;.Push((T)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取事件</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> RefreshDataPool&lt;T&gt;.Get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 后台给前台UI传递数据用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StatusBarInfo</span> : <span class="title">RefreshData</span>&lt;<span class="title">StatusBarInfo</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> FunctionBarType type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要对下列数据进行的调整</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;(FunctionBarData, FunctionBarOperationType)&gt; operations = <span class="keyword">new</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现IRefresh接口的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Refresh</span>&lt;<span class="title">T</span>&gt;(<span class="params">T data</span>) <span class="keyword">where</span> T : RefreshData&lt;T&gt;, <span class="keyword">new</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> info = data <span class="keyword">as</span> ItemRefreshData; </span><br><span class="line">        <span class="keyword">if</span> (info.type == FunctionBarOperationType.Delete)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = info.data;</span><br><span class="line">            _itemName.text = <span class="keyword">this</span>.data.itemName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题目——动态规划——leetcode 3252 特殊数组2</title>
      <link href="/posts/1719aa5f.html"/>
      <url>/posts/1719aa5f.html</url>
      
        <content type="html"><![CDATA[<h1 id="3152-特殊数组-II"><a href="#3152-特殊数组-II" class="headerlink" title="3152. 特殊数组 II"></a><a href="https://leetcode.cn/problems/special-array-ii/">3152. 特殊数组 II</a></h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这种解法不是一个一个的对比，只要给定区间的一个踏入 非特殊数组的行列，这个是关键。</p><p>关键词，点位最近符合条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">last_same</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="comment">//核心思想是记录一个点位的左侧最近不是 特殊数组 的右边界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">last_same[i] = nums[i] % <span class="number">2</span> == nums[i - <span class="number">1</span>] % <span class="number">2</span> ? i : last_same[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">res</span><span class="params">(queries.size())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//排查该点位左侧距离最近的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; it = queries[i];</span><br><span class="line">res[i] = last_same[it[<span class="number">1</span>]] &lt;= it[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>一开始的想法是从给定的矩阵中进行枚举，这个时候再去加入计算，然后慢慢扩张 特殊数组 的边界，加入pair数组存储 特殊数组 边界断裂的情况。显而易见的是，每次查询一个进来的区域是不是 特殊数组 的时候都需要遍历一次 specialRange ，这个时候的区间确定逻辑比较复杂，因此淘汰，这种思路应用的区间思想有一个解，但是在时间复杂度上稍差。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = queries.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//左右指定区间扩展</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; specialRange; <span class="comment">//存储可能的区间</span></span><br><span class="line"> </span><br><span class="line">function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : queries)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><h3 id="区间合并方法的正解"><a href="#区间合并方法的正解" class="headerlink" title="区间合并方法的正解"></a>区间合并方法的正解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isArraySpecial</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; res;</span><br><span class="line">vector&lt;pii&gt; v; <span class="comment">//存放区间</span></span><br><span class="line">v.<span class="built_in">push_back</span>(&#123; <span class="number">0</span>,<span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((nums[i] % <span class="number">2</span>) != (nums[i - <span class="number">1</span>] % <span class="number">2</span>)) <span class="comment">//说明可以更新到区间中</span></span><br><span class="line">v.<span class="built_in">back</span>().y = i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">v.<span class="built_in">push_back</span>(&#123; i,i &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后开始进行二分，由于初始化就是有序的，固然不用再进行排序</span></span><br><span class="line"><span class="type">int</span> n = queries.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> target = queries[i][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) <span class="comment">//二段性：前面都符合，后面反之</span></span><br><span class="line">&#123; <span class="comment">//寻找右边界（找出最后一个满足v[mid].x&lt;=target的元素）</span></span><br><span class="line"><span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (v[mid].x &lt;= target) <span class="comment">//说明符合</span></span><br><span class="line">l = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后去判断</span></span><br><span class="line"><span class="keyword">if</span> (v[l].x &lt;= queries[i][<span class="number">0</span>] &amp;&amp; queries[i][<span class="number">1</span>] &lt;= v[l].y)</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#经验</title>
      <link href="/posts/f3dcfd73.html"/>
      <url>/posts/f3dcfd73.html</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类设置："><a href="#抽象类设置：" class="headerlink" title="抽象类设置："></a>抽象类设置：</h1><p>抽象类不要用作泛型，会影响最后在容器泛型中直接使用抽象类进行访问</p><p>对于可能需要的对子类的内容访问，可以使用接口或者抽象方法的形式，</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240812215707.png" alt="image-20240812215704428"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240812215815.png" alt="image-20240812215811336"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240812215909.png" alt="image-20240812215906099"></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口方法被抽象类实现后前面加上virtual关键字可以被抽象类的实现类重写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRefresh</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 页面数据刷新</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Refresh</span>&lt;<span class="title">T</span>&gt;(<span class="params">T data</span>) <span class="keyword">where</span> T : <span class="title">RefreshData</span>&lt;<span class="title">T</span>&gt;, <span class="keyword">new</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IRefresh</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Refresh</span>&lt;<span class="title">T</span>&gt;(<span class="params">T data</span>) <span class="keyword">where</span> T : <span class="title">RefreshData</span>&lt;<span class="title">T</span>&gt;, <span class="keyword">new</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Refresh</span>&lt;<span class="title">T</span>&gt;(<span class="params">T info</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">       <span class="keyword">base</span>.Refresh();  </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AddressAble使用经验</title>
      <link href="/posts/f6384f1b.html"/>
      <url>/posts/f6384f1b.html</url>
      
        <content type="html"><![CDATA[<h1 id="AddressAble"><a href="#AddressAble" class="headerlink" title="AddressAble"></a>AddressAble</h1><h2 id="资源配置"><a href="#资源配置" class="headerlink" title="资源配置"></a>资源配置</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240812214816.png" alt="image-20240812214813889"></p><p>不同的Group对应最后要打的不同的AB包，每个文件最前面显示的就是对应的key，可以通过key来直接进行访问</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240812214532.png" alt="image-20240812214528628"></p><p>一般对于选中的资源都是默认使用路径资源，右键鼠标点击下图红框中间的按钮可以简化名称</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240812214717.png" alt="image-20240812214713691"></p><h2 id="加载代码"><a href="#加载代码" class="headerlink" title="加载代码"></a>加载代码</h2><p>建议参考</p><p><a href="https://blog.csdn.net/Czhenya/article/details/126873219">Unity 之 Addressable可寻址系统 – 代码加载介绍 – 进阶（一）_unity addressable-CSDN博客</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 使用Addressables.LoadAssetAsync来异步加载资源</span></span><br><span class="line">     AsyncOperationHandle&lt;T&gt; handle = Addressables.LoadAssetAsync&lt;T&gt;(path);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 等待加载操作完成</span></span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> handle.Task ;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//加载成功后把数据发送回去</span></span><br><span class="line">                <span class="keyword">if</span> (handle.Status == AsyncOperationStatus.Succeeded)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>  handle.Result <span class="keyword">as</span> T;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐使用下面这种，第一种总是出错，还只能在Start函数中运行，真是烦人，不要返回句柄</span></span><br><span class="line">Addressables.LoadAssetAsync&lt;T&gt;(path).Completed += (obj) =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.Log(obj.Result);</span><br><span class="line">                    <span class="built_in">string</span> key = path + <span class="string">&quot;_&quot;</span> + <span class="keyword">typeof</span>(T).Name;</span><br><span class="line">                    <span class="keyword">if</span> (resDic.ContainsKey(key))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ResInfo&lt;T&gt; resInfo = resDic[key] <span class="keyword">as</span> ResInfo&lt;T&gt;;</span><br><span class="line">                        resInfo.asset = obj.Result <span class="keyword">as</span> T;</span><br><span class="line"></span><br><span class="line">                        resInfo.callBack?.Invoke(resInfo.asset);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//加载完毕后 清空引用</span></span><br><span class="line">                        resInfo.callBack = <span class="literal">null</span>;</span><br><span class="line">                        resInfo.coroutine = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br></pre></td></tr></table></figure><p>加载资源的注意点：</p><p>1.不接受用抽象父类去加载子类</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Plugins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity网络游戏——Fisnet入门</title>
      <link href="/posts/984b9fd0.html"/>
      <url>/posts/984b9fd0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Fisnet-入门"><a href="#Fisnet-入门" class="headerlink" title="Fisnet 入门"></a>Fisnet 入门</h1><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>服务器权威：数据改变只能在服务器上发生，</p><p>客户端权威：数据的改变可以在客户端上发生，意思是客户端也可以作为一个服务器</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240806220346.png" alt="image-20240806220340377" style="zoom:50%;" /><h2 id="关键性组件"><a href="#关键性组件" class="headerlink" title="关键性组件"></a>关键性组件</h2><ol><li>NetWorkManager：可以在插件中预先设置的prefab中找到该名称的预制件，拖拽到场景管理器中，不做任何对象的子对象和父对象</li></ol><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240806211110.png" alt="image-20240806211105999"></p><p>2.NetworkObject：需要进行网络同步的对象添加该组件即可</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240806211424.png" alt="image-20240806211420248"></p><p>3.NetworkTransform：在网络中同步该对象的Transform 变化信息</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240806211513.png" alt="image-20240806211509257"></p><h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><h3 id="NetWorkBehaviour"><a href="#NetWorkBehaviour" class="headerlink" title="NetWorkBehaviour"></a>NetWorkBehaviour</h3><p><img src="C:/Users/LENOVO/AppData/Roaming/Typora/typora-user-images/image-20240806221416057.png" alt="image-20240806221416057"></p><p>本机判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!base.IsOwner)  <span class="comment">//区分不同客户端，不让在联机的时候一次控制所有Player</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">float</span> hor = Input.<span class="built_in">GetAxisRaw</span>(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="type">float</span> ver = Input.<span class="built_in">GetAxisRaw</span>(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* If ground cannot be found for 20 units then bump up 3 units. </span></span><br><span class="line"><span class="comment">         * This is just to keep player on ground if they fall through</span></span><br><span class="line"><span class="comment">         * when changing scenes.             */</span></span><br><span class="line">        <span class="keyword">if</span> (_clientAuth || (!_clientAuth &amp;&amp; base.IsServerStarted))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Physics.<span class="built_in">Linecast</span>(transform.position + <span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0</span>f, <span class="number">0.3f</span>, <span class="number">0</span>f), transform.position - (Vector<span class="number">3.</span>one * <span class="number">20</span>f)))</span><br><span class="line">                transform.position += <span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0</span>f, <span class="number">3</span>f, <span class="number">0</span>f);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (_clientAuth)</span><br><span class="line">            <span class="built_in">Move</span>(hor, ver);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">ServerMove</span>(hor, ver);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="代表操作"><a href="#代表操作" class="headerlink" title="代表操作"></a>代表操作</h2><h3 id="在指定位置生成Player对象"><a href="#在指定位置生成Player对象" class="headerlink" title="在指定位置生成Player对象"></a>在指定位置生成Player对象</h3><p>如下图，在场景管理器中选择手动拖拽放置的游戏对象到下图红框区域的Spawns</p><p>首先需要在PlayerPrefab选择自己制作的玩家预制件</p><p>这个组件并不是唯一指定操作，可以自己手动创建一个，这个就可以作为参考对象</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240807234830.png" alt="image-20240806223043238" style="zoom: 67%;" /><h3 id="常规生成对象"><a href="#常规生成对象" class="headerlink" title="常规生成对象"></a>常规生成对象</h3><p>Player的移动是被一个额外的组件控制着，同时那个组件上还有对权威的控制，如果需要生成对象就建议使用这个了</p><p>同时还还需要注意位置的差异，直接在Player本身上生成会收到缩放影响</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240807234852.png" alt="image-20240807234849039"></p><h3 id="动画同步"><a href="#动画同步" class="headerlink" title="动画同步"></a>动画同步</h3><p>只需要在角色上新加入一个组件就可以了</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240809101401.png" alt="image-20240809101357605"></p><h3 id="组件冲突"><a href="#组件冲突" class="headerlink" title="组件冲突"></a>组件冲突</h3><p>使用物理组件和NetWorkTransform进行角色控制的时候，客户端这边会受到冲突，物理组件和网络位置控制会同时修改Transform中的位置信息，再加上网络延迟，会造成移动到一半又被网络位置控制影响</p><p>提示：mesh collider </p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240809112244.png" alt="image-20240809112240847"></p><p>同步参数</p><p>不同于手动设置Unity消息去实现内容变化响应的功能，应该是固定的标签，对于同步变量这个东西应该绑定了对应的客户端</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240809185400.png" alt="image-20240809151041175"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240809151332.png" alt="image-20240809151327641"></p><p>同步变量的理解：还是需要进行远程过程请求，因为同步字段在最开始就限制着，就算是按照官方文档上的要求添加上了  WritePermission.ClientUnsynchronized  字段允许在本地进行修改，这样的结果不会被同步到客户端上。</p><p>ServerRpc很重要</p><h2 id="客户端预测："><a href="#客户端预测：" class="headerlink" title="客户端预测："></a>客户端预测：</h2><p>等待</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>题型解法总结——动态规划</title>
      <link href="/posts/20d90550.html"/>
      <url>/posts/20d90550.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805162532.png" alt="image-20240805162519768"></p><p>这道题是一个典型的01背包问题，只是在处理的时候遇到了递增和递减的问题，最开始很不理解的原因是我对dp的二维数组填充过程以及依赖关系没有明确清晰的认知，再加上在对找零钱这道题目中有递增操作的影响下，一直没能顺利写出正确的过程来。长话短说，这里主要涉及到一个本回合要选择的价值内容对上一轮次的占用问题。</p><p>请看如下期望的递增模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(target + <span class="number">1</span>, INT_MIN)</span></span>;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f[j - x] != INT_MIN)</span><br><span class="line">&#123;</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j - x] + <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[j]&lt;&lt;<span class="string">&quot; , &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[target] &gt; <span class="number">0</span> ? f[target] : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805162930.png" alt="image-20240805162926074"></p><p>在需求的第二行中就出现了 嵌套循环第二层中引用了被之前修改的数据，主要出现在 动态规划朝着 一维滚动数据的优化 的过程中出现的，</p><p>再来看所谓的零钱兑换，它并不在乎在本次引用了本次修改的数据，因为一个位置可以重复使用这个特性的存在，使得重复引用变得是重复使用这个索引上的零钱数量。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805163459.png" alt="image-20240805163455560"></p><h3 id="具体细则"><a href="#具体细则" class="headerlink" title="具体细则"></a>具体细则</h3><h4 id="空间优化中的注意事项"><a href="#空间优化中的注意事项" class="headerlink" title="空间优化中的注意事项"></a>空间优化中的注意事项</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805195506.png" alt="image-20240805195501745"></p><h4 id="递推中的注意事项"><a href="#递推中的注意事项" class="headerlink" title="递推中的注意事项"></a>递推中的注意事项</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805195829.png" alt="image-20240805195825737"></h4><p>同时注意在memo容器中对于初始化值的设定，建议在设定为0</p><p>在lamba中与遇见超过 int 与long long 这种涉及越界的问题，建议对加减后变成负数这种情况做出以下限定</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240806152859.png" alt="image-20240806152854844"></p><p>同时lamba表达式变量名的申请并不是注明了返回值，需要在实际使用中 -&gt; bool 来进行类型指定，如此，就可以使用 int 中的 0 和 1来代表 bool 中发 false 和 true</p><h2 id="经典线性DP"><a href="#经典线性DP" class="headerlink" title="经典线性DP"></a>经典线性DP</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>最长公共子序列</p><h4 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240806155702.png" alt="image-20240806155658543"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240806155755.png" alt="image-20240806155751436"></p><p>问题1：公式给定的是x+1个结构必定要比x的结果要大，从给定例子中来看，无论是选或者不选，都会造成结果变小，矛盾。</p><p>问题2：靠近下边的菱形结构是在表示如果不相同，则下一轮就会考虑到后面的都不选这种情况，所以不要在不相同的时候考虑问题给定情况</p><h4 id="最终公式"><a href="#最终公式" class="headerlink" title="最终公式"></a>最终公式</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240806160650.png" alt="image-20240806160646766"></p><h4 id="一维数组代码"><a href="#一维数组代码" class="headerlink" title="一维数组代码"></a>一维数组代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = text<span class="number">1.l</span>ength(), n = text<span class="number">2.l</span>ength();</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : text1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// int index = c - &#x27;a&#x27;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, pre = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = dp[i];</span><br><span class="line">dp[i] = c == text2[i - <span class="number">1</span>] ? pre + <span class="number">1</span> : <span class="built_in">max</span>(dp[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">pre = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br></pre></td></tr></table></figure><h4 id="一维数组优化思考"><a href="#一维数组优化思考" class="headerlink" title="一维数组优化思考"></a>一维数组优化思考</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240806164632.png" alt="image-20240806164629202"></p><p>所以这点跟之前的普通的01背包问题还是存在区别的，这道题目本身对于左边的数据本身就要求是同行的，所以计算后的覆盖才是有效的。</p><h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><p>记忆这种套路的重要目标是 核心公式 的选择思想，不要一上来就尝试套公式，从一开始的分析问题，判断条件是充分且必要的。</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小ASCII删除和</a></p><p>这道题目的核心公式没有太大的改变，依旧是一致就都选上，不一样就分情况迭代。重要的是前置条件的准备，因为最后要求的结果在删除掉的字符的ASCII和的最小值，从这里开始需要有一个条件需要注意一下，有两个字符串，s1 ，s2</p><p>s1，s2为空的情况：这种情况对于计算最长相等子串没有影响，最后返回 0 即可，但是本题的需求在一方为空情况下，需要记录的ASCII也会发生改变。</p><p>对于s1，s2不同的为空情况，代码实现中都有对应的注释</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp 空间优化，还是再强调一次，开始之前要思考</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> m = s<span class="number">1.l</span>ength();</span><br><span class="line"><span class="type">int</span> n = s<span class="number">2.l</span>ength();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//在s1为空的情况下，需要将s2逐索引删除的ASCII和递增</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i + <span class="number">1</span>] = dp[i] + s2[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> x : s1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pre = dp[<span class="number">0</span>]; <span class="comment">//在s2为空的前提下，记录下本次s1逐索引删除到空的ASCII和，但是在这之前要保存对应的左上角</span></span><br><span class="line">dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = dp[i];</span><br><span class="line">dp[i] = x == s2[i - <span class="number">1</span>] ? pre : <span class="built_in">min</span>(dp[i] + x, dp[i - <span class="number">1</span>] + s2[i - <span class="number">1</span>]);</span><br><span class="line">pre = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br></pre></td></tr></table></figure><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><h4 id="思考过程-1"><a href="#思考过程-1" class="headerlink" title="思考过程"></a>思考过程</h4><p>子序列属于子集型问题，解决问题的方式采用子集型回溯，尝试的方式有两种，选择，枚举，这里采用的方式是枚举。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240807155238.png" alt="image-20240807153343916"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归加上记忆化搜索</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line"><span class="type">int</span>&amp; res = memo[i];</span><br><span class="line"><span class="keyword">if</span> (res &gt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ++res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;        </span><br><span class="line"></span><br><span class="line"><span class="comment">//递推</span></span><br><span class="line">     <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[j]&lt;nums[i]) </span><br><span class="line">                &#123;</span><br><span class="line">                    memo[i] = <span class="built_in">max</span>(memo[i],memo[j]);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">memo[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ranges::<span class="built_in">max</span>(memo);</span><br></pre></td></tr></table></figure><p>这道例题和之前讲过的最长子序列是关联的，将数组排序后再去求得LCS就是LIS。（LCS是最长子序列，LIS是最长递增子序列）。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240807155233.png" alt="image-20240807153135739"></p><h4 id="时间复杂度优化"><a href="#时间复杂度优化" class="headerlink" title="时间复杂度优化"></a>时间复杂度优化</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240807155231.png" alt="image-20240807155226654"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240807155348.png" alt="image-20240807155345407"></p><p>因为最后重复的子问题，所以最终的解决方法是贪心算法加上二分查找</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//额外空间</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; g;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">      <span class="keyword">auto</span> it = ranges::<span class="built_in">lower_bound</span>(g, x); <span class="comment">//在指定的排序完成的容器找找到第一个比x大的数并返回迭代器</span></span><br><span class="line">      <span class="keyword">if</span> (it == g.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          g.<span class="built_in">push_back</span>(x); <span class="comment">// &gt;=x 的 g[j] 不存在</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          *it = x;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//原地算法</span></span><br><span class="line"> <span class="keyword">auto</span> end = nums.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">      <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), end, x);</span><br><span class="line">      *it = x;</span><br><span class="line">      <span class="keyword">if</span> (it == end) &#123; <span class="comment">// &gt;=x 的 g[j] 不存在</span></span><br><span class="line">          ++end;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> end - nums.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>该问题模型可以处理的问题总结 </p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240912154158.png" alt="image-20240912154149712" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 解法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 解法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题型总结</title>
      <link href="/posts/6c2c1ad3.html"/>
      <url>/posts/6c2c1ad3.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805162532.png" alt="image-20240805162519768"></p><p>这道题是一个典型的01背包问题，只是在处理的时候遇到了递增和递减的问题，最开始很不理解的原因是我对dp的二维数组填充过程以及依赖关系没有明确清晰的认知，再加上在对找零钱这道题目中有递增操作的影响下，一直没能顺利写出正确的过程来。长话短说，这里主要涉及到一个本回合要选择的价值内容对上一轮次的占用问题。</p><p>请看如下期望的递增模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(target + <span class="number">1</span>, INT_MIN)</span></span>;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f[j - x] != INT_MIN)</span><br><span class="line">&#123;</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j - x] + <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[j]&lt;&lt;<span class="string">&quot; , &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[target] &gt; <span class="number">0</span> ? f[target] : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805162930.png" alt="image-20240805162926074"></p><p>在需求的第二行中就出现了 嵌套循环第二层中引用了被之前修改的数据，主要出现在 动态规划朝着 一维滚动数据的优化 的过程中出现的，</p><p>再来看所谓的零钱兑换，它并不在乎在本次引用了本次修改的数据，因为一个位置可以重复使用这个特性的存在，使得重复引用变得是重复使用这个索引上的零钱数量。</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805163459.png" alt="image-20240805163455560"></p><h2 id="具体细则"><a href="#具体细则" class="headerlink" title="具体细则"></a>具体细则</h2><h3 id="空间优化中的注意事项"><a href="#空间优化中的注意事项" class="headerlink" title="空间优化中的注意事项"></a>空间优化中的注意事项</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805195506.png" alt="image-20240805195501745"></p><h3 id="递推中的注意事项"><a href="#递推中的注意事项" class="headerlink" title="递推中的注意事项"></a>递推中的注意事项</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240805195829.png" alt="image-20240805195825737"></p><p>同时注意在memo容器中对于初始化值的设定，建议在设定为0</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>左神算法——位运算</title>
      <link href="/posts/9f6b4be2.html"/>
      <url>/posts/9f6b4be2.html</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ol><li>组合起来n如果是负数就返回0，非负数就返回1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请保证参数n，不是1就是8的情况下</span></span><br><span class="line"><span class="comment">//1 -&gt;@//0-&gt;1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n^<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n是非负数，返回1// n是负数，返回8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sign</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> filp( (n&gt;&gt;<span class="number">31</span>) &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h3><p>给定两个有符号int a b，返回其中 较大的，不要进行比较</p><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731124530.png" alt="image-20240731124525913"></p><p>配合上技巧1里面的判断符号位正反的代码</p><p>解法存在问题，a - b可能溢出，但是可以提醒 互斥条件的使用 可以模拟 ifelse</p><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731145606.png" alt="image-20240731145601725"></p><p>关键性代码解析，对于return A 等号右侧公式解读：ab的符号不同，并且a是正数的情况下 以及 ab符号相同并且ab差值大于零的情况下，</p><p>至于return B 则是反过来就可以了</p><h3 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h3><p>判断一个32位的正数是不是2的幂，4的幂</p><h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><p>2的幂就代表在二进制数中只有一个位置上是1，其余位置都是0</p><h4 id="求解2的幂"><a href="#求解2的幂" class="headerlink" title="求解2的幂"></a>求解2的幂</h4><h5 id="解法1-1"><a href="#解法1-1" class="headerlink" title="解法1"></a>解法1</h5><p>取出该数最右侧的一，看不够和原来的数香氛就习了，取出最右侧1的公式：p&amp;(~p +1) </p><h5 id="解法2-1"><a href="#解法2-1" class="headerlink" title="解法2"></a>解法2</h5><p>假设p是2的幂，那么二进制上就只有一个1，p-1就会将原来的 1 打散掉，这个时候 p &amp;(p-1) &#x3D;&#x3D;0</p><h4 id="求解4的幂"><a href="#求解4的幂" class="headerlink" title="求解4的幂"></a>求解4的幂</h4><p>先判断二进制是否只有一个1，然后 &amp; x (x是第一个三十二位二进制数，以 01 为规律组成，十六进制表示是 0x55555555 )，如果不等于0，就代表是4的幂，因为4的唯一一个1所在的位置都是前面给定二进制数的固定位置上</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731153024.png" alt="image-20240731153019611"></p><h3 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h3><p>给定两个32有符号整数，不使用算数运算符，完成相应的加、减、乘 、除操作。不需要处理正常算数运算符运算产生的溢出</p><h4 id="加"><a href="#加" class="headerlink" title="加"></a>加</h4><p><img src="/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BD%8D%E8%BF%90%E7%AE%97.assets/image-20240731154119767.png" alt="image-20240731154119767"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731154536.png" alt="image-20240731154531980"></p><h4 id="减"><a href="#减" class="headerlink" title="减"></a>减</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731154833.png" alt="image-20240731154829576"></p><h4 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731155313.png" alt="image-20240731155308809"></p><p>代码</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731160208.png" alt="image-20240731160204150"></p><h5 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h5><p>在java中可以使用 &gt;&gt;&gt; 作为无符号位移操作符，可以在对一个数进行二进制位移的时候排除符号位干扰，在最左侧默认添加0</p><h4 id="除"><a href="#除" class="headerlink" title="除"></a>除</h4><h5 id="解法1-2"><a href="#解法1-2" class="headerlink" title="解法1"></a>解法1</h5><p>除法流产是相对于乘法而言的，乘法是不停的将一个因子按照另一个因子每一位的状态向左位移，最后在求和。除法则是将被除数看做乘 法的结果，将除数看做乘法中向左位移的因子。a&#x2F;b，将b的二进制向左移动到b最大的 a &gt; b的状态，c &#x3D;a- 新b，然后新b再以c做标准向左位移，重复之前的步骤。</p><h5 id="解法2-2"><a href="#解法2-2" class="headerlink" title="解法2"></a>解法2</h5><img src="%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BD%8D%E8%BF%90%E7%AE%97.assets/image-20240731162508965.png" alt="image-20240731162508965" style="zoom:50%;" /><p>如图，a&#x2F;b，第一步将b向左移动31位，看a能否减掉b，不能不减，b左移30位，重复以上步骤，直到第一次能减掉，这个时候才真去减，这时b向左移动x位，x位就是1，之后重复以上步骤。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731164005.png" alt="image-20240731164002755"></p>]]></content>
      
      
      <categories>
          
          <category> 左神算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alogrithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左神算法——大数据题目</title>
      <link href="/posts/f4330aac.html"/>
      <url>/posts/f4330aac.html</url>
      
        <content type="html"><![CDATA[<h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="常见数据"><a href="#常见数据" class="headerlink" title="常见数据"></a>常见数据</h2><ol><li>2的32次方差不多是42亿</li><li>int类型的范围是 2的32次方 -1</li></ol><h2 id="技巧罗列"><a href="#技巧罗列" class="headerlink" title="技巧罗列"></a>技巧罗列</h2><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240730160959.png" alt="image-20240730155007063"></p><ol><li>哈希函数分流思想是万能的</li><li>这类题严格意义上讲的内存限制题目，并且只有以上几种套路，是面试过程中最好准备的</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>32位无符号整数的范围是0~4,294,967.295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。可以使用最多1GB的内存，怎么找到所有未出现过的数?<br>【进阶】<br>内存限制为 10MB，但是只用找到一个没出现过的数即可</p><h4 id="空间充足"><a href="#空间充足" class="headerlink" title="空间充足"></a>空间充足</h4><p>哈希表一个一个存储 </p><h4 id="空间紧凑"><a href="#空间紧凑" class="headerlink" title="空间紧凑"></a>空间紧凑</h4><p>利用int类型来作为byte数组，校验范围内每一个数是否出现，并且由于是索引判断，更新速度很快，最后只需要遍历一次byte数组即可</p><h4 id="空间非常紧凑"><a href="#空间非常紧凑" class="headerlink" title="空间非常紧凑"></a>空间非常紧凑</h4><p>在给定的范围内求最大可以分成多长的int数组，得出的结果向下取一个最近的2的整数次幂，指数的大小就是数组的大小。然后用该数组对给定的数进行分割，可以使用 &#x2F; 操作，获取对应的索引并将该位置上的值++，最后有不满足最大值的就是缺了，然后对于确定是缺少数组的范围再次进行上述操作，不同的是这次不在这个范围内的数不放进去，同时对这个范围的数 进行 &#x2F; 操作求得索引，周而复始，最后一定能定位到没有出现的数字</p><h4 id="最最极端"><a href="#最最极端" class="headerlink" title="最最极端"></a>最最极端</h4><p>只能申请有限变量</p><p>对int的范围进行一个二分操作，校验范围内落在两边数据的数量，那边不够就是落在那边，依次二分。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后两个最多需要跑32次整体数据</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>某搜索引擎公司一天有上百亿条数据，求出100Top的热词</p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>哈希函数分流，对每一个文件区间内通过哈希表的形式进行计算，求得当前文件内的100Top，最后做一个整合。</p><p>由于哈希函的性质，对于key值一样的来说，只会得到同样的哈希值，相同的url词汇只会出现在一个区间内</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240730170821.png" alt="image-20240730170737200"></p><p>如上图所示，是该题目的具体过程，每次从总大根堆中弹出堆顶元素，然后将该元素对应的小文件的大根堆堆顶进行弹出，并将新的堆顶元素加入的总堆中去</p><p>同时因为堆的结构，相应的调整代价很低</p><p>这种堆上套堆的结构被称为二维堆。 </p><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。<br>【补充】<br>可以使用最多10MB的内存，怎么找到这40亿个整数的中位数?</p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><ol><li>哈希表分流</li><li>位图表示，使用两位来表示一个数的出现次数，正好一个G可以用完</li><li>分段统计，见问题1的第三种空间限制解法，稍微改变策略，最后对词频进行求和操作，根据数据总量来找到中位数出现的范围，然后依次进行之前的操作</li></ol><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>对海量的数据进行词频排序操作 –据说是腾讯二面原题</p><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>主要应用的是问题1中第三种情况，将给定的空间按照 最小操作数 的大小进行划分，不同于问题1的第三种情况，这里不再不需要分段统计，因为题目要求的是升序词频输出，具体思路流程见下图解析</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731111039.png" alt="image-20240731111034999"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731105755.png" alt="image-20240731105750012"></p><p>还需要强调的是 2的27次方-1这个操作，实际上还是为了和2的31次方-1这种有符合int最大值做一个匹配 </p><p>每一次出区间划分都将内容按照小的去全检挑选出来</p><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240731113128.png" alt="image-20240731113124947"></p>]]></content>
      
      
      <categories>
          
          <category> 左神算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alogrithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左神算法——并查集，KMP，Manacher</title>
      <link href="/posts/d968e671.html"/>
      <url>/posts/d968e671.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="并查集，KMP，Manacher——左神算法"><a href="#并查集，KMP，Manacher——左神算法" class="headerlink" title="并查集，KMP，Manacher——左神算法"></a>并查集，KMP，Manacher——左神算法</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>并查集是把原有的链表结构重新优化，按照图的上一个node来进行保存</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725184045.png" alt="image-20240725163127020"></p><ul><li><pre><code class="java">  import java.util.HashMap;  import java.util.List;  import java.util.Stack;    /**     * @Author laimouren   * @Date 2021/12/7 19:35     */     public class UnionFind &#123;     //样本进来会包一层，叫做元素     public static class Element&lt;V&gt;&#123;         public V value;         public Element(V value)&#123;             this.value = value;         &#125;     &#125;     public static class UnionFindSet&lt;V&gt;&#123;         //值和element的对应关系         public HashMap&lt;V,Element&lt;V&gt;&gt; elementMap;         //key 某个元素 value 该元素的父亲         public HashMap&lt;Element&lt;V&gt;,Element&lt;V&gt;&gt; fatherMap;         //key 某个集合的代表元素，value 该集合的大小         public HashMap&lt;Element&lt;V&gt;,Integer&gt; sizeMap;         public UnionFindSet(List&lt;V&gt; list)&#123;             elementMap = new HashMap&lt;&gt;();             fatherMap = new HashMap&lt;&gt;();             sizeMap = new HashMap&lt;&gt;();             for (V value : list) &#123;                 Element&lt;V&gt; element = new Element&lt;V&gt;(value);                 elementMap.put(value,element);                 fatherMap.put(element,element);                 sizeMap.put(element,1);             &#125;         &#125;  //给定一个ele，往上一直找，将代表元素返回  //调用该函数越频繁，查找的时间复杂度就为O（1）  private Element&lt;V&gt; findHead(Element&lt;V&gt; element)&#123;      Stack&lt;Element&lt;V&gt;&gt; path = new Stack&lt;&gt;();      while (element != fatherMap.get(element))&#123;          path.push(element);          element = fatherMap.get(element);      &#125;      //将遍历的整条链的父都设置为找到的代表元素      //即将其扁平化(向上找优化)      //这一步即是对并查集的时间复杂度进行一个优化，类似于一个蒲公英结构，大量的点连接到中间点      while (!path.isEmpty())&#123;          fatherMap.put(path.pop(),element);      &#125;      return element;  &#125;    public boolean isSameSet(V a,V b)&#123;      if(elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b))&#123;          return findHead(elementMap.get(a)) == findHead(elementMap.get(b));      &#125;      return false;  &#125;    public void union(V a,V b)&#123;      if(elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b))&#123;          Element&lt;V&gt; aF = findHead(elementMap.get(a));          Element&lt;V&gt; bF = findHead(elementMap.get(b));          if(aF != bF)&#123;              Element&lt;V&gt; big = sizeMap.get(aF) &gt;= sizeMap.get(bF) ? aF : bF;              Element&lt;V&gt; small = big == aF ? bF : aF;              fatherMap.put(small,big);              sizeMap.put(big,sizeMap.get(aF) + sizeMap.get(bF));              sizeMap.remove(small);          &#125;      &#125;  &#125;  &#125;  &#125;    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">    #### 趣味补充：</span><br><span class="line"></span><br><span class="line">* &lt;img src=&quot;https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725185840.png&quot; alt=&quot;image-20240725185839223&quot; style=&quot;zoom:25%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    N= 10^80，这个数逼近宇宙的原子数量，图片中央公式的返回值不超过6</span><br><span class="line"></span><br><span class="line">### 使用并查集去建立并行算法（使用多核cpu运行算法），</span><br><span class="line"></span><br><span class="line">例题leetcode 200 岛屿数量</span><br><span class="line"></span><br><span class="line">1，按照单核cpu的解法求出各个分片的结果</span><br><span class="line"></span><br><span class="line">2，记录边界点上被感染的点是最开始被哪个点感染的</span><br><span class="line"></span><br><span class="line">3，使用并查集在合并的时候进行操作</span><br><span class="line"></span><br><span class="line">![image-20240725191849517](https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725191850.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## KMP</span><br><span class="line"></span><br><span class="line">### 算法背景：</span><br><span class="line"></span><br><span class="line">判断一个str1是不是str2的子串</span><br><span class="line"></span><br><span class="line">解决如下问题</span><br><span class="line"></span><br><span class="line">![image-20240725194222536](https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725194223.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 概念引入</span><br><span class="line"></span><br><span class="line">#### 最长相等前后缀</span><br><span class="line"></span><br><span class="line">在继续进行之前需要首先了解一个概念： 最长前后缀相等长度。使用过程：有一个字符串，使用头尾双指针，依次向中间靠拢，保存可以让头尾指针走过的地方相等的最长长度，排除字符串本身的长度。字符串长度为本身长度没有意义，前后指针走过的距离长度形成的字符串不是回文的那种形式，对比遍历字符串的方向是一致的。</span><br><span class="line"></span><br><span class="line">![image-20240725195104582](https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725195105.png)</span><br><span class="line"></span><br><span class="line">#### next arr</span><br><span class="line"></span><br><span class="line">##### 建立</span><br><span class="line"></span><br><span class="line">str2是两个字符串中短的那个，这个步骤中需要求出的东西是next arr，这个数组每个位置的含义是，该位置之前的字符串最长前后缀相等长度，类似于迭代器中的end（），并不是说这个位置为null，而是不采用</span><br><span class="line"></span><br><span class="line">注意：i位置上的数字代表的是之前的字符串上的最长前后缀</span><br><span class="line"></span><br><span class="line">![image-20240725200337865](https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725200339.png)</span><br><span class="line"></span><br><span class="line">##### 使用方法</span><br><span class="line"></span><br><span class="line">next arr的具体使用方法，在str1中查找str2，知道s位置，才找到一个不同的char，这个时候str2中对比的指针需要挪到当前段最长前缀的下一个索引位置，即箭头所指位置，str1中s位置保持不变，继续比对，相当于从str1中中间位置被圈出来的a开始匹配</span><br><span class="line"></span><br><span class="line">![image-20240726154437319](https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240726154438.png)</span><br><span class="line"></span><br><span class="line">##### 证明</span><br><span class="line"></span><br><span class="line">证明被跳过的最长前缀中的任何一点都不可能匹配出一个完整是str2出来。点“j”是匹配的新的起始点。在i到j之间任意一点开始往后都不可能匹配出str2。举例：任选点k，从k到x匹配上，因为原来str2是匹配到y为止才不一致，所以在对于str1，在X之前可以匹配上，这个时候最长前后缀长度是确定的，就是目前所给出的，，如果从k到x可以匹配上，就说明在这段内的前后缀长找到个更长的，这是不可能的，因此推断出这段不可能匹配出来。 </span><br><span class="line"></span><br><span class="line">![image-20240726154358837](https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240726154400.png)</span><br><span class="line"></span><br><span class="line">##### 求解</span><br><span class="line"></span><br><span class="line">next arr的0和1索引位置都是人为规定的，-1和0，-1是代表不能再继续条状，0是因为最长前后缀不能等于本身的长度，在这之后前后缀索引计算都可以使用之前计算的长度，步骤如下：</span><br><span class="line"></span><br><span class="line">当前索引来到 i 位置，i-1位置需要加入计算，使用i-1位置上的最长前后缀点的位置，因为数组0是起始索引，所以判断str2【next【i-1】】 == str2【i-1】，true就使用i-1位置上上的值并加1，false则需要在next【i-1】的结果为索引，返回执行以上过程，直到遇到边界条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">int i = 2;</span><br><span class="line">      //拿cn字符和i-1的字符比</span><br><span class="line"> int cn = 0; </span><br><span class="line">while(i &lt; ms.length)&#123;</span><br><span class="line">if(ms[i - 1] == ms[cn]) &#123;</span><br><span class="line">    //next[i] = cn + 1;</span><br><span class="line">    //i++;</span><br><span class="line">    //cn++;此时cn值是next[i-1]的值，这个i是更新后的i</span><br><span class="line">    next[i++] = ++cn;</span><br><span class="line">&#125;</span><br><span class="line">//当前跳到cn位置的字符，和i-1位置的字符配不上</span><br><span class="line">//cn得往前跳，即它的k值</span><br><span class="line">else if(cn &gt; 0) &#123;</span><br><span class="line">    cn = next[cn];</span><br><span class="line">&#125;</span><br><span class="line">//cn &lt;= 0，没办法往前跳了</span><br><span class="line">//此时next[i]为0</span><br><span class="line">else &#123;</span><br><span class="line">    next[i++] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240726171948.png" alt="image-20240726171947560"></p><p>同样的道理，根据最后kmp算法整体的时间复杂度的证明，求得next arr的时间复杂度是线性的，时间复杂度为O（N)。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> laimouren</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/7 21:41</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">   <span class="comment">//N &gt;= M</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndexOf</span><span class="params">(String s, String m)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s == <span class="literal">null</span> || m == <span class="literal">null</span> || m.length() &lt; <span class="number">1</span> || s.length() &lt; m.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">char</span> [] str1 = s.toCharArray();</span><br><span class="line">       <span class="type">char</span> [] str2 = m.toCharArray();</span><br><span class="line">       <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//O(M)</span></span><br><span class="line">       <span class="type">int</span> [] next = getNextArray(str2);</span><br><span class="line">       <span class="comment">//O(N)</span></span><br><span class="line">       <span class="keyword">while</span>(i1 &lt; str1.length &amp;&amp; i2 &lt; next.length)&#123;</span><br><span class="line">           <span class="comment">//匹配则str1和str2都加一</span></span><br><span class="line">           <span class="keyword">if</span>(str1[i1] == str2[i2])&#123;</span><br><span class="line">               i1++;</span><br><span class="line">               i2++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//str2当前位置为0，等同与i2 == 0</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(next[i2] == -<span class="number">1</span>)&#123;</span><br><span class="line">               i1++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//此时str1和str2不匹配，通过nextArray往前跳，得到i2应该在的下一个位置</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               i2 = next[i2];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//i2越界则匹配成功，结果为i1-i2; 否则i1越界了，此时匹配失败，返回-1</span></span><br><span class="line">       <span class="keyword">return</span> ((i2 == str2.length) ? (i1 - i2) : -<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取next数组</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] getNextArray(<span class="type">char</span> [] ms)&#123;</span><br><span class="line">      <span class="comment">//人为规定第一个为-1</span></span><br><span class="line">      <span class="keyword">if</span>(ms.length == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> [] next = <span class="keyword">new</span> <span class="title class_">int</span>[ms.length];</span><br><span class="line">      next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//人为规定第一个为0</span></span><br><span class="line">      next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//next数组的位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="comment">//拿cn字符和i-1的字符比</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">cn</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(i &lt; ms.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(ms[i - <span class="number">1</span>] == ms[cn]) &#123;</span><br><span class="line">    <span class="comment">//next[i] = cn + 1;</span></span><br><span class="line">    <span class="comment">//i++;</span></span><br><span class="line">    <span class="comment">//cn++;此时cn值是next[i-1]的值，这个i是更新后的i</span></span><br><span class="line">    next[i++] = ++cn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前跳到cn位置的字符，和i-1位置的字符配不上</span></span><br><span class="line"><span class="comment">//cn得往前跳，即它的k值</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    cn = next[cn];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cn &lt;= 0，没办法往前跳了</span></span><br><span class="line"><span class="comment">//此时next[i]为0</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    next[i++] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>该过程的时间复杂度是线性的，O(n)</p><p>将while循环的调用和一些变量的变化幅度绑定在一起，这个循环一共存在在三个分支，每个分支都会让给定的参数变大，i1是N，i1-i2同样也是N，于是循环体内的总数据变化浮动是2N，因此可以证明该过程的时间复杂度是线性的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i1 &lt; str1.length &amp;&amp; i2 &lt; next.length)&#123;</span><br><span class="line">          <span class="comment">//匹配则str1和str2都加一</span></span><br><span class="line">          <span class="keyword">if</span>(str1[i1] == str2[i2])&#123;</span><br><span class="line">              i1++;</span><br><span class="line">              i2++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//str2当前位置为0，等同与i2 == 0</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(next[i2] == -<span class="number">1</span>)&#123;</span><br><span class="line">              i1++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//此时str1和str2不匹配，通过nextArray往前跳，得到i2应该在的下一个位置</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              i2 = next[i2];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240726164120.png" alt="image-20240726164118835"></p><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>求解字符串中最长回文子串问题</p><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><p>一个位置的最长回文半径，回文半径数组</p><h3 id="目标问题的经典解法"><a href="#目标问题的经典解法" class="headerlink" title="目标问题的经典解法"></a>目标问题的经典解法</h3><p>常见求解这个问题，以某个点为中心向外扩充，然后去判断。但是会错过长度为偶数的回文串。</p><p>使用以下方法就可以求解，不跳过新加入的 # 标志字符，最后结果除以2就能得到原字符串的该长度的回文子串的长度</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240727162517.png" alt="image-20240727162345539"></p><h4 id="求解的思考"><a href="#求解的思考" class="headerlink" title="求解的思考"></a>求解的思考</h4><p>新加入的内容 # 对于是不是原字符串中出现过的字符没有要求</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O（N^2)</p><p>举一个极的例子，左右两边每一次都可以直接过，都访问到边界</p><p>索引为3的位置，左边到边界，右边到边界，在索引3这个循环内，遍历的字符串，所以时间复杂度是O（n^2)</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240727163328.png" alt="image-20240727163137381"></p><h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><h4 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h4><p>回文半径，回文直径。这俩的概念非常直接</p><p>回文半径数组：在从左往右遍历的过程，将所生成的回文半径记录下来</p><p>之前所扩的所有位置中所达到的最右右边界： int R &#x3D; -1;从左到右扩张的过程中，每次回文的右侧的右边界变大，R的值随之变动，所记录的值是该位置的索引。</p><p>取得更远边界的时候中心的位置索引：int C . C随R的变动而变动</p><h4 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h4><p>条件1，当查询的点不在R值范围内，使用该问题的经典解法进行暴力扩展，没有优化</p><p>条件2，查询的点在R范围内，这时候必然存在C&lt;i&lt;R，此时根据R和C找到该回文串的左侧左边界L，点 i 绕着 中心点 C 做一个对称点 j </p><p>在条件2 下可以接着细分</p><p>​      条件2-1， 以点 j  为中心的回文彻底在LR范围内（j 的回文信息可以通过回文半径数组获得），i 的回文半径跟 j 是一样的</p><p>​      条件2-2，以点 j 为中心的回文有一部超出了 LR范文，&lt;L，这个时候对应的回文串的回文半径是 i 到 R。证明：但凡不一样一点，i 的回文串越过了R ，即代表 越过的内容肯定包含 j 越过 L 的部分，那么此时R就不成立，所以是这个结论。</p><p>和条件2-1一样，都是使用到了回文串左右对照这一特性</p><p>​    条件2-3，以点 j 为中心的回文压线L，I R 这段区域是可以确定的，再往外就不确定，首先就第一种情况，是因为当 i 扩张，对应的 j 肯定也要扩张，在这里限制着，压线就没有 j  的限制，因此大小不确定，这个时候从R往外扩就行，相当于一个加速。</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O（N)</p><p>证明：</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240727180301.png" alt="image-20240727180256602"></p><p>如上图所示：每一个点都会经历一个错的过程，所以错失可以估计的，即N</p><p>然后就成功扩充，在四个分支中，一旦出现扩充的行为，就会出现R增大的情况，而R最大的变化幅度同样是N</p><p>因此时间复杂度是O（N)</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] manacherString(String s) &#123;</span><br><span class="line">        <span class="type">char</span>[] charArr = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[s.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; ++i) &#123;</span><br><span class="line">            res[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">&#x27;#&#x27;</span> : s.charAt(index++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxLengthOfPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] str  = manacherString(s);</span><br><span class="line">    <span class="comment">//回文半径数组</span></span><br><span class="line">    <span class="type">int</span>[] pArr = <span class="keyword">new</span> <span class="title class_">int</span>[ str.length];</span><br><span class="line">    <span class="comment">// 整体最右回文右边界的下一个位置，最右的有效区是R-1位置，与讲解时不一样   L[...C...]R</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 整体最右回文时的回文半径中心</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">C</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//扩出来的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个位置都求回文半径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;  str.length; ++i) &#123;</span><br><span class="line">        <span class="comment">//不用验证也知道的i至少的回文区域，先给pArr[i],四种情况都对，可以验证</span></span><br><span class="line">        <span class="comment">//R &lt;= i i在R外，至少不用验证的区域为1，对应情况1</span></span><br><span class="line">        <span class="comment">//R &gt; i i在R内，至少不用验证的区域为为  i‘的位置对应的回文半径 和 R-i中 的最小值，对应 情况2 的1,2,3</span></span><br><span class="line">        <span class="comment">//i&#x27;的位置 = R - (R - C) * 2 + (R - i) = R - 2R + 2C + R - i = 2 * C - i</span></span><br><span class="line">        pArr[i] = R &gt; i ? Math.min(pArr[ <span class="number">2</span> * C - i], R - i) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//四种情况都往外扩，情况2的1 2 只会执行一次就会失败，这样写是为了省略代码，不需要if else判断多种情况</span></span><br><span class="line">        <span class="keyword">while</span> (i + pArr[i] &lt;  str.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i + pArr[i]] == str[i - pArr[i]]) &#123;</span><br><span class="line">                pArr[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + pArr[i] &gt; R) &#123;</span><br><span class="line">            R = i + pArr[i];</span><br><span class="line">            C = i;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, pArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 返回值s字符串的最大回文长度 等于改造的字符串的最大回文半径 - 1</span></span><br><span class="line"><span class="comment">     * eg.</span></span><br><span class="line"><span class="comment">     *    1221  ==&gt; #1#2#2#1#   返回值为 5-1 = 4</span></span><br><span class="line"><span class="comment">     *    12321 ==&gt; #1#2#3#2#1# 返回值为 6-1 = 5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> max - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab43534c1234321ab&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;s1: &quot;</span> + maxLengthOfPalindrome(s1));</span><br><span class="line">    System.out.println(<span class="string">&quot;s2: &quot;</span> + maxLengthOfPalindrome(s2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="概念引入-1"><a href="#概念引入-1" class="headerlink" title="概念引入"></a>概念引入</h3><p>双端队列：两端都可以插入和删除</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>LR分别是滑动窗口的左右两端，R前进，则从尾部向双端队列插入数据，如果插入数据后不能维持单调性，弹出双端队列中的数据直到可以维持单调性，L前进，看双端队列的头部存放的索引是不是此次滑动窗口滑出的索引，如果是就从头部弹出该元素，不是不管。</p><p>当索引对应的值相同的时候，从尾部弹出已有的索引，插入新的索引</p><p>双端队列的单调性保持的是在L弹出的数据后下一个最大值</p><h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O（N)：每个元素最多进出双端队列的可能性是1次，因此时间复杂度是O（N），单点平均时间复杂度O（1），可能会存在单次插入操作的时间复杂度峰值飙升，比如说要插入的索引指向的元素比双端队列的头部最大元素要大，这个时候需要全部弹出，就不是O（1），总的复杂度还是O（1），还是因为每个元素最多进出一次，这次出去了，下次窗口缩小弹出的时候就不需要操作。</p><h3 id="处理示例"><a href="#处理示例" class="headerlink" title="处理示例"></a>处理示例</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240728110621.png" alt="image-20240728110616213"></p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h3><p>求一个数左边距离最近比自身大的，右边距离最近比自身大的</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>维持一个栈结构从底到顶部的单调性，新加入的元素栈顶的元素如果比它小，弹出栈顶元素,</p><p>当一个数被弹出 的时候，此时的栈顶元素和要被压入的元素分别是它的左边最大和右边最大</p><p>出现相同元素的时候</p><p>将相同元素压缩在一个数据结构中，需要该结构内的数据全部弹出后，才能继续向栈中压入数据</p><p>建议放入链表，在C++中也可以使用linkedList，双向链表</p><p><img src="/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95.assets/image-20240728113726014.png" alt="image-20240728113726014"></p><h4 id="过程证明"><a href="#过程证明" class="headerlink" title="过程证明"></a>过程证明</h4><p>可以自行分析过程</p><h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O（n）</p><p>每个数都只会插入一次栈</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>定义：数组中累计和与最小值的乘积 ，假设称为指标A</p><p>问题，给定一个数组，返回子数组中，指标A的最大值</p><h4 id="大流程"><a href="#大流程" class="headerlink" title="大流程"></a>大流程</h4><p>要求每一个数都是自己所在子数组的最小值，求出指标A最大的情况，最终问题的结果一定在这些结果中间</p><h4 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h4><p>每一个数左边比它小的不能扩展，右边比它小的不能扩展，这个区间就是这个数所在子数组中指标A最大的情况，</p><p>使用单调栈会很快，因为单调栈的删选过程是O（N)，在加上后来的结果结算是使用索引直接求和然后乘以这个数，所以时间复杂度得证</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240728120617.png" alt="image-20240728120614097"></p>]]></content>
      
      
      <categories>
          
          <category> 左神算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alogrithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左神算法——二叉树进阶</title>
      <link href="/posts/5469c068.html"/>
      <url>/posts/5469c068.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="二叉树进阶"><a href="#二叉树进阶" class="headerlink" title="二叉树进阶"></a>二叉树进阶</h1><h2 id="树形dp的套路"><a href="#树形dp的套路" class="headerlink" title="树形dp的套路"></a>树形dp的套路</h2><p>可能性罗列，左右树分别可能收集什么样的信息</p><h3 id="过程总结"><a href="#过程总结" class="headerlink" title="过程总结"></a>过程总结</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729143756.png" alt="image-20240729143752703"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>规定 距离 是二叉树中任意连个node之前的node数量加上二者本身的数量和</p><p>求一棵二叉树中的最大距离</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>问题拆解，每一个子问题可以看做是1，不考虑根节点的距离，2，必须纳入根节点的距离</p><p>前者是根节点两棵子树的最大距离，后者是左右子树的高度和，由此对于树形dp套路中问左右字数要内容的结构就包含自己的最大值和高度。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729143232.png" alt="image-20240729143227677"></p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>一家公司人员结构可以看做一棵多叉树结构，每个人结构中包含一个int类型的欢乐值和下级，现在需要开一个排队，需要达到要求来人让欢乐值最大，但是员工的直接上下级不能同时出现。</p><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>还是从每一棵子树上进行分解，将这棵子树的欢乐值情况列举出来，首先是根节点来的情况，那么所有直接子节点就不来，然后是根节点不来的情况，最大欢乐值就变成了看每棵子树或者不来的最大值，因此可以由此确定返回值的结构，双int，分别代表根节点来或不来的最大欢乐值。</p><p>注意在遇见题目的时候不要跳过条件分解这一大前提，直接按照经验去构造解题过程必然会导致带着优化代码的目的去再次审题，容易陷入误区，建议还是跟着步骤走：分析条件，得出结构，编写代码。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240730115251.png" alt="image-20240729150421783"></p><h2 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一种遍历二叉树方式，时间复杂度为O(N)，空间复杂度为O(1)</p><p>通过利用原树中大量空闲指针的方式，达到节省空间的目的</p><p>本质上这是一种通过改变节点指向来遍历的方法，所以具体使用还需要看题目要求，而且一般这个方法多用在面试</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729150939.png" alt="image-20240729150935006"></p><h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><p>这种遍历实质上是对递归过程的模拟，在一个递归过程中，一个节点一共会被访问三次，这些是被通过递归过程的返回操作完成的，</p><p>Morris则是利用右node对cur的关联性进行访问，一旦访问一个node 的右节点，那么这node就彻底回不去了</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729153411.png" alt="image-20240729153407692"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729155028.png" alt="image-20240729155024594"></p><h3 id="先中后序遍历加工"><a href="#先中后序遍历加工" class="headerlink" title="先中后序遍历加工"></a>先中后序遍历加工</h3><h4 id="先序"><a href="#先序" class="headerlink" title="先序"></a>先序</h4><p>对于所有位置，只能到达一次，直接打印，如果能达到两次，第一次打印</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729155320.png" alt="image-20240729155316737"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729155540.png" alt="image-20240729155535848"></p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>只经历一次的节点，直接打印，会经历两次的节点，第二次打印</p><p>由于这俩是直接在原有的Morris上更改的，只展示不同的地方</p><p>因为图中的continue会让在能经过两地的node略过本次循环内容，不会触碰到打印行为</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729160013.png" alt="image-20240729160009855"></p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729160844.png" alt="image-20240729160841441"></p><p>流程是对于所有只能到一次的数不管，在第二次的到达可以到两次的数时，执行步骤1，当左子树右边界处理完后，执行步骤2</p><p>如何逆序打印左子树右边界</p><p>单链表的逆序操作</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729164052.png" alt="image-20240729164048900"></p><p>后序遍历代码实现</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729164320.png" alt="image-20240729164316635"></p><h3 id="Morris遍历应用"><a href="#Morris遍历应用" class="headerlink" title="Morris遍历应用"></a>Morris遍历应用</h3><p>判断二叉树是不是搜索二叉树</p><h3 id="二叉树递归套路和Morris是不是最优解"><a href="#二叉树递归套路和Morris是不是最优解" class="headerlink" title="二叉树递归套路和Morris是不是最优解"></a>二叉树递归套路和Morris是不是最优解</h3><p>解题方法中必须要对第三次回到节点有强制要求，选用递归套路；如果没有这种要求，Morris是最优解</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729233247.jpg" alt="2e182d78abe19489e7"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240729233252.jpg" alt="白丝倒地"></p>]]></content>
      
      
      <categories>
          
          <category> 左神算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alogrithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法经验</title>
      <link href="/posts/a4b89a7d.html"/>
      <url>/posts/a4b89a7d.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法解题经验"><a href="#算法解题经验" class="headerlink" title="算法解题经验"></a>算法解题经验</h1><h2 id="解题套路："><a href="#解题套路：" class="headerlink" title="解题套路："></a>解题套路：</h2><p>回溯算法：</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170601.png" alt="image-20240720152129405"></p><h2 id="1，核心条件"><a href="#1，核心条件" class="headerlink" title="1，核心条件"></a>1，核心条件</h2><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170609.png" alt="image-20240717154006594" style="zoom: 67%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170615.png" alt="image-20240717154023009" style="zoom: 67%;" /><h1 id="几个常规函数的使用"><a href="#几个常规函数的使用" class="headerlink" title="几个常规函数的使用"></a>几个常规函数的使用</h1><h2 id="string常用"><a href="#string常用" class="headerlink" title="string常用"></a>string常用</h2><ol><li>1），isalpha（），判断给定内容是不是字母，头文件 cctype.h</li><li>2），tolower()，将给定的char字母转化为小写，头文件 cctype.h</li><li>3），transform(），对给定范围内的所有内容进行一次给定操作并将结果输出到第三个参数指定的容器中，</li><li>​       有四个参数，1,2是范围的开头和结尾，3是要输出地方，4是指定操作</li><li>substr：字符串截取，接受两个参数，起始位置和长度，长度从其实位置开始算起，由string变量本身调用</li><li>判断是不是数字：isdigit（），头文件：#include<ctype>，在vs的环境中，可以被默认使用，另在 文心一言 的解释中，该方法同样存在于cctype.h的头文件中</li><li>stoll ，头文件 string，将string转换为int</li></ol><h2 id="数字常用"><a href="#数字常用" class="headerlink" title="数字常用"></a>数字常用</h2><p>1，std::accumulate()，头文件<numeric>：累加求和，同样，std：：reduce是在C++17后新加入的累计求和方法</p><p>以下代码示例就是来求vector范围内的和，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="built_in">reduce</span>(possible.<span class="built_in">begin</span>(), possible.<span class="built_in">end</span>(), <span class="number">0</span>) * <span class="number">2</span> - n;</span><br></pre></td></tr></table></figure><ol><li><p><strong>输入迭代器</strong>（<code>first</code>, <code>last</code>）：</p><ul><li><code>first</code>：指向要访问的序列（如容器）的第一个元素的迭代器。</li><li><code>last</code>：指向要访问的序列的“超过最后一个元素”的位置的迭代器（即序列末尾的下一个位置）。</li></ul><p>这两个迭代器定义了要操作的元素范围。</p></li><li><p><strong>初始值</strong>（<code>init</code>）：</p><ul><li>这是累积操作的初始值。在每次迭代中，这个值都会与序列中的元素进行某种操作（通常是加法，但也可以是其他可重载的操作）。</li></ul></li><li><p><strong>二元操作</strong>（可选，默认为<code>std::plus&lt;&gt;</code>）：</p><ul><li>这是一个二元函数对象（或者是一个可以隐式转换为函数对象的类型），它接受两个参数（通常是当前累积值和序列中的下一个元素），并返回它们的某种组合（通常是它们的和，但也可以是其他任何可定义的操作结果）。</li><li>如果不提供此参数，则默认使用<code>std::plus&lt;&gt;</code>，即执行加法操作。</li></ul></li><li><p><strong>执行策略</strong>（可选，默认为<code>std::execution::sequenced_policy</code>）：</p><ul><li>这是一个执行策略，它定义了算法的执行方式。C++17引入了三种执行策略：<code>std::execution::sequenced_policy</code>（顺序执行）、<code>std::execution::parallel_policy</code>（并行执行）和<code>std::execution::parallel_unsequenced_policy</code>（并行且向量化执行，如果可能）。</li><li>执行策略允许算法以不同的方式执行，以利用现代多核处理器的并行计算能力。但是，请注意，并行算法的正确使用需要额外的注意，以确保算法的正确性和效率。</li></ul></li></ol><h2 id="numeric头文件"><a href="#numeric头文件" class="headerlink" title="numeric头文件"></a>numeric头文件</h2><p>C++的<code>&lt;numeric&gt;</code>头文件中包含了一系列用于操作数值序列（或可通过修改参数类型适用于非数值序列）的函数。这些函数提供了基础的数值算法，便于对如<code>vector&lt;&gt;</code>、<code>list&lt;&gt;</code>等容器进行数值计算。以下是<code>&lt;numeric&gt;</code>头文件中常用的函数及其简要说明：</p><ol><li><code>std::accumulate</code><ul><li>功能：计算给定范围内元素的累积值。可以通过修改操作符来计算累乘积、累减、累除或其他自定义累计结果。</li><li>模板参数：<code>InputIterator</code>（输入迭代器类型），<code>T</code>（初始值类型），<code>BinaryOperation</code>（可选，二元操作类型）。</li><li>示例用法：计算一个<code>vector&lt;int&gt;</code>中所有元素的和。</li></ul></li><li><code>std::adjacent_difference</code><ul><li>功能：计算给定范围内相邻元素之间的差值（或自定义操作的结果），并将结果写入到输出序列中。</li><li>模板参数：<code>InputIterator</code>（输入迭代器类型），<code>OutputIterator</code>（输出迭代器类型），<code>BinaryOperation</code>（可选，二元操作类型）。</li><li>示例用法：计算一个整数数组中相邻元素之间的差值。</li></ul></li><li><code>std::inner_product</code><ul><li>功能：计算两个序列对应元素的内积，即对应元素相乘后的和（或自定义操作的结果）。</li><li>模板参数：<code>InputIterator1</code>、<code>InputIterator2</code>（两个输入迭代器类型），<code>T</code>（初始值类型），<code>BinaryOperation1</code>、<code>BinaryOperation2</code>（可选，两个二元操作类型）。</li><li>示例用法：计算两个<code>vector&lt;int&gt;</code>对应元素相乘后的和。</li></ul></li><li><code>std::partial_sum</code><ul><li>功能：计算给定范围内元素的部分和（或自定义操作的结果），并将结果写入到输出序列中。</li><li>模板参数：<code>InputIterator</code>（输入迭代器类型），<code>OutputIterator</code>（输出迭代器类型），<code>BinaryOperation</code>（可选，二元操作类型）。</li><li>示例用法：计算一个整数数组中每个位置之前所有元素的和。</li></ul></li><li><code>std::iota</code><ul><li>功能：生成一个范围内的连续整数序列，并将它们赋值给输出序列中的元素。</li><li>模板参数：<code>OutputIterator</code>（输出迭代器类型），<code>T</code>（整数类型）。</li><li>示例用法：初始化一个<code>vector&lt;int&gt;</code>，使其包含从0开始的连续整数。</li></ul></li><li>C++17新增函数<ul><li>**<code>std::gcd</code>**：计算两个整数的最大公约数。</li><li>**<code>std::lcm</code>**：计算两个整数的最小公倍数。</li><li>**<code>std::midpoint</code>**：计算两个数值的中点，避免溢出</li></ul></li></ol><h2 id="algorithm："><a href="#algorithm：" class="headerlink" title="algorithm："></a>algorithm：</h2><p>next_permutation：获取给定区间内容的下一个排列范方式，直到遍历完成所有的排列组合后false，对string也同样适用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next_permutation</span>(from.<span class="built_in">begin</span>(), from.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><p>手撕全排序算法，想起见test工程下的BackTracking专栏</p><p>lower_bound()<br>&#x2F;&#x2F;给定两个参数，a和b，a是容器，元素已经排好序，b是目标，作用是在a中找到第一个大于等于b的元素的位置并返回迭代器</p><p>upper_bound（）：给定的参数是和lower_bound一样的，不同的是，该函数在a中找到第一个大于b的</p><h1 id="算法套路："><a href="#算法套路：" class="headerlink" title="算法套路："></a>算法套路：</h1><p>创建一个长度26的int类型的数组，保存是对应的ASCII编码，在使用前需要将字母类型- ‘a’，来获取ASCII码</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170621.png" alt="image-20240713165422734"></p><p>具体手撕可见</p><p>4，std::ranges::sort()：C++20后新加入的排序，对于原有的sort排序，二者都可以对嵌套数组进行排序操作，对比元素是每个数组的0号索引位置</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170623.png" alt="image-20240718105454408"></p><h3 id="典型题目："><a href="#典型题目：" class="headerlink" title="典型题目："></a>典型题目：</h3><p>leetcode 3 无重复字符的最长子串</p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170626.png" alt="image-20240714182233599" style="zoom: 50%;" /><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170627.png" alt="image-20240714182315119" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> size = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m; <span class="comment">//key是位置上的值，value是index</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> resFalg = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tempStr = s[i];</span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">find</span>(tempStr) != m.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">resFalg = resFalg &gt; flag ? resFalg : flag;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> value = i - m[tempStr];<span class="comment">//与题目进行适配</span></span><br><span class="line">res = res &gt; value ? res : value;</span><br><span class="line"><span class="comment">//更新这个值的位置</span></span><br><span class="line">m[tempStr] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m[tempStr] = i;</span><br><span class="line">++flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">resFalg = resFalg &lt; flag ? flag : resFalg;</span><br><span class="line">res = res &gt;= resFalg ? res : resFalg;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上演示的是错误示范，在使用flag标记中，考虑到了在返回结果的时候没有找到重复元素，但是没有考虑到查找起始点位，也就是俗称的滑动窗口，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(std::string s)</span> </span>&#123;  </span><br><span class="line">      <span class="type">int</span> size = s.<span class="built_in">size</span>();  </span><br><span class="line">      <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">      std::unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m; <span class="comment">// key是字符，value是字符最后出现的位置  </span></span><br><span class="line">      <span class="type">int</span> maxLength = <span class="number">0</span>;  </span><br><span class="line">      <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">// 最长子串的起始位置  </span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;  </span><br><span class="line">          <span class="keyword">if</span> (m.<span class="built_in">find</span>(s[i]) != m.<span class="built_in">end</span>() &amp;&amp; m[s[i]] &gt;= start) &#123;  </span><br><span class="line">              <span class="comment">// 如果当前字符在之前的子串中出现过，并且位置在当前子串范围内  </span></span><br><span class="line">              <span class="comment">// 更新起始位置为当前字符上一次出现位置的下一个位置  </span></span><br><span class="line">              start = m[s[i]] + <span class="number">1</span>;  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="comment">// 更新当前字符的最后出现位置  </span></span><br><span class="line">          m[s[i]] = i;  </span><br><span class="line">          <span class="comment">// 更新最长子串的长度  </span></span><br><span class="line">          maxLength = std::<span class="built_in">max</span>(maxLength, i - start + <span class="number">1</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> maxLength;  </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure><h2 id="2，二维数组寻找各行各列最高值"><a href="#2，二维数组寻找各行各列最高值" class="headerlink" title="2，二维数组寻找各行各列最高值"></a>2，二维数组寻找各行各列最高值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出每行和每列的最大值  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">rowMax[i] = std::<span class="built_in">max</span>(rowMax[i], grid[i][j]);</span><br><span class="line">colMax[j] = std::<span class="built_in">max</span>(colMax[j], grid[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯："><a href="#回溯：" class="headerlink" title="回溯："></a>回溯：</h3><p>1，求子集和分割的解法很像：</p><p>分割</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> (index == n)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, index, i))</span><br><span class="line">&#123;</span><br><span class="line">path.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(index, i - index + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line"><span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="N皇后问题："><a href="#N皇后问题：" class="headerlink" title="N皇后问题："></a>N皇后问题：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; BackTracking::<span class="built_in">solveNQueens</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(n)</span>, <span class="title">on_path</span><span class="params">(n)</span>, <span class="title">diag1</span><span class="params">(n * <span class="number">2</span> - <span class="number">1</span>)</span>, <span class="title">diag2</span><span class="params">(n * <span class="number">2</span> - <span class="number">1</span>)</span></span>;</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> r) &#123;</span><br><span class="line"><span class="keyword">if</span> (r == n) &#123;</span><br><span class="line">vector&lt;string&gt; <span class="built_in">board</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">board[i] = <span class="built_in">string</span>(col[i], <span class="string">&#x27;.&#x27;</span>) + <span class="string">&#x27;Q&#x27;</span> + <span class="built_in">string</span>(n - <span class="number">1</span> - col[i], <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ans.<span class="built_in">emplace_back</span>(board);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123;</span><br><span class="line"><span class="type">int</span> rc = r - c + n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!on_path[c] &amp;&amp; !diag1[r + c] &amp;&amp; !diag2[rc]) &#123;</span><br><span class="line">col[r] = c;</span><br><span class="line">on_path[c] = diag1[r + c] = diag2[rc] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(r + <span class="number">1</span>);</span><br><span class="line">on_path[c] = diag1[r + c] = diag2[rc] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n皇后操作其实并不难，只是后来加进去的的皇后棋都会被之前加入的棋子约束，一开始很容易想到在保存使用数组按照点的形式保存下来，但是这之后每次筛查点的时候都需要遍历之前保存的棋子，时间复杂度很高，以上代码给出一种新的方式。</p><h3 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170638.png" alt="image-20240724152332341"></p><p>动态规划背包问题常见变形</p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170640.png" alt="image-20240724153617434"></p><p>完全背包优化到最后的结果：</p><p><img src="/%E7%AE%97%E6%B3%95%E7%BB%8F%E9%AA%8C.assets/image-20240724185655022.png!%5Bimage-20240724185829215%5D(https:/gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170642.png" alt="image-20240724185655022"></p><p>如上图所示：基本处理逻辑仍然是遵循不选和选这一基本操作，只是在memo的上对不需要的数据进行了覆盖处理，</p><p>对0索引位置上的数据初始化一个0是为了让当前硬币x就可以组成目前需要的值</p><h1 id="VS快捷操作经验："><a href="#VS快捷操作经验：" class="headerlink" title="VS快捷操作经验："></a>VS快捷操作经验：</h1><p>ctrl + K + O：在头文件和cpp中快速切换</p><p>xml注释换行：<para> </para> 将要新一行的内容包裹起来</p><h1 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>1.对于vector，一开始就规定大小然后使用索引访问要比push_back（）快上很多</p><h2 id="常规操作："><a href="#常规操作：" class="headerlink" title="常规操作："></a>常规操作：</h2><p>1，back()：返回容器中最后一个元素，</p><p>2，优先级队列：</p><p>以下内容是在优先级队列中使用自定义变量并设置自定义比较标准的示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myCompare = [](ListNode* node1, ListNode* node2) &#123;</span><br><span class="line"><span class="keyword">return</span> node1-&gt;value &lt; node2-&gt;value;</span><br><span class="line">&#125;;</span><br><span class="line">std::priority_queue&lt;ListNode*,std::vector&lt;ListNode*&gt;,<span class="keyword">decltype</span>(myCompare)&gt; <span class="built_in">heapSortO</span>(myCompare);</span><br></pre></td></tr></table></figure><p>以下是优先级队列使用lamba表达式快速构建自定义比较类型的例子，注意，使用greater（greater自带的比较器）是小根堆，即 return i&gt;j；i在参数中是前者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>([](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; i, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; j) &#123;<span class="keyword">return</span> i.first &gt; j.first; &#125;) &gt; pq;</span><br></pre></td></tr></table></figure><h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><h3 id="清空内存"><a href="#清空内存" class="headerlink" title="清空内存"></a>清空内存</h3><p>1，在STL中某些容器不提供清空操作的前提下，快速清空指定内存，例如清空栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(sta); <span class="comment">//清空栈</span></span><br></pre></td></tr></table></figure><p>具体的底层内存操作过程如下：</p><ol><li>创建了一个空的临时<code>std::stack&lt;int&gt;</code>对象。</li><li>这个临时对象与<code>sta</code>进行了<code>swap</code>操作，导致<code>sta</code>的内容被清空，而临时对象现在包含了<code>sta</code>原来的内容。</li><li>临时对象在表达式结束时被销毁。销毁过程中，如果临时对象内部有动态分配的内存（例如，<code>std::deque</code>可能会为其元素分配堆内存），则这些内存会被回收（通过调用析构函数和可能的内存释放操作）。但是，请注意，这里的“回收”并不意味着内存被立即返回给操作系统；它可能只是被标记为可重用，以便后续的堆分配可以重用这些内存块。</li></ol><h3 id="删除内容："><a href="#删除内容：" class="headerlink" title="删除内容："></a>删除内容：</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170645.png" alt="image-20240720172221617"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170647.png" alt="image-20240720172907972"></p><p>通过以上内容可以知道：容器在保存node指针的时候类似于在函数传递过程中的形参，构造了一个新的指针并拷贝了原始指针，</p><p>因为node的数据是保存在堆上的，所以现在相当于在栈和堆上同时拥有一份指向保存在堆上的node地址的指针，对node值的修改可以做到同步，删除原始指针或者map的都不会对最终的结果产生影响。</p><p>所以建议在创建node的时候还是new一个，因为容器最终是要释放掉的</p><h2 id="2，特殊操作"><a href="#2，特殊操作" class="headerlink" title="2，特殊操作"></a>2，特殊操作</h2><h3 id="判断内容相等"><a href="#判断内容相等" class="headerlink" title="&#x3D;&#x3D;判断内容相等"></a>&#x3D;&#x3D;判断内容相等</h3><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170657.png" alt="image-20240716154802788"></p><p><img src="https://gitee.com/cat-hair-hutao/images/raw/master/Typora/20240725170658.png" alt="image-20240716155146719"></p><h1 id="不熟悉但是重要的特性："><a href="#不熟悉但是重要的特性：" class="headerlink" title="不熟悉但是重要的特性："></a>不熟悉但是重要的特性：</h1><p>lamba表达式：</p><p>auto :自动变量标签 </p><p>reverse定义变量名</p><p>&amp;，&#x3D;：在中括号内使用这两个参数，编辑器自动捕获需要的内容，捕获的方式分别是引用捕获和值捕获</p><p>值捕获：在lamba表达式被创建的时候就完成值的复制，之后对值的修改无影响</p><p>引用捕获：顾名思义，和方法的引用传递差不多，但是主要注意调用的时候捕获的值的存在与否之类的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> reverse = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i++], nums[j--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    k %= n; <span class="comment">// 轮转 k 次等于轮转 k%n 次</span></span><br><span class="line">    <span class="built_in">reverse</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(k, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20240718114132322.png" alt="image-20240718114132322"></p><p>自我调用的两种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">ans.<span class="built_in">emplace_back</span>(path);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123; <span class="comment">// 枚举选择的数字</span></span><br><span class="line">path.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line"><span class="built_in">dfs</span>(dfs, j + <span class="number">1</span>);</span><br><span class="line">path.<span class="built_in">pop_back</span>(); <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line"><span class="built_in">dfs</span>(i<span class="number">+1</span>);</span><br><span class="line">path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lamba在使用auto这种不完成的类型进行自我调用的时候需要使用第一种形式，第二种就是完整的调用流程，头文件<functional></p>]]></content>
      
      
      <categories>
          
          <category> Alogrithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
